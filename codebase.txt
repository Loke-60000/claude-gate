// File: CHANGELOG.md

# Changelog

All notable changes to Claude Gate will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.1.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [Unreleased]

### Added
- Interactive server monitoring dashboard with real-time metrics
- OAuth flow with interactive TUI and browser automation
- Bubble Tea UI foundation for enhanced CLI experience
- Comprehensive documentation structure

### Changed
- Reorganized documentation into logical categories
- Standardized port configuration to 8080
- Improved authentication flow with better error handling

### Fixed
- Dashboard requests/sec metric showing 0.0
- Various documentation inconsistencies

## [0.1.0] - 2024-01-01

### Added
- Initial release
- OAuth/PKCE authentication with Claude Pro/Max accounts
- HTTP proxy server for Anthropic API
- Cross-platform support (macOS, Linux)
- NPM package distribution
- Basic CLI commands (auth, start, stop, status)
- Environment variable configuration
- Secure token storage

[Unreleased]: https://github.com/ml0-1337/claude-gate/compare/v0.1.0...HEAD
[0.1.0]: https://github.com/ml0-1337/claude-gate/releases/tag/v0.1.0
// End of CHANGELOG.md

=====================

// File: CLAUDE.md

# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

Claude Gate is a high-performance Go OAuth proxy for Anthropic's Claude API that enables FREE Claude usage for Pro/Max subscribers by identifying as "Claude Code" (Anthropic's official CLI). This is the official Go port of the original Python implementation.

**Key Features:**
- OAuth 2.0 PKCE authentication flow
- Secure token storage with OS keychain integration (planned)
- Interactive TUI dashboard for monitoring
- Cross-platform support (macOS, Linux, Windows)
- Multiple distribution methods (NPM, Homebrew, direct binary)

## Quick Navigation

### Core Implementation Files
- Main entry: `cmd/claude-gate/main.go`
- OAuth client: `internal/auth/client.go`
- Proxy handler: `internal/proxy/handler.go`
- Dashboard: `internal/ui/dashboard/dashboard.go`

### Configuration Files
- Go module: `go.mod`
- Build config: `.goreleaser.yml`
- CI/CD: `.github/workflows/release.yml`
- NPM package: `npm/package.json`

### Test Files
- Unit tests: `*_test.go` (alongside source)
- Integration: `internal/test/integration/*_test.go`
- E2E: `internal/test/e2e/*_test.go`
- Test helpers: `internal/test/helpers/helpers.go`

### Scripts
- Version update: `scripts/update-version.sh`
- NPM test: `scripts/test-npm-local.sh`
- Add co-author: `.claude/scripts/add-claude-coauthor.sh`

## Common Commands

### Building
```bash
make build        # Build for current platform
make snapshot     # Build all platforms (uses GoReleaser)
make install      # Install to ~/bin
```

### Testing
```bash
make test              # Run unit tests with coverage
make test-unit         # Run unit tests only (short mode)
make test-integration  # Run integration tests
make test-e2e          # Run end-to-end tests
make test-all          # Run all test types
make npm-test          # Test NPM package locally
go test -v ./...       # Quick test during development
```

### Running
```bash
claude-gate start --host 127.0.0.1 --port 5789  # Start proxy server
claude-gate dashboard                            # Start with interactive dashboard
claude-gate auth login                           # Authenticate with Claude
```

### Releasing
```bash
make release VERSION=0.2.0  # Create new release
./scripts/update-version.sh # Update version in all files
```

## Architecture

The codebase follows clean architecture principles with clear separation of concerns:

### Core Components

1. **CLI Layer** (`cmd/claude-gate/`)
   - Uses Kong framework for command parsing
   - Entry point for all operations

2. **Auth Package** (`internal/auth/`)
   - OAuth 2.0 PKCE implementation
   - Token storage and management
   - Browser automation for login flow

3. **Proxy Package** (`internal/proxy/`)
   - HTTP proxy server implementation
   - Request/response transformation
   - Enhanced server with monitoring capabilities

4. **UI Package** (`internal/ui/`)
   - Bubble Tea-based TUI components
   - Interactive dashboard for monitoring
   - Reusable components (spinner, progress, styles)

### Request Flow
1. Client connects to local proxy (default: 127.0.0.1:5789)
2. Proxy validates authentication token
3. Request transformed to identify as "Claude Code"
4. Forwarded to Claude API with OAuth credentials
5. Response streamed back to client

### Security Model
- OAuth 2.0 PKCE flow for authentication
- Tokens stored securely (keychain integration planned)
- Local-only proxy binding by default
- Optional proxy authentication token for additional security

## Project Structure

```
claude-gate/
├── cmd/
│   └── claude-gate/          # CLI application entry point
│       ├── main.go          # Main entry point with Kong CLI setup
│       └── auth_storage.go  # Storage-related CLI commands
├── internal/                 # Private application code (Go convention)
│   ├── auth/                # Authentication & token management
│   │   ├── client.go        # OAuth client implementation
│   │   ├── oauth.go         # OAuth flow logic
│   │   ├── storage_*.go     # Various storage backends
│   │   └── *_test.go        # Unit tests
│   ├── config/              # Configuration management
│   ├── proxy/               # Proxy server implementation
│   │   ├── handler.go       # Main proxy handler
│   │   ├── server.go        # Enhanced server with monitoring
│   │   └── transformer.go   # Request/response transformation
│   ├── test/                # Test infrastructure
│   │   ├── integration/     # Integration tests (build tag: integration)
│   │   ├── e2e/            # End-to-end tests (build tag: e2e)
│   │   ├── helpers/        # Shared test utilities
│   │   └── testdata/       # Test fixtures
│   └── ui/                  # Terminal UI components
│       ├── components/      # Reusable UI components
│       ├── dashboard/       # Interactive dashboard
│       ├── styles/         # Terminal styling (Lipgloss)
│       └── utils/          # UI utilities
├── docs/                    # Project documentation
│   ├── architecture/       # Architecture decisions and diagrams
│   ├── deployment/         # Deployment guides
│   ├── getting-started/    # User guides
│   └── testing/           # Testing documentation
├── npm/                    # NPM package distribution
│   ├── package.json       # Main NPM package
│   ├── platforms/         # Platform-specific packages
│   └── scripts/           # Installation scripts
├── scripts/               # Build and utility scripts
├── .github/              # GitHub Actions workflows
│   └── workflows/        # CI/CD pipelines
├── .claude/              # Claude-specific files
│   ├── todos/           # Active todo files
│   ├── archive/         # Completed todos
│   └── scripts/         # Claude utility scripts
├── Makefile             # Build automation
├── go.mod              # Go module definition
└── .goreleaser.yml     # GoReleaser configuration
```

### File Naming Conventions
- Test files: `*_test.go` alongside source files
- Integration tests: `*_integration_test.go` with build tags
- E2E tests: `*_e2e_test.go` with build tags
- Mock implementations: `mock_*.go`
- Interfaces: Often in the same file as primary implementation

### Key Files
- Entry point: `cmd/claude-gate/main.go`
- OAuth config: `internal/auth/oauth.go` (contains client ID)
- Proxy handler: `internal/proxy/handler.go`
- Dashboard UI: `internal/ui/dashboard/dashboard.go`
- Storage factory: `internal/auth/storage_factory.go`

## Testing Strategy

The project uses Test-Driven Development (TDD) with comprehensive test coverage:

- **Unit Tests**: Alongside source files (`*_test.go`)
- **Integration Tests**: `internal/test/integration/`
- **E2E Tests**: `internal/test/e2e/`
- **Cross-Platform Tests**: Via Docker containers
- **NPM Package Tests**: Validates installation and binary selection

Always write tests before implementing features. Use testify for assertions.

## TDD Requirements (MANDATORY)

**IMPORTANT**: This project follows the strict TDD workflow defined in the system CLAUDE.md. Test-first development is MANDATORY, not optional.

### The Red-Green-Refactor-Commit (RGRC) Cycle

1. **Red Phase**: Write failing tests FIRST
   ```bash
   # Write test in *_test.go file
   go test -v ./path/to/package -run TestNewFeature
   # Verify test fails before proceeding
   ```

2. **Green Phase**: Write MINIMUM code to pass
   ```bash
   # Implement just enough to make tests pass
   go test -v ./path/to/package -run TestNewFeature
   # All tests should now pass
   ```

3. **Refactor Phase**: Improve code quality
   ```bash
   # Clean up implementation while keeping tests green
   make test  # Run full test suite with race detection
   ```

4. **Commit Phase**: Save progress
   ```bash
   git add -A
   git commit -m "test: Add tests for [feature]"
   git commit -m "feat: Implement [feature] to pass tests"
   ```

### When TDD is MANDATORY

- **New Features**: Write acceptance tests first
- **Bug Fixes**: Write test that reproduces bug first
- **Refactoring**: Ensure tests exist before changing
- **API Changes**: Contract tests before implementation

### Go-Specific TDD Patterns

```go
// Example: Table-driven test (write BEFORE implementation)
func TestAuthenticateRequest(t *testing.T) {
    tests := []struct {
        name    string
        token   string
        want    bool
        wantErr bool
    }{
        {"valid token", "Bearer valid-token", true, false},
        {"invalid token", "Bearer invalid", false, true},
        {"missing token", "", false, true},
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            got, err := AuthenticateRequest(tt.token)
            if tt.wantErr {
                assert.Error(t, err)
            } else {
                assert.NoError(t, err)
                assert.Equal(t, tt.want, got)
            }
        })
    }
}
```

## Development Workflow

**REMINDER**: All development MUST follow the TDD workflow. No exceptions.

1. **Feature Development** (TDD MANDATORY)
   - Create feature branch
   - **RED**: Write failing tests first
   - Verify tests fail (run `go test -v`)
   - **GREEN**: Implement minimum code to pass
   - Verify all tests pass
   - **REFACTOR**: Clean up implementation
   - Run `make test-all`
   - **COMMIT**: Tests and implementation together
   - Submit PR with tests passing

2. **Bug Fixes** (TDD MANDATORY)
   - **RED**: Write test that reproduces bug
   - Verify test fails with current code
   - **GREEN**: Fix the issue
   - Ensure all tests pass
   - **REFACTOR**: Improve fix if needed
   - **COMMIT**: Test and fix together
   - Document in TROUBLESHOOTING.md if user-facing

3. **Documentation Updates**
   - Update relevant docs in `docs/`
   - Keep README.md concise
   - Add troubleshooting entries as needed

## NPM Package Management

The project distributes platform-specific binaries via NPM:

- Main package: `npm/package.json`
- Platform packages: `npm/platforms/*/package.json`
- Installation scripts: `npm/scripts/`
- Binary wrappers: `npm/bin/`

Test NPM changes with: `make npm-test`

## Key Dependencies

- **Kong**: CLI framework for command parsing
- **Bubble Tea**: Terminal UI framework
- **Lipgloss**: Terminal styling
- **Testify**: Testing assertions and mocks
- **GoReleaser**: Multi-platform release automation

## Release Process

1. Update version: `./scripts/update-version.sh`
2. Create release: `make release VERSION=x.y.z`
3. Push tags: `git push origin main && git push origin vx.y.z`
4. GitHub Actions automatically:
   - Builds binaries for all platforms
   - Publishes to NPM registry
   - Creates GitHub release

## Important Patterns

- **TEST FIRST**: Never write implementation before tests
- Use `internal/` for private packages (Go convention)
- Follow clean architecture: separate concerns between packages
- Use interfaces for testability and flexibility
- Implement context propagation for cancellation
- Handle errors explicitly, never ignore them
- Use structured logging with clear messages
- Write self-documenting code with meaningful names

## System CLAUDE.md Compliance

This project adheres to all laws and workflows defined in the system CLAUDE.md, including:
- **Law 1**: NEVER Code Without Approval
- **Law 2**: Plan-First Workflow
- **Law 3**: Document Everything
- **Law 4**: Test-First for Features & Fixes (MANDATORY)

Refer to system CLAUDE.md for complete workflow requirements.

## Contribution Guidelines

See CONTRIBUTING.md for detailed guidelines. Key points:
- All code must have tests
- Follow Go best practices and idioms
- Use `go fmt` and `go vet`
- Document public APIs
- Sign commits with GPG key
- Squash commits before merging

## Utility Scripts

- `.claude/scripts/add-claude-coauthor.sh [num_commits]` - Add Claude as co-author to recent commits (default: 10)
  - Creates backup branch before making changes
  - Use when commits are missing Claude co-author attribution

## Important Instruction Reminders

The following instructions are inherited from system CLAUDE.md and apply to ALL work in this project:

- **ALWAYS** use Test-Driven Development (Red-Green-Refactor-Commit)
- **NEVER** write code without tests failing first
- **ALWAYS** get approval before implementing
- **ALWAYS** create todos for task tracking
- **ALWAYS** document all decisions and research

When in doubt, refer to system CLAUDE.md for the complete workflow.
// End of CLAUDE.md

=====================

// File: cmd/claude-gate/auth_storage.go

package main

import (
	"fmt"
	"os"

	"github.com/alecthomas/kong"
	"github.com/ml0-1337/claude-gate/internal/auth"
	"github.com/ml0-1337/claude-gate/internal/config"
)

// AuthStorageCmd handles auth storage management commands
type AuthStorageCmd struct {
	Status  AuthStorageStatusCmd  `cmd:"" help:"Show storage backend status"`
	Migrate AuthStorageMigrateCmd `cmd:"" help:"Migrate tokens between storage backends"`
	Test    AuthStorageTestCmd    `cmd:"" help:"Test storage backend operations"`
	Backup  AuthStorageBackupCmd  `cmd:"" help:"Create manual backup of tokens"`
	Reset   AuthStorageResetCmd   `cmd:"" help:"Reset keychain items with proper trust settings"`
}

// AuthStorageStatusCmd shows storage backend status
type AuthStorageStatusCmd struct{}

func (cmd *AuthStorageStatusCmd) Run(ctx *kong.Context) error {
	cfg := config.DefaultConfig()
	cfg.LoadFromEnv()
	
	// Create storage factory
	factory := auth.NewStorageFactory(createStorageFactoryConfig(cfg))
	
	// Get current storage
	storage, err := factory.Create()
	if err != nil {
		return fmt.Errorf("failed to create storage: %w", err)
	}
	
	fmt.Println("Storage Backend Status")
	fmt.Println("=====================")
	fmt.Printf("Type: %s\n", cfg.AuthStorageType)
	fmt.Printf("Backend: %s\n", storage.Name())
	fmt.Printf("Available: %v\n", storage.IsAvailable())
	fmt.Printf("Requires Unlock: %v\n", storage.RequiresUnlock())
	
	// List stored providers
	providers, err := storage.List()
	if err != nil {
		fmt.Printf("\nError listing providers: %v\n", err)
	} else {
		fmt.Printf("\nStored Providers: %d\n", len(providers))
		if len(providers) > 0 {
			fmt.Println("\nProviders:")
			for _, provider := range providers {
				token, err := storage.Get(provider)
				if err != nil {
					fmt.Printf("  - %s: Error reading token\n", provider)
					continue
				}
				if token == nil {
					fmt.Printf("  - %s: No token\n", provider)
					continue
				}
				
				status := "Valid"
				if token.IsExpired() {
					status = "Expired"
				} else if token.NeedsRefresh() {
					status = "Needs Refresh"
				}
				
				fmt.Printf("  - %s: %s token (%s)\n", provider, token.Type, status)
			}
		}
	}
	
	// Show configuration
	fmt.Println("\nConfiguration:")
	fmt.Printf("  Storage Path: %s\n", cfg.AuthStoragePath)
	fmt.Printf("  Keyring Service: %s\n", cfg.KeyringService)
	fmt.Printf("  Auto-Migrate: %v\n", cfg.AutoMigrateTokens)
	
	return nil
}

// AuthStorageMigrateCmd migrates tokens between storage backends
type AuthStorageMigrateCmd struct {
	From   string `help:"Source storage type (file/keyring)" default:"file"`
	To     string `help:"Destination storage type (file/keyring)" default:"keyring"`
	DryRun bool   `help:"Show what would be migrated without making changes"`
}

func (cmd *AuthStorageMigrateCmd) Run(ctx *kong.Context) error {
	cfg := config.DefaultConfig()
	cfg.LoadFromEnv()
	
	// Create source storage
	sourceCfg := createStorageFactoryConfig(cfg)
	sourceCfg.Type = auth.StorageType(cmd.From)
	sourceFactory := auth.NewStorageFactory(sourceCfg)
	
	source, err := sourceFactory.Create()
	if err != nil {
		return fmt.Errorf("failed to create source storage: %w", err)
	}
	
	// Create destination storage
	destCfg := createStorageFactoryConfig(cfg)
	destCfg.Type = auth.StorageType(cmd.To)
	destCfg.FilePath = cfg.AuthStoragePath + ".migrated"
	destFactory := auth.NewStorageFactory(destCfg)
	
	destination, err := destFactory.Create()
	if err != nil {
		return fmt.Errorf("failed to create destination storage: %w", err)
	}
	
	// List tokens to migrate
	providers, err := source.List()
	if err != nil {
		return fmt.Errorf("failed to list providers: %w", err)
	}
	
	if len(providers) == 0 {
		fmt.Println("No tokens to migrate")
		return nil
	}
	
	fmt.Printf("Migrating %d tokens from %s to %s\n", len(providers), source.Name(), destination.Name())
	
	if cmd.DryRun {
		fmt.Println("\nDry run - no changes will be made:")
		for _, provider := range providers {
			fmt.Printf("  - Would migrate: %s\n", provider)
		}
		return nil
	}
	
	// Confirm migration
	fmt.Print("\nProceed with migration? [y/N]: ")
	var response string
	fmt.Scanln(&response)
	if response != "y" && response != "Y" {
		fmt.Println("Migration cancelled")
		return nil
	}
	
	// Perform migration
	migrator := auth.NewStorageMigrator(source, destination)
	if err := migrator.Migrate(); err != nil {
		return fmt.Errorf("migration failed: %w", err)
	}
	
	// Verify migration
	if err := migrator.VerifyMigration(); err != nil {
		fmt.Printf("Warning: Migration verification failed: %v\n", err)
	} else {
		fmt.Println("Migration completed and verified successfully")
	}
	
	return nil
}

// AuthStorageTestCmd tests storage backend operations
type AuthStorageTestCmd struct{}

func (cmd *AuthStorageTestCmd) Run(ctx *kong.Context) error {
	cfg := config.DefaultConfig()
	cfg.LoadFromEnv()
	
	// Create storage
	factory := auth.NewStorageFactory(createStorageFactoryConfig(cfg))
	
	storage, err := factory.Create()
	if err != nil {
		return fmt.Errorf("failed to create storage: %w", err)
	}
	
	fmt.Printf("Testing storage backend: %s\n\n", storage.Name())
	
	// Test availability
	fmt.Print("Testing availability... ")
	if storage.IsAvailable() {
		fmt.Println("✓ Available")
	} else {
		fmt.Println("✗ Not available")
		return fmt.Errorf("storage backend not available")
	}
	
	// Test set operation
	fmt.Print("Testing write operation... ")
	testToken := &auth.TokenInfo{
		Type:        "oauth",
		AccessToken: "test-token",
	}
	if err := storage.Set("test-provider", testToken); err != nil {
		fmt.Printf("✗ Failed: %v\n", err)
		return err
	}
	fmt.Println("✓ Success")
	
	// Test get operation
	fmt.Print("Testing read operation... ")
	retrieved, err := storage.Get("test-provider")
	if err != nil {
		fmt.Printf("✗ Failed: %v\n", err)
		return err
	}
	if retrieved == nil || retrieved.AccessToken != testToken.AccessToken {
		fmt.Println("✗ Token mismatch")
		return fmt.Errorf("retrieved token does not match")
	}
	fmt.Println("✓ Success")
	
	// Test list operation
	fmt.Print("Testing list operation... ")
	providers, err := storage.List()
	if err != nil {
		fmt.Printf("✗ Failed: %v\n", err)
		return err
	}
	found := false
	for _, p := range providers {
		if p == "test-provider" {
			found = true
			break
		}
	}
	if !found {
		fmt.Println("✗ Test provider not found in list")
		return fmt.Errorf("test provider not found")
	}
	fmt.Println("✓ Success")
	
	// Test remove operation
	fmt.Print("Testing remove operation... ")
	if err := storage.Remove("test-provider"); err != nil {
		fmt.Printf("✗ Failed: %v\n", err)
		return err
	}
	
	// Verify removal
	retrieved, err = storage.Get("test-provider")
	if err != nil {
		fmt.Printf("✗ Failed to verify removal: %v\n", err)
		return err
	}
	if retrieved != nil {
		fmt.Println("✗ Token still exists after removal")
		return fmt.Errorf("token not removed")
	}
	fmt.Println("✓ Success")
	
	fmt.Println("\nAll tests passed!")
	return nil
}

// AuthStorageBackupCmd creates manual backup of tokens
type AuthStorageBackupCmd struct{}

func (cmd *AuthStorageBackupCmd) Run(ctx *kong.Context) error {
	cfg := config.DefaultConfig()
	cfg.LoadFromEnv()
	
	// Only backup file storage
	if cfg.AuthStorageType != "file" {
		fmt.Println("Backup is only supported for file storage")
		fmt.Println("Keyring storage is backed up by the operating system")
		return nil
	}
	
	// Check if auth file exists
	if _, err := os.Stat(cfg.AuthStoragePath); os.IsNotExist(err) {
		fmt.Println("No auth file to backup")
		return nil
	}
	
	// Create backup
	fmt.Println("Creating backup...")
	
	// For now, use a simple copy
	backupPath := cfg.AuthStoragePath + ".backup"
	data, err := os.ReadFile(cfg.AuthStoragePath)
	if err != nil {
		return fmt.Errorf("failed to read auth file: %w", err)
	}
	
	if err := os.WriteFile(backupPath, data, 0600); err != nil {
		return fmt.Errorf("failed to write backup: %w", err)
	}
	
	fmt.Printf("Backup created: %s\n", backupPath)
	return nil
}

// AuthStorageResetCmd resets keychain items with proper trust settings
type AuthStorageResetCmd struct {
	Force bool `help:"Skip confirmation prompt" short:"f"`
}

func (cmd *AuthStorageResetCmd) Run(ctx *kong.Context) error {
	cfg := config.DefaultConfig()
	cfg.LoadFromEnv()
	
	// Only applicable for keyring storage
	if cfg.AuthStorageType == "file" {
		fmt.Println("Reset is only applicable for keyring storage")
		fmt.Println("Current storage type is 'file'")
		return nil
	}
	
	// Confirm with user unless forced
	if !cmd.Force {
		fmt.Println("WARNING: This will clear all stored tokens and require re-authentication.")
		fmt.Print("Continue? (y/N): ")
		var response string
		fmt.Scanln(&response)
		if response != "y" && response != "Y" {
			fmt.Println("Cancelled")
			return nil
		}
	}
	
	// Create storage
	factory := auth.NewStorageFactory(createStorageFactoryConfig(cfg))
	storage, err := factory.Create()
	if err != nil {
		return fmt.Errorf("failed to create storage: %w", err)
	}
	
	// List all providers
	providers, err := storage.List()
	if err != nil {
		return fmt.Errorf("failed to list providers: %w", err)
	}
	
	if len(providers) == 0 {
		fmt.Println("No tokens found to reset")
		return nil
	}
	
	// Store tokens temporarily
	tokens := make(map[string]*auth.TokenInfo)
	for _, provider := range providers {
		token, err := storage.Get(provider)
		if err != nil {
			fmt.Printf("Warning: Failed to get token for %s: %v\n", provider, err)
			continue
		}
		if token != nil {
			tokens[provider] = token
		}
	}
	
	// Remove all tokens
	fmt.Println("Removing existing tokens...")
	for _, provider := range providers {
		if err := storage.Remove(provider); err != nil {
			fmt.Printf("Warning: Failed to remove token for %s: %v\n", provider, err)
		}
	}
	
	// Re-add tokens with proper trust settings
	fmt.Println("Re-adding tokens with trust settings...")
	successCount := 0
	for provider, token := range tokens {
		if err := storage.Set(provider, token); err != nil {
			fmt.Printf("Error: Failed to restore token for %s: %v\n", provider, err)
		} else {
			successCount++
			fmt.Printf("✓ Restored token for %s with trust settings\n", provider)
		}
	}
	
	fmt.Printf("\nReset complete: %d/%d tokens restored\n", successCount, len(tokens))
	
	if successCount < len(tokens) {
		fmt.Println("\nSome tokens failed to restore. You may need to re-authenticate.")
	} else {
		fmt.Println("\nAll tokens restored successfully with proper trust settings.")
		fmt.Println("You should no longer see repeated password prompts.")
	}
	
	return nil
}
// End of cmd/claude-gate/auth_storage.go

=====================

// File: cmd/claude-gate/main.go

package main

import (
	"encoding/json"
	"fmt"
	"net/http"
	"os"
	"os/signal"
	"strings"
	"syscall"
	"time"

	"github.com/alecthomas/kong"
	tea "github.com/charmbracelet/bubbletea"
	"github.com/ml0-1337/claude-gate/internal/auth"
	"github.com/ml0-1337/claude-gate/internal/config"
	"github.com/ml0-1337/claude-gate/internal/logger"
	"github.com/ml0-1337/claude-gate/internal/proxy"
	"github.com/ml0-1337/claude-gate/internal/ui"
	"github.com/ml0-1337/claude-gate/internal/ui/components"
)

var version = "0.1.0"

// createStorageFactoryConfig creates a StorageFactoryConfig from the main Config
func createStorageFactoryConfig(cfg *config.Config) auth.StorageFactoryConfig {
	return auth.StorageFactoryConfig{
		Type:                           auth.StorageType(cfg.AuthStorageType),
		FilePath:                       cfg.AuthStoragePath,
		ServiceName:                    cfg.KeyringService,
		KeychainTrustApp:               cfg.KeychainTrustApp,
		KeychainAccessibleWhenUnlocked: cfg.KeychainAccessibleWhenUnlocked,
		KeychainSynchronizable:         cfg.KeychainSynchronizable,
	}
}

type CLI struct {
	Start     StartCmd     `cmd:"" help:"Start the Claude OAuth proxy server"`
	Dashboard DashboardCmd `cmd:"" help:"Start server with interactive dashboard"`
	Auth      AuthCmd      `cmd:"" help:"Authentication management commands"`
	Test      TestCmd      `cmd:"" help:"Test the proxy connection"`
	Version   VersionCmd   `cmd:"" help:"Show version information"`
}

type StartCmd struct {
	Host      string `help:"Host to bind the proxy server" default:"127.0.0.1"`
	Port      int    `help:"Port to bind the proxy server" default:"5789"`
	AuthToken string `help:"Enable proxy authentication with this token" env:"CLAUDE_GATE_PROXY_AUTH_TOKEN"`
	LogLevel  string `help:"Logging level (DEBUG, INFO, WARNING, ERROR)" default:"INFO"`
	SkipAuthCheck bool `help:"Skip OAuth authentication check"`
}

type DashboardCmd struct {
	Host      string `help:"Host to bind the proxy server" default:"127.0.0.1"`
	Port      int    `help:"Port to bind the proxy server" default:"5789"`
	AuthToken string `help:"Enable proxy authentication with this token" env:"CLAUDE_GATE_PROXY_AUTH_TOKEN"`
	LogLevel  string `help:"Logging level (DEBUG, INFO, WARNING, ERROR)" default:"INFO"`
	SkipAuthCheck bool `help:"Skip OAuth authentication check"`
}

type AuthCmd struct {
	Login   LoginCmd         `cmd:"" help:"Authenticate with Claude Pro/Max using OAuth"`
	Logout  LogoutCmd        `cmd:"" help:"Clear stored authentication credentials"`
	Status  StatusCmd        `cmd:"" help:"Check authentication status"`
	Storage AuthStorageCmd   `cmd:"" help:"Manage token storage backends"`
}

type LoginCmd struct{}
type LogoutCmd struct{}
type StatusCmd struct{}

type TestCmd struct {
	BaseURL string `help:"Proxy server URL" default:"http://localhost:5789"`
}

type VersionCmd struct{}

func (s *StartCmd) Run() error {
	cfg := config.DefaultConfig()
	cfg.Host = s.Host
	cfg.Port = s.Port
	cfg.ProxyAuthToken = s.AuthToken
	cfg.LogLevel = s.LogLevel
	cfg.LoadFromEnv()
	
	out := ui.NewOutput()
	
	// Check authentication unless skipped
	if !s.SkipAuthCheck {
		// Create storage using factory
		factory := auth.NewStorageFactory(createStorageFactoryConfig(cfg))
		
		storage, err := factory.Create()
		if err != nil {
			return fmt.Errorf("failed to create storage: %w", err)
		}
		
		token, err := storage.Get("anthropic")
		if err != nil || token == nil || token.Type != "oauth" {
			out.Error("No OAuth authentication found!")
			out.Info("Please run 'claude-gate auth login' first to set up OAuth.")
			return fmt.Errorf("authentication required")
		}
		out.Success("OAuth authentication configured and ready")
	}
	
	// Print startup banner
	out.Title("🚀 Claude OAuth Proxy")
	
	headers := []string{"Configuration", "Value"}
	rows := [][]string{
		{"Server URL", fmt.Sprintf("http://%s", cfg.GetBindAddress())},
		{"Anthropic API", cfg.AnthropicBaseURL},
		{"Proxy Auth", func() string {
			if cfg.ProxyAuthToken != "" {
				return "Enabled"
			}
			return "Disabled"
		}()},
		{"OpenAI Compatible", fmt.Sprintf("http://%s/v1", cfg.GetBindAddress())},
	}
	out.Table(headers, rows)
	
	if cfg.ProxyAuthToken == "" {
		out.Warning("Proxy authentication disabled - anyone can use this proxy")
	}
	
	out.Info("\nPress CTRL+C to stop the server")
	
	// Create proxy server with storage
	factory := auth.NewStorageFactory(createStorageFactoryConfig(cfg))
	
	storage, err := factory.CreateWithMigration()
	if err != nil {
		return fmt.Errorf("failed to create storage: %w", err)
	}
	
	tokenProvider := auth.NewOAuthTokenProvider(storage)
	transformer := proxy.NewRequestTransformer()
	
	// Create logger
	log := logger.New(logger.ParseLevel(cfg.LogLevel))
	
	proxyConfig := &proxy.ProxyConfig{
		UpstreamURL:   cfg.AnthropicBaseURL,
		TokenProvider: tokenProvider,
		Transformer:   transformer,
		Timeout:       cfg.RequestTimeout,
		Logger:        log,
	}
	
	server := proxy.NewProxyServer(proxyConfig, cfg.GetBindAddress(), storage)
	
	// Handle graceful shutdown
	sigChan := make(chan os.Signal, 1)
	signal.Notify(sigChan, os.Interrupt, syscall.SIGTERM)
	
	go func() {
		<-sigChan
		out.Info("\n\nShutting down proxy server...")
		if err := server.Stop(30 * time.Second); err != nil {
			out.Error("Error during shutdown: %v", err)
		}
	}()
	
	// Start server
	if err := server.Start(); err != nil && err != http.ErrServerClosed {
		return fmt.Errorf("server error: %w", err)
	}
	
	out.Success("Proxy server stopped")
	return nil
}

func (d *DashboardCmd) Run() error {
	cfg := config.DefaultConfig()
	cfg.Host = d.Host
	cfg.Port = d.Port
	cfg.ProxyAuthToken = d.AuthToken
	cfg.LogLevel = d.LogLevel
	cfg.LoadFromEnv()
	
	out := ui.NewOutput()
	
	// Check authentication unless skipped
	if !d.SkipAuthCheck {
		// Create storage using factory
		factory := auth.NewStorageFactory(createStorageFactoryConfig(cfg))
		
		storage, err := factory.Create()
		if err != nil {
			return fmt.Errorf("failed to create storage: %w", err)
		}
		
		token, err := storage.Get("anthropic")
		if err != nil || token == nil || token.Type != "oauth" {
			out.Error("No OAuth authentication found!")
			out.Info("Please run 'claude-gate auth login' first to set up OAuth.")
			return fmt.Errorf("authentication required")
		}
	}
	
	// Create proxy server with storage
	factory := auth.NewStorageFactory(createStorageFactoryConfig(cfg))
	
	storage, err := factory.CreateWithMigration()
	if err != nil {
		return fmt.Errorf("failed to create storage: %w", err)
	}
	
	tokenProvider := auth.NewOAuthTokenProvider(storage)
	transformer := proxy.NewRequestTransformer()
	
	// Create logger
	log := logger.New(logger.ParseLevel(cfg.LogLevel))
	
	proxyConfig := &proxy.ProxyConfig{
		UpstreamURL:   cfg.AnthropicBaseURL,
		TokenProvider: tokenProvider,
		Transformer:   transformer,
		Timeout:       cfg.RequestTimeout,
		Logger:        log,
	}
	
	server := proxy.NewEnhancedProxyServer(proxyConfig, cfg.GetBindAddress(), storage)
	
	// Get dashboard model
	dashboardModel := server.GetDashboard()
	
	// Start server in background
	serverErrChan := make(chan error, 1)
	go func() {
		if err := server.Start(); err != nil && err != http.ErrServerClosed {
			serverErrChan <- err
		}
	}()
	
	// Give server a moment to start
	time.Sleep(100 * time.Millisecond)
	
	// Check if server started successfully
	select {
	case err := <-serverErrChan:
		return fmt.Errorf("failed to start server: %w", err)
	default:
		// Server started successfully
	}
	
	// Run the dashboard UI
	p := tea.NewProgram(dashboardModel, tea.WithAltScreen())
	
	// Handle shutdown
	go func() {
		sigChan := make(chan os.Signal, 1)
		signal.Notify(sigChan, os.Interrupt, syscall.SIGTERM)
		<-sigChan
		p.Quit()
	}()
	
	// Run the dashboard
	if _, err := p.Run(); err != nil {
		out.Error("Dashboard error: %v", err)
	}
	
	// Shutdown server
	out.Info("\nShutting down proxy server...")
	if err := server.Stop(30 * time.Second); err != nil {
		out.Error("Error during shutdown: %v", err)
	}
	
	out.Success("Dashboard stopped")
	return nil
}

func (l *LoginCmd) Run() error {
	cfg := config.DefaultConfig()
	cfg.LoadFromEnv()
	
	// Create storage using factory
	factory := auth.NewStorageFactory(createStorageFactoryConfig(cfg))
	
	storage, err := factory.Create()
	if err != nil {
		return fmt.Errorf("failed to create storage: %w", err)
	}
	
	client := auth.NewOAuthClient()
	out := ui.NewOutput()
	
	// Check if already authenticated
	existing, _ := storage.Get("anthropic")
	if existing != nil && existing.Type == "oauth" {
		out.Warning("Already authenticated!")
		if !components.Confirm("Do you want to re-authenticate?") {
			return nil
		}
		err := components.RunSpinner("Removing existing authentication...", func() error {
			return storage.Remove("anthropic")
		})
		if err != nil {
			return err
		}
	}
	
	// Get authorization URL
	var authData *auth.AuthData
	var authErr error
	
	// Generate URL in background
	go func() {
		authData, authErr = client.GetAuthorizationURL()
	}()
	
	// Show spinner while generating
	err = components.RunSpinner("Generating authorization URL...", func() error {
		// Wait for URL generation
		for authData == nil && authErr == nil {
			time.Sleep(100 * time.Millisecond)
		}
		return authErr
	})
	if err != nil {
		return fmt.Errorf("failed to generate authorization URL: %w", err)
	}
	
	// Run interactive OAuth flow
	code, err := ui.RunOAuthFlow(authData.URL)
	if err != nil {
		return fmt.Errorf("authentication canceled: %w", err)
	}
	code = strings.TrimSpace(code)
	
	// Exchange code for tokens
	var token *auth.TokenInfo
	err = components.RunSpinner("Exchanging code for tokens...", func() error {
		var err error
		token, err = client.ExchangeCode(code, authData.Verifier)
		if err != nil {
			return err
		}
		// Save tokens
		return storage.Set("anthropic", token)
	})
	if err != nil {
		return fmt.Errorf("authentication failed: %w", err)
	}
	
	out.Success("\nAuthentication successful!")
	out.Success("Your Claude Pro/Max account is now connected.")
	out.Info("Tokens are securely stored for future use.")
	
	return nil
}

func (l *LogoutCmd) Run() error {
	cfg := config.DefaultConfig()
	cfg.LoadFromEnv()
	
	// Create storage using factory
	factory := auth.NewStorageFactory(createStorageFactoryConfig(cfg))
	
	storage, err := factory.Create()
	if err != nil {
		return fmt.Errorf("failed to create storage: %w", err)
	}
	
	out := ui.NewOutput()
	
	if !components.Confirm("Are you sure you want to logout?") {
		return nil
	}
	
	err = components.RunSpinner("Removing authentication...", func() error {
		return storage.Remove("anthropic")
	})
	if err != nil {
		return fmt.Errorf("failed to remove authentication: %w", err)
	}
	
	out.Success("Logged out successfully")
	return nil
}

func (s *StatusCmd) Run() error {
	cfg := config.DefaultConfig()
	cfg.LoadFromEnv()
	
	// Create storage using factory
	factory := auth.NewStorageFactory(createStorageFactoryConfig(cfg))
	
	storage, err := factory.Create()
	if err != nil {
		return fmt.Errorf("failed to create storage: %w", err)
	}
	
	out := ui.NewOutput()
	
	out.Title("Claude Gate Status")
	
	// Check authentication
	token, err := storage.Get("anthropic")
	if err != nil || token == nil {
		out.Error("Authentication: Not configured")
		out.Info("Run 'claude-gate auth login' to authenticate")
		return nil
	}
	
	if token.Type == "oauth" {
		out.Success("OAuth Authentication: Configured")
		expires := time.Unix(token.ExpiresAt, 0)
		if token.IsExpired() {
			out.Warning("Token is expired and will be refreshed on next use")
		} else if token.NeedsRefresh() {
			out.Warning("Token expires soon and will be refreshed on next use")
		} else {
			out.Info("Token expires: %s", expires.Format("2006-01-02 15:04:05"))
		}
	} else {
		out.Warning("API Key Authentication: Configured")
		out.Info("Consider using OAuth for free usage")
	}
	
	// Show proxy configuration
	out.Subtitle("\nProxy Configuration")
	headers := []string{"Setting", "Value"}
	rows := [][]string{
		{"Default host", cfg.Host},
		{"Default port", fmt.Sprintf("%d", cfg.Port)},
		{"Auth required", func() string {
			if cfg.ProxyAuthToken != "" {
				return "Yes"
			}
			return "No"
		}()},
		{"Log level", cfg.LogLevel},
	}
	out.Table(headers, rows)
	
	return nil
}

func (t *TestCmd) Run() error {
	out := ui.NewOutput()
	out.Title("Testing Claude Gate Proxy")
	out.Info("Testing proxy at %s...", t.BaseURL)
	
	var resp *http.Response
	err := components.RunSpinner("Connecting to proxy...", func() error {
		var err error
		resp, err = http.Get(t.BaseURL + "/health")
		return err
	})
	if err != nil {
		out.Error("Could not connect to proxy at %s", t.BaseURL)
		out.Info("Is the proxy server running?")
		return err
	}
	defer resp.Body.Close()
	
	if resp.StatusCode == 200 {
		out.Success("Proxy server is running")
		
		// Parse response
		var health map[string]interface{}
		if err := json.NewDecoder(resp.Body).Decode(&health); err == nil {
			headers := []string{"Status", "Value"}
			rows := [][]string{}
			
			if status, ok := health["oauth_status"].(string); ok {
				rows = append(rows, []string{"OAuth status", status})
			}
			if proxyAuth, ok := health["proxy_auth"].(string); ok {
				rows = append(rows, []string{"Proxy auth", proxyAuth})
			}
			
			if len(rows) > 0 {
				out.Table(headers, rows)
			}
		}
	} else {
		out.Error("Unexpected status code: %d", resp.StatusCode)
	}
	
	return nil
}

func (v *VersionCmd) Run() error {
	out := ui.NewOutput()
	out.Title("Claude Gate")
	out.Info("Version: %s", version)
	out.Info("Go OAuth proxy for Anthropic API")
	out.Info("https://github.com/ml0-1337/claude-gate")
	return nil
}

func main() {
	var cli CLI
	ctx := kong.Parse(&cli,
		kong.Name("claude-gate"),
		kong.Description("Claude OAuth proxy server - FREE Claude usage for Pro/Max subscribers"),
		kong.UsageOnError(),
	)
	
	if err := ctx.Run(); err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}
}
// End of cmd/claude-gate/main.go

=====================

// File: docs/architecture/decisions/001-project-structure.md

# ADR-001: Project Structure

## Status
Accepted

## Context
The Claude Gate project needs a clear, maintainable structure that balances Go community conventions with practical needs. The golang-standards/project-layout is popular but controversial, and we need to decide what structure best serves our project.

## Decision
We will use a simplified structure based on Go conventions:
- `/cmd/claude-gate/` for the CLI entry point
- `/internal/` for private packages (auth, proxy, config)
- No `/pkg/` directory unless we develop public APIs
- `/docs/` for documentation
- `/scripts/` for build automation
- `/.claude/` for project management

We will NOT use:
- `/pkg/` - No public API currently planned
- `/api/` - No API definitions needed
- `/web/` - No web assets
- Deep nesting - Keep structure flat

## Consequences

### Positive
- Simple and easy to navigate
- Follows Go compiler conventions (internal)
- Clear separation of concerns
- Easy for new contributors to understand
- Avoids over-engineering

### Negative
- May need restructuring if public API added
- Less "standard" than full project-layout
- Some Go developers expect /pkg/

## Alternatives Considered

1. **Full golang-standards/project-layout**
   - Pro: Familiar to many Go developers
   - Con: Overkill for our current needs
   - Con: Includes many unnecessary directories

2. **Flat structure (everything in root)**
   - Pro: Maximum simplicity
   - Con: No privacy enforcement
   - Con: Harder to organize as project grows

3. **Domain-driven structure**
   - Pro: Business logic focused
   - Con: Less conventional in Go
   - Con: Overhead for small project

## References
- [golang-standards/project-layout](https://github.com/golang-standards/project-layout)
- [Go Project Structure Best Practices](https://tutorialedge.net/golang/go-project-structure-best-practices/)
- [Organizing a Go module](https://go.dev/doc/modules/layout)
// End of docs/architecture/decisions/001-project-structure.md

=====================

// File: docs/architecture/overview.md

# Claude Gate Architecture

## Overview

Claude Gate is a high-performance OAuth proxy for Anthropic's Claude API that enables free Claude usage for Pro/Max subscribers by identifying as "Claude Code" (Anthropic's official CLI). This document describes the system architecture, design decisions, and component interactions.

## System Architecture

```
┌─────────────────┐     ┌──────────────────┐     ┌─────────────────┐
│                 │     │                  │     │                 │
│  User's Editor  │────▶│   Claude Gate   │────▶│  Anthropic API  │
│   (Zed, etc)    │     │   OAuth Proxy    │     │                 │
│                 │     │                  │     │                 │
└─────────────────┘     └──────────────────┘     └─────────────────┘
         │                       │                         │
         │                       │                         │
         ▼                       ▼                         ▼
    API Requests          System Prompt              OAuth 2.0
                          Injection +                Authentication
                          Token Addition

```

## Core Components

### 1. CLI Layer (`cmd/claude-gate/`)

The command-line interface provides user interaction and server management:

- **Framework**: Kong CLI framework for command parsing
- **Commands**:
  - `start` - Launches the proxy server
  - `auth login` - Initiates OAuth flow
  - `auth logout` - Revokes tokens
  - `auth status` - Shows authentication status
  - `test` - Validates proxy functionality
  - `version` - Displays version information

### 2. Authentication Layer (`internal/auth/`)

Handles OAuth 2.0 PKCE flow with Anthropic:

- **OAuth Client** (`client.go`) - HTTP client for OAuth operations
- **OAuth Flow** (`oauth.go`) - PKCE implementation with automatic token refresh
- **Token Storage** (`storage.go`) - Secure token persistence (file-based, keychain planned)

Key features:
- Public client with PKCE for security
- Automatic token refresh before expiration
- Graceful degradation for storage backends

### 3. Proxy Layer (`internal/proxy/`)

Core proxy functionality for API translation:

- **Server** (`server.go`) - HTTP server management and lifecycle
- **Handler** (`handler.go`) - Request routing and response handling
- **Transformer** (`transformer.go`) - Request/response transformation

Key transformations:
1. System prompt injection (prepends "Claude Code" identifier)
2. OAuth header injection (adds authentication)
3. Model alias mapping (e.g., "latest" → specific versions)
4. SSE stream handling with proper flushing

### 4. Configuration (`internal/config/`)

Centralized configuration management:
- Default port: 5789
- Configurable via environment variables
- Runtime configuration validation

## Data Flow

### 1. Authentication Flow

```
User ──login──▶ OAuth Provider ──code──▶ Claude Gate ──exchange──▶ Access Token
                                                           │
                                                           ▼
                                                     Token Storage
```

### 2. Request Flow

```
1. Client Request → Claude Gate
2. Validate authentication
3. Transform request:
   - Inject "Claude Code" system prompt
   - Map model aliases
   - Add OAuth headers
4. Forward to Anthropic API
5. Stream response back to client
```

### 3. System Prompt Transformation

The proxy ensures all requests identify as "Claude Code":

- String prompts: Converted to array with Claude Code first
- Array prompts: Claude Code prepended if not present
- Empty prompts: Left unchanged

## Security Architecture

### Authentication Security

- **OAuth 2.0 PKCE**: Proof Key for Code Exchange prevents authorization code interception
- **Public Client**: Client ID is public by design (security via PKCE, not secrecy)
- **Token Rotation**: Automatic refresh before expiration
- **Secure Storage**: Tokens stored in OS keychain (planned) or encrypted file

### Network Security

- **TLS Only**: All communication with Anthropic over HTTPS
- **Header Stripping**: Removes identifying headers from client
- **No Logging**: Sensitive data never logged
- **Rate Limiting**: Planned to prevent abuse

### Defense in Depth

1. Authentication layer validates all requests
2. Proxy never exposes raw tokens to clients
3. Automatic token refresh prevents expiration attacks
4. File-based storage fallback with encryption (planned)

## Deployment Architecture

### Binary Distribution

```
GitHub Release ──▶ Platform Binaries ──▶ Direct Download
       │                                        │
       └──▶ NPM Packages ──▶ Auto-install ──────┘
```

### NPM Package Structure

```
claude-gate (main package)
    ├── @claude-gate/darwin-x64
    ├── @claude-gate/darwin-arm64
    ├── @claude-gate/linux-x64
    ├── @claude-gate/linux-arm64
    └── @claude-gate/win32-x64
```

### Runtime Requirements

- **Go Binary**: Single static binary, no runtime dependencies
- **Port**: 9988 (configurable)
- **Storage**: ~/.claude-gate/ for tokens and config
- **Permissions**: User-level only, no elevated privileges

## Performance Characteristics

### Optimizations

1. **Zero-copy streaming**: Direct pipe between client and API
2. **Minimal allocations**: Reuses buffers where possible
3. **No caching**: Stateless proxy for simplicity
4. **Connection pooling**: Reuses HTTP connections

### Bottlenecks

1. **Token refresh**: Synchronous operation (minimal impact)
2. **System prompt parsing**: JSON unmarshal/marshal overhead
3. **SSE buffering**: Requires immediate flushing

## Monitoring and Observability

### Current State

- Basic console logging
- Error responses in Anthropic format
- No metrics collection

### Planned Enhancements

1. Structured logging with levels
2. Prometheus metrics endpoint
3. Request ID tracking
4. Performance profiling endpoints

## Future Architecture Considerations

### Planned Features

1. **OS Keychain Integration**: Secure token storage
2. **Rate Limiting**: Token bucket algorithm
3. **Circuit Breaker**: Fault tolerance for API outages
4. **WebSocket Support**: Future API compatibility

### Scalability Path

Currently designed for single-user desktop use. For multi-user:

1. External token storage (Redis/PostgreSQL)
2. Horizontal scaling with load balancer
3. Distributed rate limiting
4. Centralized logging

## Architecture Decisions Records (ADRs)

See `/docs/decisions/` for detailed rationale on:

1. Why PKCE over client credentials
2. Why file-based storage with keychain upgrade path
3. Why system prompt injection over API translation
4. Why Go over Python (performance, distribution)
5. Why NPM distribution alongside binaries

---

[← Architecture](../README.md#architecture) | [Documentation Home](../README.md) | [Security →](./security.md)
// End of docs/architecture/overview.md

=====================

// File: docs/architecture/security.md

# Security Policy

## Overview

Claude Gate handles sensitive authentication tokens and proxies API requests. This document outlines our security model, best practices, and vulnerability reporting process.

## Security Model

### OAuth 2.0 Public Client with PKCE

Claude Gate uses OAuth 2.0 with Proof Key for Code Exchange (PKCE) for authentication:

- **Public Client**: The OAuth client ID is intentionally public
- **PKCE Protection**: Security comes from the PKCE challenge/verifier, not client secrecy
- **Industry Standard**: Same approach used by GitHub CLI, Google Cloud SDK, and other major tools

### Token Security

#### Current Implementation
- **OS Keychain Integration** (Implemented)
  - macOS: Keychain Services
  - Linux: Secret Service API (GNOME Keyring, KWallet)
  - Windows: Credential Manager
- **Automatic Fallback**: File storage when keychain unavailable
- **Zero-Configuration**: Auto-detects best storage backend
- **Seamless Migration**: Automatic migration from JSON to keychain
- File permissions set to 0600 (user read/write only)
- Automatic token refresh before expiration
- Tokens never transmitted to clients

#### Storage Backend Selection
1. **Auto Mode** (Default)
   - Automatically selects the most secure available backend
   - Prefers OS keychain/keystore over file storage
   - Transparent fallback on errors
   
2. **Keyring Mode**
   - Forces use of OS-native secure storage
   - Fails if keychain not available
   
3. **File Mode**
   - Traditional JSON file storage
   - Encrypted file storage using JOSE (PBES2_HS256_A128KW + A256GCM)
   - For environments without keychain access

#### Storage Management
- `claude-gate auth storage status`: Check current backend
- `claude-gate auth storage migrate`: Migrate between backends
- `claude-gate auth storage test`: Verify storage operations
- `claude-gate auth storage backup`: Create manual backup

### Network Security

- **TLS Only**: All API communication uses HTTPS
- **Certificate Validation**: Full certificate chain validation
- **No Proxy Bypass**: Security settings cannot be disabled
- **Header Sanitization**: Removes identifying client headers

### Request Security

1. **Authentication Validation**
   - Every request checks token validity
   - Expired tokens trigger automatic refresh
   - Invalid tokens return 401 Unauthorized

2. **System Prompt Injection**
   - Prepends identifier to maintain API compliance
   - No user data logged or stored
   - Transformation is transparent and auditable

3. **Rate Limiting** (Planned)
   - Per-IP rate limiting to prevent abuse
   - Token bucket algorithm with configurable limits
   - Graceful degradation under load

## Security Best Practices

### For Users

1. **Protect Your Token**
   - Never share your `auth.json` file
   - Revoke tokens if system compromised
   - Use `claude-gate auth logout` when done

2. **System Security**
   - Keep your OS and Claude Gate updated
   - Use full-disk encryption
   - Don't run Claude Gate as root/admin

3. **Network Security**
   - Use Claude Gate only on trusted networks
   - Consider VPN for public WiFi
   - Monitor for unusual activity

### For Developers

1. **Code Security**
   - Never log tokens or sensitive data
   - Validate all inputs
   - Use constant-time comparisons for secrets
   - Keep dependencies updated

2. **Build Security**
   - Build with latest Go version
   - Enable all compiler security features
   - Sign releases with GPG
   - Generate reproducible builds

## Threat Model

### In Scope

1. **Token Theft**
   - Mitigation: Keychain storage, file encryption
   - Detection: Token revocation on suspicious activity

2. **Man-in-the-Middle**
   - Mitigation: TLS with certificate pinning
   - Detection: Certificate validation failures

3. **Replay Attacks**
   - Mitigation: OAuth nonce, request signing
   - Detection: Duplicate request detection

4. **Resource Exhaustion**
   - Mitigation: Rate limiting, connection limits
   - Detection: Metrics and monitoring

### Out of Scope

1. **Physical Access**: If attacker has system access, game over
2. **OS Vulnerabilities**: We assume a secure OS
3. **Social Engineering**: User education responsibility
4. **Anthropic API Security**: We trust Anthropic's security

## Vulnerability Reporting

### Reporting Process

1. **Do NOT** create public GitHub issues for security vulnerabilities
2. Email security concerns to: security@claude-gate.dev
3. Include:
   - Description of vulnerability
   - Steps to reproduce
   - Potential impact
   - Suggested fix (if any)

### Response Timeline

- **24 hours**: Initial acknowledgment
- **72 hours**: Preliminary assessment
- **7 days**: Fix development begins
- **30 days**: Fix released (critical issues faster)

### Disclosure Policy

- 90-day disclosure deadline
- Coordinated disclosure preferred
- Credit given to reporters (if desired)
- Security advisories posted to GitHub

## Security Checklist

### For Each Release

- [ ] Update all dependencies
- [ ] Run security scanner (gosec)
- [ ] Test token rotation
- [ ] Verify TLS settings
- [ ] Check file permissions
- [ ] Audit logging statements

### Monthly Reviews

- [ ] Review threat model
- [ ] Check for new CVEs
- [ ] Update security documentation
- [ ] Test incident response plan
- [ ] Review access logs

## Incident Response

### If You Suspect Compromise

1. **Immediately**: Run `claude-gate auth logout`
2. **Then**: Revoke tokens in Anthropic dashboard
3. **Check**: System for other compromises
4. **Report**: To maintainers if Claude Gate issue
5. **Monitor**: For unauthorized API usage

### For Maintainers

1. **Assess**: Severity and scope
2. **Contain**: Patch or disable affected features
3. **Communicate**: Notify affected users
4. **Fix**: Develop and test patch
5. **Release**: Emergency update
6. **Post-mortem**: Document and learn

## Security Features Roadmap

### Q1 2025
- [x] OAuth 2.0 PKCE implementation
- [x] OS keychain integration (Completed)
- [x] Encrypted file storage (via 99designs/keyring FileBackend)
- [ ] Basic rate limiting

### Q2 2025
- [ ] Certificate pinning
- [ ] Advanced rate limiting
- [ ] Security audit
- [ ] Penetration testing

### Q3 2025
- [ ] Hardware token support
- [ ] Multi-factor authentication
- [ ] Audit logging
- [ ] SIEM integration

## Compliance

Claude Gate is designed with security best practices but makes no compliance claims:

- Not evaluated for HIPAA, PCI, or other standards
- Users responsible for their own compliance
- We'll help with security questionnaires
- Open source for full auditability

## Resources

- [OWASP API Security](https://owasp.org/www-project-api-security/)
- [OAuth 2.0 Security Best Practices](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-security-topics)
- [Go Security Guidelines](https://golang.org/doc/security)
- [NIST Cybersecurity Framework](https://www.nist.gov/cyberframework)

---

[← Architecture](../README.md#architecture) | [Documentation Home](../README.md) | [Overview →](./overview.md)
// End of docs/architecture/security.md

=====================

// File: docs/deployment/npm-package.md

# NPM Package Guide

This guide covers the Claude Gate NPM package distribution, including installation, usage, and publishing.

## For Users

### Installation

Install Claude Gate globally via NPM:

```bash
npm install -g claude-gate
```

Or using Yarn:

```bash
yarn global add claude-gate
```

Or using pnpm:

```bash
pnpm add -g claude-gate
```

### What Gets Installed

The NPM package:
1. Downloads the appropriate binary for your platform
2. Installs it in your global NPM bin directory
3. Makes the `claude-gate` command available system-wide

### Supported Platforms

The NPM package supports the following platforms:

| Platform | Architecture | Package Name |
|----------|--------------|--------------|
| macOS | Intel (x64) | `@claude-gate/darwin-x64` |
| macOS | Apple Silicon (arm64) | `@claude-gate/darwin-arm64` |
| Linux | x64 | `@claude-gate/linux-x64` |
| Linux | arm64 | `@claude-gate/linux-arm64` |
| Windows | x64 | `@claude-gate/win32-x64` |

### Verifying Installation

After installation, verify it works:

```bash
claude-gate version
```

### Updating

Update to the latest version:

```bash
npm update -g claude-gate
```

### Uninstalling

Remove Claude Gate:

```bash
npm uninstall -g claude-gate
```

## For Maintainers

### Package Structure

The NPM package uses a multi-package architecture:

```
npm/
├── package.json           # Main package
├── index.js              # Installation script
├── scripts/
│   ├── install.js        # Post-install script
│   └── uninstall.js      # Pre-uninstall script
└── platforms/
    ├── darwin-arm64/
    │   └── package.json  # Platform-specific package
    ├── darwin-x64/
    ├── linux-arm64/
    ├── linux-x64/
    └── win32-x64/
```

### How It Works

1. **Main Package** (`claude-gate`):
   - Contains installation logic
   - Has optional dependencies on platform packages
   - Runs post-install script to set up binary

2. **Platform Packages** (`@claude-gate/platform-arch`):
   - Contains the actual binary for that platform
   - Only the matching platform package is installed

3. **Installation Process**:
   - NPM installs main package
   - NPM installs matching platform package
   - Post-install script extracts and sets up binary

### Building NPM Packages

#### Prerequisites

- Built binaries for all platforms
- Node.js and NPM installed
- NPM authentication token

#### Build Process

1. **Build all binaries**:
   ```bash
   make build-all
   ```

2. **Prepare NPM packages**:
   ```bash
   make build-npm
   ```

3. **Test locally**:
   ```bash
   cd npm
   npm link
   claude-gate version
   ```

### Publishing

#### First-Time Setup

1. **Create NPM organization** (if needed):
   - Go to npmjs.com
   - Create organization: `@claude-gate`

2. **Authenticate with NPM**:
   ```bash
   npm login
   ```

3. **Set up automated publishing** (optional):
   ```bash
   ./scripts/setup-npm-auth.sh
   ```

#### Publishing Process

1. **Update version** in all package.json files:
   ```bash
   ./scripts/update-version.sh 1.2.3
   ```

2. **Build and test packages**:
   ```bash
   make build-npm
   ./scripts/test-npm-local.sh
   ```

3. **Publish packages**:
   ```bash
   # Publish platform packages first
   for platform in npm/platforms/*/; do
     cd "$platform"
     npm publish --access public
     cd -
   done

   # Publish main package
   cd npm
   npm publish --access public
   ```

#### Automated Publishing

The GitHub Actions workflow handles publishing on new releases:

```yaml
# .github/workflows/release.yml
- name: Publish to NPM
  run: |
    echo "//registry.npmjs.org/:_authToken=${{ secrets.NPM_TOKEN }}" > ~/.npmrc
    make publish-npm
```

### Version Management

#### Versioning Strategy

- Main package and platform packages share the same version
- Version follows semantic versioning (semver)
- All packages are published together

#### Updating Versions

Use the update script:

```bash
./scripts/update-version.sh 1.2.3
```

Or manually update:
1. `npm/package.json`
2. `npm/platforms/*/package.json`
3. Binary version in Go code

### Testing NPM Package

#### Local Testing

```bash
# Build packages
make build-npm

# Test installation
cd npm
npm link

# Verify
claude-gate version

# Test uninstall
npm unlink
```

#### Cross-Platform Testing

```bash
# Run comprehensive tests
./scripts/test-npm-local.sh

# Test in Docker containers
./scripts/test-docker.sh
```

#### Integration Tests

Test with different package managers:

```bash
# NPM
npm install -g ./npm

# Yarn
yarn global add file:./npm

# pnpm
pnpm add -g ./npm
```

### Troubleshooting Publishing

#### Authentication Issues

```bash
# Check authentication
npm whoami

# Re-authenticate
npm logout
npm login
```

#### Permission Issues

```bash
# Check package access
npm access ls-packages

# Grant publish access
npm owner add USERNAME @claude-gate/PACKAGE
```

#### Failed Publish

1. Check version conflicts:
   ```bash
   npm view claude-gate versions
   ```

2. Try force publish (careful!):
   ```bash
   npm publish --force
   ```

3. Unpublish broken version (within 72 hours):
   ```bash
   npm unpublish claude-gate@1.2.3
   ```

### NPM Package Best Practices

1. **Security**:
   - Never include sensitive data in packages
   - Use `.npmignore` to exclude unnecessary files
   - Regular security audits: `npm audit`

2. **Size Optimization**:
   - Only include necessary files
   - Compress binaries when possible
   - Check package size: `npm pack --dry-run`

3. **Compatibility**:
   - Test on all supported Node.js versions
   - Handle missing optional dependencies gracefully
   - Provide clear error messages

4. **Documentation**:
   - Keep README.md updated
   - Include platform requirements
   - Document common issues

### Monitoring NPM Package

#### Download Statistics

View package statistics:

```bash
# Command line
npm view claude-gate

# Or visit
# https://www.npmjs.com/package/claude-gate
```

#### User Issues

Monitor:
- GitHub issues with `npm` label
- NPM package page reviews
- Social media mentions

#### Security Monitoring

```bash
# Check for vulnerabilities
npm audit

# Update dependencies
npm update

# Check outdated packages
npm outdated
```

---

[← Deployment](../README.md#deployment) | [Documentation Home](../README.md)
// End of docs/deployment/npm-package.md

=====================

// File: docs/getting-started/configuration.md

# Configuration Guide

Claude Gate can be configured through command-line flags, environment variables, or configuration files.

## Configuration Methods

### 1. Command-Line Flags

Command-line flags take the highest precedence:

```bash
claude-gate start --port 3000 --host 0.0.0.0 --log-level debug
```

### 2. Environment Variables

Set environment variables before starting Claude Gate:

```bash
export CLAUDE_GATE_PORT=3000
export CLAUDE_GATE_HOST=0.0.0.0
export CLAUDE_GATE_LOG_LEVEL=debug
claude-gate start
```

### 3. Configuration File

Create a configuration file at `~/.claude-gate/config.yaml`:

```yaml
# ~/.claude-gate/config.yaml
host: 127.0.0.1
port: 5789
log_level: info
proxy_auth_token: your-secret-token
dashboard:
  enabled: false
  refresh_interval: 1s
```

## Configuration Options

### Server Settings

| Option | Environment Variable | Default | Description |
|--------|---------------------|---------|-------------|
| `--host` | `CLAUDE_GATE_HOST` | `127.0.0.1` | IP address to bind to |
| `--port` | `CLAUDE_GATE_PORT` | `5789` | Port number to listen on |
| `--proxy-auth-token` | `CLAUDE_GATE_PROXY_AUTH_TOKEN` | (none) | Enable proxy authentication |

### Logging

| Option | Environment Variable | Default | Description |
|--------|---------------------|---------|-------------|
| `--log-level` | `CLAUDE_GATE_LOG_LEVEL` | `INFO` | Log level: DEBUG, INFO, WARNING, ERROR |
| `--log-file` | `CLAUDE_GATE_LOG_FILE` | (stdout) | Log to file instead of console |
| `--log-format` | `CLAUDE_GATE_LOG_FORMAT` | `text` | Log format: text, json |

### Dashboard

| Option | Environment Variable | Default | Description |
|--------|---------------------|---------|-------------|
| `--dashboard` | `CLAUDE_GATE_DASHBOARD` | `false` | Enable interactive dashboard |
| `--dashboard-refresh` | `CLAUDE_GATE_DASHBOARD_REFRESH` | `1s` | Dashboard refresh interval |

### Security

| Option | Environment Variable | Default | Description |
|--------|---------------------|---------|-------------|
| `--allowed-origins` | `CLAUDE_GATE_ALLOWED_ORIGINS` | `*` | CORS allowed origins |
| `--tls-cert` | `CLAUDE_GATE_TLS_CERT` | (none) | TLS certificate file |
| `--tls-key` | `CLAUDE_GATE_TLS_KEY` | (none) | TLS key file |

## Common Configurations

### Development Setup

For local development with maximum visibility:

```bash
claude-gate start \
  --host 127.0.0.1 \
  --port 5789 \
  --log-level debug \
  --dashboard
```

### Production Setup

For production use with security:

```bash
export CLAUDE_GATE_HOST=127.0.0.1
export CLAUDE_GATE_PORT=5789
export CLAUDE_GATE_PROXY_AUTH_TOKEN=$(openssl rand -hex 32)
export CLAUDE_GATE_LOG_LEVEL=info
export CLAUDE_GATE_LOG_FILE=/var/log/claude-gate.log

claude-gate start
```

### Docker Setup

Using environment variables with Docker:

```dockerfile
FROM golang:1.22-alpine
# ... build steps ...

ENV CLAUDE_GATE_HOST=0.0.0.0
ENV CLAUDE_GATE_PORT=5789
ENV CLAUDE_GATE_LOG_LEVEL=info

EXPOSE 5789
CMD ["claude-gate", "start"]
```

### Systemd Service

Create `/etc/systemd/system/claude-gate.service`:

```ini
[Unit]
Description=Claude Gate Proxy
After=network.target

[Service]
Type=simple
User=claude-gate
Environment="CLAUDE_GATE_PORT=5789"
Environment="CLAUDE_GATE_HOST=127.0.0.1"
Environment="CLAUDE_GATE_LOG_LEVEL=info"
ExecStart=/usr/local/bin/claude-gate start
Restart=always

[Install]
WantedBy=multi-user.target
```

## Authentication Storage

Claude Gate stores authentication tokens in:
- **macOS**: `~/Library/Application Support/claude-gate/`
- **Linux**: `~/.config/claude-gate/`
- **Windows**: `%APPDATA%\claude-gate\`

The token file permissions are set to 600 (user read/write only) for security.

## Proxy Authentication

To require authentication for proxy access:

1. Generate a secure token:
   ```bash
   openssl rand -hex 32
   ```

2. Set the environment variable:
   ```bash
   export CLAUDE_GATE_PROXY_AUTH_TOKEN=your-generated-token
   ```

3. Include the token in your API requests:
   ```python
   client = anthropic.Anthropic(
       base_url="http://localhost:5789",
       api_key="your-generated-token"  # Use the proxy auth token
   )
   ```

## TLS/HTTPS Support

To enable HTTPS:

1. Generate or obtain TLS certificates
2. Start Claude Gate with TLS:
   ```bash
   claude-gate start \
     --tls-cert /path/to/cert.pem \
     --tls-key /path/to/key.pem
   ```

3. Update your client to use HTTPS:
   ```python
   client = anthropic.Anthropic(
       base_url="https://localhost:5789",
       api_key="sk-dummy"
   )
   ```

## Configuration Best Practices

1. **Security First**
   - Always use `127.0.0.1` unless you need external access
   - Enable proxy authentication in production
   - Use TLS for external access

2. **Logging**
   - Use `INFO` level for production
   - Enable `DEBUG` only when troubleshooting
   - Rotate log files regularly

3. **Performance**
   - Keep the dashboard disabled in production
   - Use appropriate log levels to reduce I/O

4. **Monitoring**
   - Set up log aggregation for production use
   - Monitor disk space for log files
   - Track proxy usage patterns

## Troubleshooting Configuration

### Port Already in Use

If you get "address already in use" error:

1. Check what's using the port:
   ```bash
   lsof -i :5789  # macOS/Linux
   netstat -ano | findstr :5789  # Windows
   ```

2. Use a different port:
   ```bash
   claude-gate start --port 5790
   ```

### Configuration Not Loading

1. Check file location:
   ```bash
   claude-gate config --show-path
   ```

2. Validate YAML syntax:
   ```bash
   claude-gate config --validate
   ```

3. Check environment variables:
   ```bash
   env | grep CLAUDE_GATE
   ```

---

[← Quick Start](./quick-start.md) | [Documentation Home](../README.md) | [Troubleshooting →](../guides/troubleshooting.md)
// End of docs/getting-started/configuration.md

=====================

// File: docs/getting-started/installation.md

# Installation Guide

This guide covers all the ways to install Claude Gate on your system.

## Prerequisites

- **Claude Pro or Claude Max subscription** - Required for authentication
- **Supported Operating System**:
  - macOS (Intel & Apple Silicon)
  - Linux (x64 & ARM64)
  - Windows (x64)

## Installation Methods

### Via NPM (Recommended)

The easiest way to install Claude Gate is through NPM:

```bash
npm install -g claude-gate
```

This will automatically download the correct binary for your platform.

### Via Homebrew (macOS/Linux)

If you prefer Homebrew:

```bash
brew tap ml0-1337/tap
brew install claude-gate
```

### From Source

If you have Go 1.22+ installed:

```bash
go install github.com/ml0-1337/claude-gate/cmd/claude-gate@latest
```

### Direct Download

Download pre-built binaries from the [releases page](https://github.com/ml0-1337/claude-gate/releases).

1. Download the appropriate binary for your platform
2. Extract the archive
3. Move the binary to a location in your PATH (e.g., `/usr/local/bin`)
4. Make it executable: `chmod +x claude-gate` (macOS/Linux)

## Verify Installation

After installation, verify Claude Gate is working:

```bash
claude-gate version
```

## Development Installation

If you're planning to contribute to Claude Gate, see our [Development Guide](../guides/development.md) for setting up a development environment.

### Development Prerequisites

- Go 1.22 or later
- Node.js 18 or later (for NPM package testing)
- Git
- Make
- GoReleaser (for release builds)

### Development Setup

```bash
# Clone the repository
git clone https://github.com/ml0-1337/claude-gate.git
cd claude-gate

# Install dependencies
go mod download

# Build the project
make build

# Run tests
make test
```

## Configuration

Claude Gate uses the following default settings:

- **Host**: `127.0.0.1` (localhost only)
- **Port**: `5789`

You can customize these using environment variables:

```bash
export CLAUDE_GATE_HOST=127.0.0.1
export CLAUDE_GATE_PORT=5789
export CLAUDE_GATE_PROXY_AUTH_TOKEN=your-token  # Optional: Enable proxy authentication
export CLAUDE_GATE_LOG_LEVEL=INFO               # Options: DEBUG, INFO, WARNING, ERROR
```

For more configuration options, see the [Configuration Guide](./configuration.md).

## Troubleshooting Installation

Having issues? Check our [Troubleshooting Guide](../guides/troubleshooting.md) or common solutions below:

### NPM Installation Fails

If NPM installation fails, try:

1. Clear NPM cache: `npm cache clean --force`
2. Use a different registry: `npm install -g claude-gate --registry https://registry.npmjs.org/`
3. Install with verbose logging: `npm install -g claude-gate --verbose`

### Permission Errors

On macOS/Linux, you might need to use sudo:

```bash
sudo npm install -g claude-gate
```

Or configure NPM to use a different directory for global packages.

### Binary Not Found

If the `claude-gate` command is not found after installation:

1. Check if it's in your PATH: `which claude-gate`
2. Find where NPM installs global packages: `npm root -g`
3. Add the NPM bin directory to your PATH

## Next Steps

Once installed, proceed to the [Quick Start Guide](./quick-start.md) to authenticate and start using Claude Gate.

---

[← Back to Documentation](../README.md) | [Quick Start →](./quick-start.md)
// End of docs/getting-started/installation.md

=====================

// File: docs/getting-started/quick-start.md

# Quick Start Guide

Get up and running with Claude Gate in just a few minutes!

## Prerequisites

- Claude Gate installed ([Installation Guide](./installation.md))
- Claude Pro or Claude Max subscription
- Python, Node.js, or any language with an Anthropic SDK

## Step 1: Authenticate

First, authenticate with your Claude account:

```bash
claude-gate auth login
```

This will:
1. Open your browser to the Claude login page
2. Guide you through the OAuth authentication flow
3. Securely store your authentication token

## Step 2: Start the Proxy Server

Start Claude Gate in the background:

```bash
claude-gate start
```

The proxy server will start on `http://localhost:5789` by default.

To run with a custom port:

```bash
claude-gate start --port 3000
```

## Step 3: Use with Anthropic SDKs

Now you can use any Anthropic SDK with Claude Gate as the proxy:

### Python Example

```python
import anthropic

client = anthropic.Anthropic(
    base_url="http://localhost:5789",
    api_key="sk-dummy"  # Can be any string
)

response = client.messages.create(
    model="claude-opus-4-20250514",  # Latest Claude 4 Opus
    max_tokens=300,
    messages=[
        {"role": "user", "content": "Hello, Claude!"}
    ]
)

print(response.content[0].text)
```

### Node.js Example

```javascript
import Anthropic from '@anthropic-ai/sdk';

const client = new Anthropic({
  baseURL: 'http://localhost:5789',
  apiKey: 'sk-dummy', // Can be any string
});

const response = await client.messages.create({
  model: 'claude-opus-4-20250514',  // Latest Claude 4 Opus
  max_tokens: 300,
  messages: [
    { role: 'user', content: 'Hello, Claude!' }
  ],
});

console.log(response.content[0].text);
```

### OpenAI SDK Example (Compatibility Mode)

```python
from openai import OpenAI

client = OpenAI(
    api_key="sk-dummy",  # Can be any string
    base_url="http://localhost:5789/v1/"  # Note the /v1/ suffix
)

response = client.chat.completions.create(
    model="claude-opus-4-20250514",  # Latest Claude 4 Opus
    messages=[
        {"role": "system", "content": "You are a helpful assistant."},
        {"role": "user", "content": "Hello, Claude!"}
    ]
)

print(response.choices[0].message.content)
```

**Note**: OpenAI SDK compatibility has some limitations. System messages are concatenated to the conversation start, and some OpenAI-specific parameters are ignored.

### cURL Example

```bash
curl -X POST http://localhost:5789/v1/messages \
  -H "Content-Type: application/json" \
  -H "X-API-Key: sk-dummy" \
  -H "anthropic-version: 2023-06-01" \
  -d '{
    "model": "claude-opus-4-20250514",
    "max_tokens": 300,
    "messages": [
      {"role": "user", "content": "Hello, Claude!"}
    ]
  }'
```

## Step 4: Monitor Usage (Optional)

View the interactive dashboard to monitor your usage:

```bash
claude-gate start --dashboard
```

This shows:
- Real-time request metrics
- Token usage statistics
- Response times
- Error rates

## Common Commands

### Check Status

```bash
claude-gate status
```

### Stop the Server

```bash
claude-gate stop
```

### View Logs

```bash
claude-gate logs
```

### Re-authenticate

```bash
claude-gate auth refresh
```

## What's Next?

- **Configure Claude Gate**: See the [Configuration Guide](./configuration.md)
- **Integrate with your app**: Check the [API Reference](../reference/api.md)
- **Run into issues?**: Visit our [Troubleshooting Guide](../guides/troubleshooting.md)
- **Want to contribute?**: Read the [Contributing Guide](../guides/contributing.md)

## Tips

1. **Keep it running**: Claude Gate needs to be running for your applications to work
2. **Security**: By default, Claude Gate only accepts connections from localhost
3. **Rate limits**: Claude Gate respects your Claude subscription's rate limits
4. **Token usage**: Monitor your token usage through the dashboard to avoid surprises

---

[← Installation](./installation.md) | [Documentation Home](../README.md) | [Configuration →](./configuration.md)
// End of docs/getting-started/quick-start.md

=====================

// File: docs/guides/contributing.md

# Contributing to Claude Gate

Thank you for your interest in contributing to Claude Gate! This guide will help you get started with development and ensure your contributions align with our project standards.

## Table of Contents

- [Getting Started](#getting-started)
- [Development Setup](#development-setup)
- [Project Structure](#project-structure)
- [Development Workflow](#development-workflow)
- [Testing](#testing)
- [Code Style](#code-style)
- [Submitting Changes](#submitting-changes)
- [Release Process](#release-process)

## Getting Started

### Prerequisites

- Go 1.22 or later
- Node.js 18 or later (for NPM package testing)
- Git
- Make
- GoReleaser (for release builds)

### Initial Setup

```bash
# Clone the repository
git clone https://github.com/ml0-1337/claude-gate.git
cd claude-gate

# Install dependencies
go mod download

# Build the project
make build

# Run tests
make test
```

## Development Setup

### Environment Setup

1. **Go Environment**
   ```bash
   # Ensure Go is properly installed
   go version
   
   # Set up Go workspace (if needed)
   export GOPATH=$HOME/go
   export PATH=$PATH:$GOPATH/bin
   ```

2. **Development Tools**
   ```bash
   # Install GoReleaser
   brew install goreleaser/tap/goreleaser
   
   # Install linting tools
   go install github.com/golangci/golangci-lint/cmd/golangci-lint@latest
   ```

3. **Editor Configuration**
   - VS Code: Install Go extension
   - GoLand: Built-in support
   - Vim/Neovim: Use vim-go or nvim-lspconfig

## Project Structure

```
claude-gate/
├── cmd/claude-gate/        # CLI entry point
│   └── main.go            # Main application
├── internal/              # Private packages
│   ├── auth/             # OAuth authentication
│   ├── config/           # Configuration management
│   └── proxy/            # Core proxy logic
├── docs/                 # Documentation
│   ├── architecture/     # System design docs
│   └── decisions/        # ADRs
├── scripts/              # Build and test scripts
├── npm/                  # NPM distribution
└── .claude/              # Project management
    ├── todos/            # Active tasks
    └── knowledge/        # Research docs
```

## Development Workflow

### 1. Creating a New Feature

```bash
# Create a feature branch
git checkout -b feature/your-feature-name

# Make changes and test
make test

# Build and test locally
make build && ./claude-gate test
```

### 2. Task Management

We use `.claude/todos/` for task tracking:

```bash
# Create a task file
touch .claude/todos/your-task.md

# Use the template format (see existing todos)
```

### 3. Making Changes

1. **Write tests first** (TDD approach)
2. **Implement the feature**
3. **Update documentation**
4. **Run full test suite**

### 4. Code Organization

- Put reusable code in appropriate `internal/` packages
- Keep `main.go` minimal - delegate to packages
- Use meaningful package names
- Follow single responsibility principle

## Testing

### Running Tests

```bash
# Run all tests with coverage
make test

# Run specific package tests
go test ./internal/auth/...

# Run with race detection
go test -race ./...

# Run integration tests
make test-all
```

### Writing Tests

1. **Unit Tests**
   - Test individual functions
   - Use table-driven tests
   - Mock external dependencies
   - Achieve >80% coverage

2. **Integration Tests**
   - Test component interactions
   - Use real implementations
   - Test error scenarios

3. **Test Organization**
   ```go
   func TestFunctionName(t *testing.T) {
       t.Run("successful case", func(t *testing.T) {
           // Test implementation
       })
       
       t.Run("error case", func(t *testing.T) {
           // Test implementation
       })
   }
   ```

## Code Style

### Go Code Guidelines

1. **Formatting**
   - Use `gofmt` (automatic with most editors)
   - Keep lines under 120 characters
   - Use meaningful variable names

2. **Error Handling**
   ```go
   // Good
   if err != nil {
       return fmt.Errorf("failed to process request: %w", err)
   }
   
   // Bad
   if err != nil {
       return err
   }
   ```

3. **Comments**
   - Document all exported functions
   - Explain "why", not "what"
   - Keep comments up-to-date

4. **Package Design**
   - Small, focused packages
   - Clear interfaces
   - Minimize dependencies

### Commit Messages

Follow conventional commits:

```
type(scope): subject

body

footer
```

Types:
- `feat`: New feature
- `fix`: Bug fix
- `docs`: Documentation
- `test`: Testing
- `refactor`: Code refactoring
- `chore`: Maintenance

Example:
```
feat(auth): add keychain support for token storage

Implement OS-specific keychain integration for secure token storage.
Supports macOS Keychain, Linux Secret Service, and Windows Credential Manager.

Closes #123
```

## Submitting Changes

### Pull Request Process

1. **Before Submitting**
   - [ ] Tests pass (`make test`)
   - [ ] Code is formatted (`gofmt`)
   - [ ] Documentation updated
   - [ ] Commit messages follow convention
   - [ ] Branch is up-to-date with main

2. **PR Description Template**
   ```markdown
   ## Description
   Brief description of changes
   
   ## Type of Change
   - [ ] Bug fix
   - [ ] New feature
   - [ ] Breaking change
   - [ ] Documentation update
   
   ## Testing
   - [ ] Unit tests pass
   - [ ] Integration tests pass
   - [ ] Manual testing completed
   
   ## Checklist
   - [ ] My code follows the project style
   - [ ] I have added tests for my changes
   - [ ] Documentation has been updated
   ```

3. **Review Process**
   - Maintainers will review within 48 hours
   - Address feedback promptly
   - Keep PR focused and small
   - Be patient and respectful

### Code Review Guidelines

**For Authors:**
- Keep PRs small and focused
- Respond to feedback constructively
- Update based on suggestions
- Test thoroughly before requesting review

**For Reviewers:**
- Be constructive and specific
- Suggest improvements, don't just criticize
- Approve when ready, not perfect
- Consider the bigger picture

## Release Process

### Version Numbering

We use semantic versioning (MAJOR.MINOR.PATCH):
- MAJOR: Breaking changes
- MINOR: New features (backward compatible)
- PATCH: Bug fixes

### Creating a Release

```bash
# Update version
make release VERSION=1.2.3

# This will:
# 1. Update version in all files
# 2. Create git commit
# 3. Create git tag
# 4. Show push instructions
```

### Release Checklist

- [ ] All tests passing
- [ ] Documentation updated
- [ ] CHANGELOG updated
- [ ] Version bumped
- [ ] Tag created
- [ ] Release notes written

## Getting Help

### Resources

- [Project Documentation](../README.md)
- [Architecture Overview](../architecture/overview.md)
- [Security Policy](../architecture/security.md)
- [Issue Tracker](https://github.com/ml0-1337/claude-gate/issues)

### Communication

- **Issues**: Bug reports and feature requests
- **Discussions**: General questions and ideas
- **Pull Requests**: Code contributions

### First-Time Contributors

Look for issues labeled:
- `good first issue`
- `help wanted`
- `documentation`

## Thank You!

Your contributions make Claude Gate better for everyone. We appreciate your time and effort in improving this project!

---

[← Guides](../README.md#guides) | [Documentation Home](../README.md) | [Development →](./development.md)
// End of docs/guides/contributing.md

=====================

// File: docs/guides/development.md

# Development Guide

This guide covers everything you need to know to set up a development environment for Claude Gate.

## Prerequisites

- **Go 1.22 or later** - [Install Go](https://golang.org/dl/)
- **Node.js 18 or later** - For NPM package testing
- **Git** - Version control
- **Make** - Build automation
- **GoReleaser** - For release builds (optional)

### macOS Setup

```bash
# Install Homebrew if not already installed
/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"

# Install prerequisites
brew install go node git
brew install goreleaser/tap/goreleaser
```

### Linux Setup

```bash
# Ubuntu/Debian
sudo apt update
sudo apt install golang nodejs npm git make

# Fedora/RHEL
sudo dnf install golang nodejs npm git make
```


## Setting Up the Development Environment

### 1. Fork and Clone

```bash
# Fork the repository on GitHub, then:
git clone https://github.com/YOUR_USERNAME/claude-gate.git
cd claude-gate

# Add upstream remote
git remote add upstream https://github.com/ml0-1337/claude-gate.git
```

### 2. Install Dependencies

```bash
# Go dependencies
go mod download

# Install development tools
go install github.com/golangci/golangci-lint/cmd/golangci-lint@latest
go install golang.org/x/tools/cmd/goimports@latest
go install mvdan.cc/gofumpt@latest
```

### 3. Build and Test

```bash
# Build the binary
make build

# Run all tests
make test

# Run tests with coverage
make test-coverage

# Run linting
make lint
```

## Development Workflow

### 1. Create a Feature Branch

```bash
git checkout -b feature/your-feature-name
```

### 2. Make Your Changes

Follow the project structure:

```
claude-gate/
├── cmd/claude-gate/      # Main application entry point
├── internal/             # Internal packages
│   ├── auth/            # Authentication logic
│   ├── config/          # Configuration management
│   ├── proxy/           # Proxy server implementation
│   └── ui/              # Terminal UI components
├── pkg/                  # Public packages
└── scripts/             # Build and utility scripts
```

### 3. Write Tests

All new features should include tests:

```go
// internal/auth/oauth_test.go
func TestOAuthFlow(t *testing.T) {
    // Your test implementation
}
```

Run tests for a specific package:

```bash
go test ./internal/auth/...
```

### 4. Run Local Development Server

```bash
# Build and run with debug logging
go run cmd/claude-gate/main.go start --log-level debug
```

### 5. Test NPM Package Locally

```bash
# Build for all platforms and test NPM package
make npm-test

# Or separately:
make snapshot      # Build all platforms with GoReleaser
./scripts/test-npm-local.sh  # Test NPM package installation

# To test the created package globally:
npm install -g /path/to/created/claude-gate-0.1.0.tgz
claude-gate version
```

## Code Style Guide

### Go Code Style

We follow standard Go conventions with some additions:

1. **Format code** with `gofumpt` (stricter than `gofmt`):
   ```bash
   gofumpt -w .
   ```

2. **Import ordering** with `goimports`:
   ```bash
   goimports -w .
   ```

3. **Linting** with `golangci-lint`:
   ```bash
   golangci-lint run
   ```

### Code Organization

- Keep functions small and focused
- Use meaningful variable and function names
- Add comments for exported functions
- Group related functionality in packages

### Error Handling

```go
// Good
if err != nil {
    return fmt.Errorf("failed to authenticate: %w", err)
}

// Bad
if err != nil {
    return err
}
```

## Debugging

### Enable Debug Logging

```bash
# Via environment variable
export CLAUDE_GATE_LOG_LEVEL=debug
claude-gate start

# Or via flag
claude-gate start --log-level debug
```

### Using Delve Debugger

```bash
# Install Delve
go install github.com/go-delve/delve/cmd/dlv@latest

# Debug the application
dlv debug cmd/claude-gate/main.go -- start --log-level debug
```

### Common Debugging Commands

```bash
# Check binary location
which claude-gate

# View configuration
claude-gate config --show

# Test authentication
claude-gate auth status

# View stored tokens (macOS)
ls -la ~/Library/Application\ Support/claude-gate/
```

## Testing

### Unit Tests

```bash
# Run all unit tests
make test

# Run tests for specific package
go test ./internal/proxy/...

# Run tests with verbose output
go test -v ./...

# Run tests with race detection
go test -race ./...
```

### Integration Tests

```bash
# Run integration tests
make test-integration

# Run specific integration test
go test -tags=integration ./internal/test/integration/...
```

### End-to-End Tests

```bash
# Run e2e tests
make test-e2e

# Test cross-platform builds
./scripts/test-all.sh
```

## Building

### Local Build

```bash
# Build for current platform
make build

# Build with version info
make build VERSION=v1.2.3
```

### Cross-Platform Builds

```bash
# Build for all platforms
make build-all

# Build for specific platform
GOOS=linux GOARCH=amd64 make build
GOOS=darwin GOARCH=arm64 make build
GOOS=windows GOARCH=amd64 make build
```

### Release Builds

```bash
# Create a release with GoReleaser
goreleaser release --snapshot --clean

# Build NPM packages
make build-npm
```

## Troubleshooting Development Issues

### Go Module Issues

```bash
# Clean module cache
go clean -modcache

# Update dependencies
go mod tidy
go mod vendor
```

### Build Failures

```bash
# Clean build artifacts
make clean

# Rebuild everything
make clean build
```

### Test Failures

```bash
# Run tests with more output
go test -v -count=1 ./...

# Skip test cache
go test -count=1 ./...
```

## Contributing Your Changes

1. **Commit your changes**:
   ```bash
   git add .
   git commit -m "feat: add new feature"
   ```

2. **Push to your fork**:
   ```bash
   git push origin feature/your-feature-name
   ```

3. **Create a Pull Request**:
   - Go to GitHub and create a PR from your fork
   - Fill out the PR template
   - Wait for CI to pass

See our [Contributing Guide](./contributing.md) for more details on the PR process.

## Additional Resources

- [Go Documentation](https://golang.org/doc/)
- [Effective Go](https://golang.org/doc/effective_go)
- [Go Code Review Comments](https://github.com/golang/go/wiki/CodeReviewComments)
- [Project Architecture](../architecture/overview.md)

---

[← Guides](../README.md#guides) | [Documentation Home](../README.md) | [Contributing →](./contributing.md)
// End of docs/guides/development.md

=====================

// File: docs/guides/storage.md

# Token Storage Guide

Claude Gate now supports secure platform-native token storage using your operating system's built-in security features.

## Overview

By default, Claude Gate automatically selects the most secure storage backend available on your system:

- **macOS**: Keychain Services
- **Linux**: Secret Service API (GNOME Keyring, KWallet)
- **Fallback**: Encrypted file storage when OS keychain is unavailable

## Storage Backends

### OS Keychain (Recommended)
Your tokens are stored in the operating system's secure credential storage:
- Hardware-backed security when available
- Encrypted at rest by the OS
- Integrated with system security (Touch ID, etc.)
- Survives application updates

### File Storage (Fallback)
When keychain access is unavailable:
- Tokens stored in `~/.claude-gate/auth.json`
- File permissions restricted to owner only (0600)
- Optional encryption using JOSE (JSON Web Encryption)
- Portable across systems

## Configuration

### Environment Variables

```bash
# Storage backend selection (auto, keyring, file)
export CLAUDE_GATE_AUTH_STORAGE_TYPE=auto

# Keyring service name
export CLAUDE_GATE_KEYRING_SERVICE=claude-gate

# File storage path
export CLAUDE_GATE_AUTH_STORAGE_PATH=~/.claude-gate/auth.json

# Auto-migrate tokens to keyring
export CLAUDE_GATE_AUTO_MIGRATE_TOKENS=true
```

### Storage Commands

```bash
# Check current storage backend
claude-gate auth storage status

# Migrate tokens between backends
claude-gate auth storage migrate --from file --to keyring

# Test storage operations
claude-gate auth storage test

# Create backup (file storage only)
claude-gate auth storage backup
```

## Migration

When you update Claude Gate, existing tokens are automatically migrated to the most secure available backend:

1. **Automatic Migration**: Happens on first use after update
2. **Manual Migration**: Use `claude-gate auth storage migrate`
3. **Backup Creation**: Original tokens are backed up before migration
4. **Verification**: Migration is verified before marking complete

## Troubleshooting

### Keychain Access Issues

**macOS**: If prompted for keychain access, click "Always Allow" to avoid repeated prompts.

**Linux**: Ensure a keyring daemon is running:
```bash
# Check if keyring is available
echo $GNOME_KEYRING_CONTROL
# or
echo $SSH_AUTH_SOCK
```

### Fallback Behavior

If keychain access fails, Claude Gate automatically falls back to file storage with a warning. To force a specific backend:

```bash
# Force file storage
export CLAUDE_GATE_AUTH_STORAGE_TYPE=file

# Force keyring (fails if unavailable)
export CLAUDE_GATE_AUTH_STORAGE_TYPE=keyring
```

### Permission Errors

**Linux**: You may need to unlock your keyring on first use:
```bash
# Unlock GNOME Keyring
gnome-keyring-daemon --unlock
```

**All Platforms**: Ensure you have write permissions to `~/.claude-gate/`:
```bash
mkdir -p ~/.claude-gate
chmod 700 ~/.claude-gate
```

## Security Considerations

1. **Keychain Security**: Your tokens are as secure as your system login
2. **Backup Security**: Backups are stored in `~/.claude-gate/backups/` with restricted permissions
3. **Migration Security**: Tokens are never transmitted during migration
4. **Revocation**: Use `claude-gate auth logout` to remove all stored tokens

## Best Practices

1. **Use OS Keychain**: Let Claude Gate use your OS keychain when available
2. **Regular Backups**: Periodically backup tokens if using file storage
3. **Monitor Access**: Check `claude-gate auth storage status` regularly
4. **Update Promptly**: Keep Claude Gate updated for latest security fixes
5. **Logout When Done**: Remove tokens if not using Claude Gate for extended periods

## Platform-Specific Notes

### macOS
- Tokens stored in login keychain by default
- Synced across devices if iCloud Keychain enabled
- May prompt for password after system updates

### Linux
- Requires D-Bus and keyring daemon
- Works with GNOME Keyring, KDE Wallet, etc.
- May require unlocking after reboot

### Docker/Containers
- Keychain not available in containers
- Always uses file storage
- Mount volume for persistence: `-v ~/.claude-gate:/root/.claude-gate`

## Advanced Usage

### Custom Password for File Backend

When using encrypted file storage, you can provide a custom password:

```go
// In code - implement PasswordPromptFunc
func myPasswordPrompt(prompt string) (string, error) {
    // Return password from secure source
    return os.Getenv("CLAUDE_GATE_MASTER_PASSWORD"), nil
}
```

### Multiple Profiles

Store tokens for different accounts:

```bash
# Use different service names
export CLAUDE_GATE_KEYRING_SERVICE=claude-gate-work
claude-gate auth login

export CLAUDE_GATE_KEYRING_SERVICE=claude-gate-personal  
claude-gate auth login
```

For questions or issues, please see our [Troubleshooting Guide](./troubleshooting.md) or [open an issue](https://github.com/ml0-1337/claude-gate/issues).
// End of docs/guides/storage.md

=====================

// File: docs/guides/troubleshooting.md

# Claude Gate Troubleshooting Guide

## Installation Issues

### NPM Installation Fails

**Problem:** `npm install -g claude-gate` fails with permission errors.

**Solution:**
```bash
# Option 1: Use a Node version manager (recommended)
# Install nvm: https://github.com/nvm-sh/nvm
nvm install node
npm install -g claude-gate

# Option 2: Change npm's default directory
mkdir ~/.npm-global
npm config set prefix '~/.npm-global'
echo 'export PATH=~/.npm-global/bin:$PATH' >> ~/.bashrc
source ~/.bashrc
npm install -g claude-gate
```

### Binary Not Found After Installation

**Problem:** `claude-gate: command not found` after successful installation.

**Solution:**
1. Check where npm installs global packages:
   ```bash
   npm config get prefix
   ```
2. Ensure the bin directory is in your PATH:
   ```bash
   # Add to ~/.bashrc or ~/.zshrc
   export PATH="$(npm config get prefix)/bin:$PATH"
   ```

### Platform Not Supported Error

**Problem:** "Unsupported platform" error during installation.

**Solution:**
- Check supported platforms: darwin-x64, darwin-arm64, linux-x64, linux-arm64, win32-x64
- For other platforms, build from source:
  ```bash
  git clone https://github.com/ml0-1337/claude-gate
  cd claude-gate
  go build -o claude-gate ./cmd/claude-gate
  ```

### Installation with --ignore-scripts

**Problem:** Binary doesn't work when installed with `npm install -g claude-gate --ignore-scripts`.

**Solution:**
The package includes a fallback mechanism that should handle this automatically. If it doesn't work:
```bash
# Manually run the install script
cd $(npm root -g)/claude-gate
node scripts/install.js
```

## Runtime Issues

### OAuth Authentication Fails

**Problem:** "OAuth token error" when starting the proxy.

**Solution:**
1. Re-authenticate:
   ```bash
   claude-gate auth logout
   claude-gate auth login
   ```
2. Check if you have an active Claude Pro/Max subscription
3. Ensure you're using the correct authorization code
4. Check storage backend status:
   ```bash
   claude-gate auth storage status
   ```
5. For keychain issues, see [Token Storage Guide](./storage.md)

### Proxy Connection Refused

**Problem:** Cannot connect to the proxy server.

**Solution:**
1. Check if the proxy is running:
   ```bash
   claude-gate test
   ```
2. Verify the port isn't already in use:
   ```bash
   lsof -i :5789  # macOS/Linux
   ```
3. Try a different port:
   ```bash
   claude-gate start --port 5789
   ```

### SSE Streaming Not Working

**Problem:** Streaming responses appear to hang or timeout.

**Solution:**
1. Ensure your HTTP client supports SSE
2. Check if a proxy or firewall is interfering
3. Verify your client isn't buffering the response

### Token Expiration Issues

**Problem:** "Token is expired" errors during use.

**Solution:**
The proxy should automatically refresh tokens. If not:
```bash
claude-gate auth status  # Check token status
claude-gate auth login   # Re-authenticate if needed
```

## Build Issues

### GoReleaser Build Fails

**Problem:** `goreleaser build` fails with errors.

**Solution:**
1. Ensure Go 1.22+ is installed:
   ```bash
   go version
   ```
2. Install dependencies:
   ```bash
   go mod download
   ```
3. Check for syntax errors:
   ```bash
   go build ./...
   ```

### NPM Package Testing Fails

**Problem:** `make npm-test` doesn't work correctly.

**Solution:**
1. Ensure binaries are built first:
   ```bash
   make snapshot
   ```
2. Check Node.js version (16+ required):
   ```bash
   node --version
   ```

## Common Error Messages

### "OAuth token error"
- **Cause:** No valid authentication or token expired
- **Fix:** Run `claude-gate auth login`

### "Failed to transform request"
- **Cause:** Invalid request format
- **Fix:** Ensure you're using a compatible Anthropic SDK

### "This credential is only authorized for use with Claude Code"
- **Cause:** The proxy is not properly injecting the Claude Code system prompt
- **Fix:** Update to version 0.2.1+ which fixes system prompt injection for requests without an existing system prompt
- **Details:** This error typically occurs when using the Anthropic SDK without including a system prompt in your request. The latest version automatically injects the required Claude Code identification.

### "Upstream request failed"
- **Cause:** Network issues or Anthropic API down
- **Fix:** Check internet connection and Anthropic status

### "Unsupported platform"
- **Cause:** Running on an unsupported OS/architecture
- **Fix:** Build from source for your platform

## Getting Help

If you're still experiencing issues:

1. Check existing issues: https://github.com/ml0-1337/claude-gate/issues
2. Create a new issue with:
   - Your OS and architecture (`uname -a` on Unix)
   - Node.js version (`node --version`)
   - NPM version (`npm --version`)
   - Complete error message
   - Steps to reproduce

## Debug Mode

For more detailed logging:
```bash
CLAUDE_GATE_LOG_LEVEL=DEBUG claude-gate start
```

This will show detailed information about:
- OAuth token operations
- Request/response transformations
- Proxy operations
- Error details

## Token Storage Issues

### Keychain Access Denied

**Problem:** "keyring access denied" or repeated password prompts on macOS.

**Solution:**
1. When prompted, click "Always Allow" instead of "Allow"
2. Check Keychain Access app for any denied entries
3. Reset keychain permissions:
   ```bash
   security unlock-keychain ~/Library/Keychains/login.keychain
   ```

### macOS Repeated Password Prompts (Fixed)

**Problem:** macOS shows password prompts every time Claude Gate accesses the keychain.

**Solution:**
As of version 0.2.0+, Claude Gate automatically configures the `KeychainTrustApplication` setting to prevent repeated password prompts. You should only see one prompt on first use where you can click "Always Allow".

If you still experience repeated prompts:

1. **Update to the latest version:**
   ```bash
   npm update -g claude-gate
   ```

2. **Clear existing keychain entries and re-authenticate:**
   ```bash
   claude-gate auth logout
   claude-gate auth login
   ```

3. **Override default settings (if needed):**
   ```bash
   # Disable application trust (not recommended)
   export CLAUDE_GATE_KEYCHAIN_TRUST_APP=false
   
   # Change accessibility settings
   export CLAUDE_GATE_KEYCHAIN_ACCESSIBLE_WHEN_UNLOCKED=false
   
   # Enable iCloud sync (security risk - not recommended)
   export CLAUDE_GATE_KEYCHAIN_SYNCHRONIZABLE=true
   ```

4. **Check keychain permissions in Keychain Access app:**
   - Open Keychain Access (Applications > Utilities)
   - Search for "claude-gate"
   - Double-click the entry
   - Go to Access Control tab
   - Ensure claude-gate is in the allowed applications list

5. **Reset keychain items with proper trust settings:**
   ```bash
   # This will recreate all keychain items with correct trust settings
   claude-gate auth storage reset
   
   # Skip confirmation prompt
   claude-gate auth storage reset -f
   ```
   This command removes and recreates all stored tokens with the proper trust settings.
   After running this, you should only see one password prompt when first accessing the keychain.

### Linux Keyring Not Available

**Problem:** "keyring backend not available" on Linux.

**Solution:**
1. Install required packages:
   ```bash
   # Debian/Ubuntu
   sudo apt-get install gnome-keyring libsecret-1-0
   
   # Fedora/RHEL
   sudo dnf install gnome-keyring libsecret
   ```
2. Ensure D-Bus is running:
   ```bash
   echo $DBUS_SESSION_BUS_ADDRESS
   ```
3. Start keyring daemon:
   ```bash
   gnome-keyring-daemon --start --daemonize
   ```

### Automatic Migration Fails

**Problem:** Token migration from file to keychain fails.

**Solution:**
1. Check current storage status:
   ```bash
   claude-gate auth storage status
   ```
2. Manually migrate:
   ```bash
   claude-gate auth storage migrate --from file --to keyring
   ```
3. Force file storage if keychain issues persist:
   ```bash
   export CLAUDE_GATE_AUTH_STORAGE_TYPE=file
   ```

### Tokens Lost After Update

**Problem:** Authentication required after updating Claude Gate.

**Solution:**
1. Check for migrated file:
   ```bash
   ls ~/.claude-gate/auth.json.migrated
   ```
2. Restore from backup:
   ```bash
   cp ~/.claude-gate/backups/auth-*.json ~/.claude-gate/auth.json
   ```
3. Re-authenticate if necessary:
   ```bash
   claude-gate auth login
   ```

For more storage-related issues, see the [Token Storage Guide](./storage.md).

---

[← Guides](../README.md#guides) | [Documentation Home](../README.md) | [Contributing →](./contributing.md)
// End of docs/guides/troubleshooting.md

=====================

// File: docs/README.md

# Claude Gate Documentation

Welcome to the Claude Gate documentation! This guide will help you navigate through all available documentation.

## 📚 Documentation Structure

### [Getting Started](./getting-started/)
- [Installation](./getting-started/installation.md) - How to install Claude Gate
- [Quick Start](./getting-started/quick-start.md) - Get up and running in minutes
- [Configuration](./getting-started/configuration.md) - Configure Claude Gate for your needs

### [Guides](./guides/)
- [Contributing](./guides/contributing.md) - Guidelines for contributors
- [Development](./guides/development.md) - Setting up your development environment
- [Troubleshooting](./guides/troubleshooting.md) - Common issues and solutions

### [Testing](./testing/)
- [Test Guide](./testing/test-guide.md) - How to run tests and validate builds
- [Test Results](./testing/test-results/) - Archive of test execution results

### [Reference](./reference/)
- [API Reference](./reference/api.md) - HTTP API endpoints and usage
- [CLI Reference](./reference/cli.md) - Command-line interface documentation
- [Configuration Reference](./reference/configuration.md) - All configuration options

### [Architecture](./architecture/)
- [Overview](./architecture/overview.md) - System architecture and design
- [Security](./architecture/security.md) - Security model and best practices
- [Decision Records](./architecture/decisions/) - Architectural decision records (ADRs)

### [Deployment](./deployment/)
- [NPM Package](./deployment/npm-package.md) - Publishing and using the NPM package

## 🔍 Quick Links

- **First time?** Start with the [Installation Guide](./getting-started/installation.md)
- **Contributing?** Read our [Contributing Guidelines](./guides/contributing.md)
- **Having issues?** Check the [Troubleshooting Guide](./guides/troubleshooting.md)
- **API Integration?** See the [API Reference](./reference/api.md)

## 📖 About This Documentation

This documentation is organized to help you find information quickly:

- **Getting Started**: Essential information for new users
- **Guides**: Step-by-step instructions for common tasks
- **Reference**: Detailed technical specifications
- **Architecture**: Design decisions and system internals

## 🤝 Contributing to Docs

Found an error or want to improve the documentation? See our [Contributing Guide](./guides/contributing.md) for details on how to help.

---

[← Back to Main README](../README.md)
// End of docs/README.md

=====================

// File: docs/reference/api.md

# Claude Gate API Documentation

## Overview

Claude Gate acts as a transparent proxy to the Anthropic Claude API, adding OAuth authentication and system prompt injection. It maintains full API compatibility while identifying as "Claude Code".

## Base URL

```
http://localhost:5789
```

The proxy listens on port 5789 by default. This can be configured via environment variables.

## Authentication

Claude Gate handles OAuth authentication transparently. Before making API requests:

1. Authenticate using the CLI: `claude-gate auth login`
2. Start the proxy server: `claude-gate start`
3. Configure your client to use `http://localhost:5789` instead of `https://api.anthropic.com`

## Proxied Endpoints

All Anthropic Claude API endpoints are proxied transparently:

### Messages API
```
POST /v1/messages
```

Creates a message with the Claude model. The proxy automatically:
- Adds OAuth authentication headers
- Injects "Claude Code" system prompt
- Maps model aliases (e.g., "latest" to specific versions)

### Models API
```
GET /v1/models
```

Lists available models (proxied directly).

### Other Endpoints

All other Anthropic API endpoints are proxied without modification, with only authentication headers added.

## Request Transformation

### System Prompt Injection

The proxy ensures all requests identify as "Claude Code":

**Original Request:**
```json
{
  "model": "claude-3-5-sonnet-20241022",
  "system": "You are a helpful assistant",
  "messages": [{"role": "user", "content": "Hello"}]
}
```

**Transformed Request:**
```json
{
  "model": "claude-3-5-sonnet-20241022",
  "system": [
    {"type": "text", "text": "You are Claude Code, Anthropic's official CLI for Claude."},
    {"type": "text", "text": "You are a helpful assistant"}
  ],
  "messages": [{"role": "user", "content": "Hello"}]
}
```

### Model Alias Mapping

The proxy automatically maps model aliases:

| Alias | Actual Model |
|-------|--------------|
| claude-3-5-haiku-latest | claude-3-5-haiku-20241022 |
| claude-3-5-sonnet-latest | claude-3-5-sonnet-20241022 |
| claude-3-7-sonnet-latest | claude-3-7-sonnet-20250219 |
| claude-3-opus-latest | claude-3-opus-20240229 |

### Header Transformation

**Added Headers:**
- `Authorization: Bearer <oauth-token>`
- `anthropic-beta: oauth-2025-04-20`
- `anthropic-version: 2023-06-01`

**Removed Headers:**
- `User-Agent` (identifies client application)
- Custom headers not in allowlist

## Response Handling

### Streaming Responses

Server-Sent Events (SSE) are fully supported with immediate flushing for real-time streaming.

### Error Responses

Errors maintain Anthropic's format:
```json
{
  "type": "error",
  "error": {
    "type": "authentication_error",
    "message": "Authentication required. Please run: claude-gate auth login"
  }
}
```

## Client Configuration Examples

### Python (anthropic)
```python
from anthropic import Anthropic

client = Anthropic(
    base_url="http://localhost:5789/v1",
    api_key="dummy"  # OAuth handled by proxy
)
```

### Node.js (@anthropic-ai/sdk)
```javascript
import Anthropic from '@anthropic-ai/sdk';

const client = new Anthropic({
  baseURL: 'http://localhost:5789/v1',
  apiKey: 'dummy'  // OAuth handled by proxy
});
```

### cURL
```bash
curl http://localhost:5789/v1/messages \
  -H "Content-Type: application/json" \
  -d '{
    "model": "claude-3-5-sonnet-latest",
    "messages": [{"role": "user", "content": "Hello"}]
  }'
```

## Rate Limiting

Currently, rate limiting is enforced by Anthropic's API. Local rate limiting is planned for future releases.

## Health Check

```
GET /health
```

Returns 200 OK when the proxy is running and authenticated.

## Metrics (Planned)

```
GET /metrics
```

Prometheus-compatible metrics endpoint (future release).

## Security Considerations

1. The proxy runs locally and should not be exposed to the internet
2. OAuth tokens are never exposed to clients
3. All communication with Anthropic uses TLS
4. See [Security Policy](../SECURITY.md) for details

## Troubleshooting

### Common Issues

1. **401 Unauthorized**
   - Run `claude-gate auth login`
   - Check token expiration with `claude-gate auth status`

2. **Connection Refused**
   - Ensure proxy is running: `claude-gate start`
   - Check port 5789 is not in use

3. **Model Not Found**
   - Use valid model names or aliases
   - Check Anthropic API documentation

### Debug Mode

Set environment variable for verbose logging:
```bash
CLAUDE_GATE_DEBUG=true claude-gate start
```

## Version Compatibility

Claude Gate maintains compatibility with:
- Anthropic API version: 2023-06-01
- OAuth Beta: oauth-2025-04-20

Check your version:
```bash
claude-gate version
```

---

[← Reference](../README.md#reference) | [Documentation Home](../README.md) | [CLI Reference →](./cli.md)
// End of docs/reference/api.md

=====================

// File: docs/reference/cli.md

# CLI Reference

Complete reference for all Claude Gate command-line interface commands and options.

## Global Options

These options can be used with any command:

```bash
claude-gate [global options] command [command options] [arguments...]
```

| Option | Description | Default |
|--------|-------------|---------|
| `--help`, `-h` | Show help | - |
| `--version`, `-v` | Show version | - |
| `--config FILE` | Load configuration from FILE | `~/.claude-gate/config.yaml` |
| `--log-level LEVEL` | Set log level (DEBUG, INFO, WARNING, ERROR) | `INFO` |

## Commands

### `auth` - Authentication Management

Manage authentication with Claude Pro/Max accounts.

#### `auth login`

Authenticate with your Claude account:

```bash
claude-gate auth login [options]
```

**Options:**
- `--browser` - Force browser authentication (default: auto-detect)
- `--no-browser` - Use terminal-only authentication
- `--timeout DURATION` - Authentication timeout (default: `5m`)

**Example:**
```bash
claude-gate auth login --timeout 10m
```

#### `auth logout`

Remove stored authentication:

```bash
claude-gate auth logout
```

#### `auth status`

Check authentication status:

```bash
claude-gate auth status [options]
```

**Options:**
- `--json` - Output in JSON format
- `--verbose` - Show detailed token information

**Example:**
```bash
claude-gate auth status --json
```

#### `auth refresh`

Refresh authentication token:

```bash
claude-gate auth refresh
```

### `start` - Start Proxy Server

Start the Claude Gate proxy server:

```bash
claude-gate start [options]
```

**Options:**
| Option | Environment Variable | Default | Description |
|--------|---------------------|---------|-------------|
| `--host` | `CLAUDE_GATE_HOST` | `127.0.0.1` | Host to bind to |
| `--port` | `CLAUDE_GATE_PORT` | `5789` | Port to listen on |
| `--dashboard` | - | `false` | Enable interactive dashboard |
| `--daemon` | - | `false` | Run in background |
| `--proxy-auth-token` | `CLAUDE_GATE_PROXY_AUTH_TOKEN` | - | Require authentication |
| `--tls-cert` | - | - | TLS certificate file |
| `--tls-key` | - | - | TLS key file |

**Examples:**
```bash
# Start on default port
claude-gate start

# Start with dashboard
claude-gate start --dashboard

# Start on custom port with auth
claude-gate start --port 3000 --proxy-auth-token "secret-token"

# Start with TLS
claude-gate start --tls-cert cert.pem --tls-key key.pem
```

### `stop` - Stop Proxy Server

Stop the running Claude Gate proxy:

```bash
claude-gate stop [options]
```

**Options:**
- `--force` - Force stop without graceful shutdown
- `--timeout DURATION` - Shutdown timeout (default: `30s`)

**Example:**
```bash
claude-gate stop --timeout 10s
```

### `status` - Check Server Status

Check if Claude Gate is running:

```bash
claude-gate status [options]
```

**Options:**
- `--json` - Output in JSON format
- `--verbose` - Show detailed server information

**Output includes:**
- Running status
- PID
- Port number
- Uptime
- Request statistics

**Example:**
```bash
claude-gate status --json
```

### `logs` - View Server Logs

Display Claude Gate server logs:

```bash
claude-gate logs [options]
```

**Options:**
- `--follow`, `-f` - Follow log output
- `--tail N` - Show last N lines (default: `100`)
- `--since DURATION` - Show logs since duration ago
- `--level LEVEL` - Filter by log level

**Examples:**
```bash
# Follow logs in real-time
claude-gate logs -f

# Show last 50 error logs
claude-gate logs --tail 50 --level ERROR

# Show logs from last hour
claude-gate logs --since 1h
```

### `config` - Configuration Management

Manage Claude Gate configuration:

#### `config show`

Display current configuration:

```bash
claude-gate config show [options]
```

**Options:**
- `--json` - Output in JSON format
- `--show-defaults` - Include default values

#### `config validate`

Validate configuration file:

```bash
claude-gate config validate [FILE]
```

#### `config init`

Create initial configuration file:

```bash
claude-gate config init [options]
```

**Options:**
- `--force` - Overwrite existing configuration

### `version` - Show Version Information

Display Claude Gate version:

```bash
claude-gate version [options]
```

**Options:**
- `--json` - Output in JSON format
- `--verbose` - Show build information

**Example output:**
```
Claude Gate version 1.0.0
Built: 2024-01-20T10:00:00Z
Go version: go1.22.0
Platform: darwin/arm64
```

## Environment Variables

Claude Gate respects the following environment variables:

| Variable | Description | Default |
|----------|-------------|---------|
| `CLAUDE_GATE_HOST` | Default host for server | `127.0.0.1` |
| `CLAUDE_GATE_PORT` | Default port for server | `5789` |
| `CLAUDE_GATE_CONFIG` | Configuration file path | `~/.claude-gate/config.yaml` |
| `CLAUDE_GATE_LOG_LEVEL` | Default log level | `INFO` |
| `CLAUDE_GATE_LOG_FILE` | Log file path | - |
| `CLAUDE_GATE_PROXY_AUTH_TOKEN` | Proxy authentication token | - |
| `CLAUDE_GATE_DASHBOARD` | Enable dashboard by default | `false` |
| `CLAUDE_GATE_ALLOWED_ORIGINS` | CORS allowed origins | `*` |
| `NO_COLOR` | Disable colored output | - |

## Exit Codes

Claude Gate uses the following exit codes:

| Code | Description |
|------|-------------|
| 0 | Success |
| 1 | General error |
| 2 | Configuration error |
| 3 | Authentication error |
| 4 | Server already running |
| 5 | Server not running |
| 127 | Command not found |

## Examples

### Basic Usage

```bash
# Authenticate
claude-gate auth login

# Start server
claude-gate start

# Check status
claude-gate status

# View logs
claude-gate logs -f

# Stop server
claude-gate stop
```

### Production Setup

```bash
# Set up with authentication
export CLAUDE_GATE_PROXY_AUTH_TOKEN=$(openssl rand -hex 32)
export CLAUDE_GATE_LOG_LEVEL=INFO
export CLAUDE_GATE_LOG_FILE=/var/log/claude-gate.log

# Start with specific configuration
claude-gate start --host 127.0.0.1 --port 5789

# Monitor
claude-gate status --json | jq
```

### Development Setup

```bash
# Start with debug logging and dashboard
claude-gate start --log-level DEBUG --dashboard

# Follow logs in another terminal
claude-gate logs -f --level DEBUG
```

## Tips and Tricks

1. **Auto-completion**: Enable shell completion:
   ```bash
   # Bash
   claude-gate completion bash > /etc/bash_completion.d/claude-gate
   
   # Zsh
   claude-gate completion zsh > "${fpath[1]}/_claude-gate"
   ```

2. **Aliases**: Add useful aliases:
   ```bash
   alias cg='claude-gate'
   alias cgs='claude-gate start --dashboard'
   alias cgl='claude-gate logs -f'
   ```

3. **Configuration Profiles**: Use different configs:
   ```bash
   claude-gate --config ~/.claude-gate/dev.yaml start
   claude-gate --config ~/.claude-gate/prod.yaml start
   ```

---

[← Reference](../README.md#reference) | [Documentation Home](../README.md) | [API Reference →](./api.md)
// End of docs/reference/cli.md

=====================

// File: docs/reference/configuration.md

# Configuration Reference

Complete reference for all Claude Gate configuration options.

## Configuration Hierarchy

Claude Gate uses a hierarchical configuration system where settings can be specified at different levels, with higher-priority sources overriding lower ones:

1. **Command-line flags** (highest priority)
2. **Environment variables**
3. **Configuration file**
4. **Default values** (lowest priority)

## Configuration File

Claude Gate looks for configuration in the following locations:

- `~/.claude-gate/config.yaml` (default)
- Path specified by `--config` flag
- Path specified by `CLAUDE_GATE_CONFIG` environment variable

### Configuration File Format

```yaml
# ~/.claude-gate/config.yaml
host: 127.0.0.1
port: 5789
log_level: info
log_format: text
proxy_auth_token: your-secret-token
allowed_origins:
  - http://localhost:3000
  - https://myapp.com
dashboard:
  enabled: false
  refresh_interval: 1s
tls:
  cert: /path/to/cert.pem
  key: /path/to/key.pem
```

## All Configuration Options

### Server Configuration

| Option | CLI Flag | Environment Variable | Config Key | Default | Description |
|--------|----------|---------------------|------------|---------|-------------|
| Host | `--host` | `CLAUDE_GATE_HOST` | `host` | `127.0.0.1` | IP address to bind to |
| Port | `--port` | `CLAUDE_GATE_PORT` | `port` | `5789` | Port number for the server |
| Proxy Auth Token | `--proxy-auth-token` | `CLAUDE_GATE_PROXY_AUTH_TOKEN` | `proxy_auth_token` | (none) | Token for proxy authentication |

### Logging Configuration

| Option | CLI Flag | Environment Variable | Config Key | Default | Description |
|--------|----------|---------------------|------------|---------|-------------|
| Log Level | `--log-level` | `CLAUDE_GATE_LOG_LEVEL` | `log_level` | `info` | Logging level: debug, info, warning, error |
| Log File | `--log-file` | `CLAUDE_GATE_LOG_FILE` | `log_file` | (stdout) | Path to log file |
| Log Format | `--log-format` | `CLAUDE_GATE_LOG_FORMAT` | `log_format` | `text` | Log format: text, json |

### Security Configuration

| Option | CLI Flag | Environment Variable | Config Key | Default | Description |
|--------|----------|---------------------|------------|---------|-------------|
| Allowed Origins | `--allowed-origins` | `CLAUDE_GATE_ALLOWED_ORIGINS` | `allowed_origins` | `["*"]` | CORS allowed origins |
| TLS Certificate | `--tls-cert` | `CLAUDE_GATE_TLS_CERT` | `tls.cert` | (none) | Path to TLS certificate |
| TLS Key | `--tls-key` | `CLAUDE_GATE_TLS_KEY` | `tls.key` | (none) | Path to TLS private key |

### Dashboard Configuration

| Option | CLI Flag | Environment Variable | Config Key | Default | Description |
|--------|----------|---------------------|------------|---------|-------------|
| Dashboard Enabled | `--dashboard` | `CLAUDE_GATE_DASHBOARD` | `dashboard.enabled` | `false` | Enable interactive dashboard |
| Refresh Interval | `--dashboard-refresh` | `CLAUDE_GATE_DASHBOARD_REFRESH` | `dashboard.refresh_interval` | `1s` | Dashboard update frequency |

### Authentication Configuration

| Option | Environment Variable | Config Key | Default | Description |
|--------|---------------------|------------|---------|-------------|
| Token Storage Path | `CLAUDE_GATE_TOKEN_PATH` | `auth.token_path` | (platform-specific) | Where to store auth tokens |
| Token Encryption | `CLAUDE_GATE_TOKEN_ENCRYPT` | `auth.encrypt_tokens` | `true` | Encrypt stored tokens |

## Platform-Specific Defaults

### Token Storage Locations

- **macOS**: `~/Library/Application Support/claude-gate/`
- **Linux**: `~/.config/claude-gate/`
- **Windows**: `%APPDATA%\claude-gate\`

### Log File Locations (when specified)

- **macOS/Linux**: `/var/log/claude-gate.log` (requires permissions)
- **Windows**: `%LOCALAPPDATA%\claude-gate\logs\claude-gate.log`

## Environment Variable Format

### Simple Values

```bash
export CLAUDE_GATE_HOST=0.0.0.0
export CLAUDE_GATE_PORT=3000
export CLAUDE_GATE_LOG_LEVEL=debug
```

### List Values

For array configurations, use comma-separated values:

```bash
export CLAUDE_GATE_ALLOWED_ORIGINS="http://localhost:3000,https://myapp.com"
```

### Boolean Values

Use `true`, `false`, `1`, or `0`:

```bash
export CLAUDE_GATE_DASHBOARD=true
export CLAUDE_GATE_TOKEN_ENCRYPT=1
```

## Configuration Examples

### Development Configuration

```yaml
# ~/.claude-gate/config.dev.yaml
host: 127.0.0.1
port: 5789
log_level: debug
log_format: text
dashboard:
  enabled: true
  refresh_interval: 500ms
```

### Production Configuration

```yaml
# ~/.claude-gate/config.prod.yaml
host: 127.0.0.1
port: 5789
log_level: info
log_format: json
log_file: /var/log/claude-gate.log
proxy_auth_token: ${PROXY_AUTH_TOKEN}  # Can use env var substitution
allowed_origins:
  - https://app.example.com
  - https://www.example.com
tls:
  cert: /etc/claude-gate/cert.pem
  key: /etc/claude-gate/key.pem
```

### Docker Configuration

```yaml
# config.docker.yaml
host: 0.0.0.0  # Listen on all interfaces in container
port: 5789
log_level: info
log_format: json  # Structured logs for container logging
```

## Configuration Validation

Claude Gate validates configuration on startup:

1. **Type validation** - Ensures values are correct types
2. **Range validation** - Ports must be 1-65535
3. **File validation** - TLS cert/key files must exist if specified
4. **Permission validation** - Log file must be writable

To validate a configuration file without starting the server:

```bash
claude-gate config validate ~/.claude-gate/config.yaml
```

## Configuration Best Practices

1. **Security**
   - Never commit `proxy_auth_token` to version control
   - Use environment variables for sensitive values
   - Restrict file permissions on config files with secrets

2. **Performance**
   - Disable dashboard in production
   - Use appropriate log levels (info or warning for production)
   - Consider log rotation for file logging

3. **Maintainability**
   - Use separate config files for different environments
   - Document custom configuration in your project
   - Keep configuration minimal - rely on defaults where possible

4. **Monitoring**
   - Enable JSON logging for log aggregation systems
   - Include instance identifiers in multi-instance deployments
   - Monitor configuration changes

---

[← Reference](../README.md#reference) | [Documentation Home](../README.md) | [CLI Reference →](./cli.md)
// End of docs/reference/configuration.md

=====================

// File: docs/testing/test-guide.md

# Claude Gate Testing Guide

This guide explains how to thoroughly test the cross-platform builds and NPM distribution system.

## Quick Start

Run all tests:
```bash
make test-all
```

## Test Categories

### 1. Unit Tests

**Go Tests:**
```bash
make test
```

**NPM Package Tests:**
```bash
cd npm
node scripts/install.test.js
```

### 2. Build Tests

**Local Build:**
```bash
make build
./claude-gate version
```

**Cross-Platform Build:**
```bash
make snapshot
ls -la dist/
```

### 3. NPM Package Tests

**Local Package Test:**
```bash
make npm-test
```

This will:
- Build all platform binaries
- Create test NPM package
- Simulate installation
- Verify the package works

### 4. Integration Tests

**Comprehensive Test Suite:**
```bash
make test-all
```

This runs:
- Go unit tests
- GoReleaser build tests
- NPM package structure validation
- Platform detection tests
- Binary execution tests
- Error handling tests

### 5. Docker Tests

**Multi-Platform Docker Tests:**
```bash
make test-docker
```

Tests installation on:
- Linux x64
- Linux ARM64 (if supported)
- Different Node.js versions

### 6. Edge Case Tests

**Edge Cases and Error Scenarios:**
```bash
make test-edge
```

Tests:
- Missing binaries
- Permission errors
- Concurrent installations
- Signal handling
- Version mismatches

## Manual Testing

### Test NPM Installation Locally

1. **Create package:**
   ```bash
   cd npm
   npm pack
   ```

2. **Install globally:**
   ```bash
   npm install -g claude-gate-0.1.0.tgz
   ```

3. **Test commands:**
   ```bash
   claude-gate version
   claude-gate --help
   claude-gate auth status
   ```

4. **Uninstall:**
   ```bash
   npm uninstall -g claude-gate
   ```

### Test --ignore-scripts

```bash
npm install -g claude-gate-0.1.0.tgz --ignore-scripts
claude-gate version  # Should trigger fallback installation
```

### Test Platform Detection

```bash
cd npm
node -e "const {getPlatform} = require('./scripts/install.js'); console.log(getPlatform())"
```

## CI/CD Testing

### GitHub Actions

The project includes automated tests that run on:
- Every push to main/develop
- Every pull request

Test matrix includes:
- OS: Ubuntu, macOS, Windows
- Go: 1.22, 1.23
- Node.js: 18, 20, 22

### Local CI Testing

Test GitHub Actions locally using act:
```bash
brew install act
act -j test-go
```

## Platform-Specific Testing

### macOS
```bash
# Test on Intel Mac
GOARCH=amd64 make build

# Test on Apple Silicon
GOARCH=arm64 make build
```

### Linux
Use Docker for testing:
```bash
docker run --rm -it -v $(pwd):/app -w /app golang:1.22 bash
# Inside container:
make test
```

### Windows
Use Windows VM or:
```bash
GOOS=windows make build
# Test .exe in Windows environment
```

## Release Testing

### Pre-Release Checklist

1. **Version Consistency:**
   ```bash
   ./scripts/update-version.sh 0.1.0
   git diff  # Review changes
   ```

2. **Build Test:**
   ```bash
   make snapshot
   ```

3. **NPM Package Test:**
   ```bash
   make npm-test
   ```

4. **Tag and Release (Dry Run):**
   ```bash
   goreleaser release --snapshot --skip-publish --clean
   ```

## Debugging Failed Tests

### Verbose Output
```bash
# Go tests with verbose output
go test -v ./...

# NPM install with debug
DEBUG=* npm install -g claude-gate-0.1.0.tgz
```

### Check Logs
- GitHub Actions: Check workflow run logs
- Local: Check console output and error messages

### Common Issues

1. **GoReleaser not found:**
   ```bash
   brew install goreleaser
   ```

2. **Permission denied:**
   ```bash
   sudo npm install -g claude-gate
   # Or use nvm to avoid sudo
   ```

3. **Binary not found:**
   - Check if platform is supported
   - Verify dist/ directory has binaries
   - Check npm package structure

## Performance Testing

### Binary Size Check
```bash
make snapshot
find dist -name "claude-gate*" -exec ls -lh {} \;
```

Target: <15MB per platform

### Installation Speed
```bash
time npm install -g claude-gate
```

Target: <30 seconds on decent connection

## Security Testing

### Checksum Verification
```bash
cd dist
sha256sum -c checksums.txt
```

### Dependency Audit
```bash
cd npm
npm audit
```

## Reporting Issues

When reporting test failures, include:
1. OS and architecture: `uname -a`
2. Go version: `go version`
3. Node.js version: `node --version`
4. NPM version: `npm --version`
5. Complete error output
6. Steps to reproduce

---

[← Testing](../README.md#testing) | [Documentation Home](../README.md) | [Test Results →](./test-results/)
// End of docs/testing/test-guide.md

=====================

// File: docs/testing/test-results/2025-01-20.md

# Claude Gate - Test Results Summary

## Test Execution Date
2025-06-24

## Test Environment
- OS: macOS (darwin/arm64)
- Go: 1.24.4
- Node.js: v24.1.0
- npm: 11.3.0

## Test Results

### ✅ All Tests Passed!

#### Core Tests (31 passed, 0 failed, 4 skipped)

**Go Tests:**
- ✅ Unit tests for all packages
- ✅ Build tests
- ⏭️ GoReleaser snapshot (skipped - not installed)

**NPM Package Tests:**
- ✅ Package structure validation
- ✅ Platform detection
- ✅ Install/uninstall scripts
- ✅ Version consistency
- ✅ All platform packages valid

**GitHub Actions:**
- ✅ Workflow file exists
- ⏭️ YAML validation (skipped - PyYAML not installed)

**Other Tests:**
- ✅ Error handling
- ✅ Script permissions
- ⏭️ Binary execution (skipped - no binaries built)
- ⏭️ NPM local package test (skipped - no binaries built)

#### NPM Unit Tests (8 passed, 0 failed)
- ✅ Platform detection for all supported platforms
- ✅ Error handling for unsupported platforms
- ✅ Path validation

## How to Run Full Test Suite

1. **Install Prerequisites:**
   ```bash
   brew install goreleaser
   pip3 install pyyaml  # Optional, for YAML validation
   ```

2. **Run All Tests:**
   ```bash
   make test-all
   ```

3. **Individual Test Suites:**
   ```bash
   make test           # Go tests only
   make npm-test       # NPM package test
   make test-docker    # Docker tests
   make test-edge      # Edge case tests
   ```

## Known Limitations

1. **GoReleaser Tests:** Require GoReleaser installation
2. **Binary Tests:** Require built binaries (run `make snapshot` first)
3. **Docker Tests:** Require Docker to be installed and running
4. **Windows Tests:** Best run on actual Windows machine or VM

## Recommendations

1. Install GoReleaser to enable full build testing
2. Set up CI/CD to run tests automatically on all platforms
3. Add integration tests with actual Anthropic API (mock server)
4. Consider adding performance benchmarks

## Conclusion

The cross-platform build and NPM distribution implementation is working correctly. All critical tests pass, demonstrating:

- ✅ Correct package structure
- ✅ Platform detection works on all supported platforms
- ✅ Error handling is robust
- ✅ Version management is consistent
- ✅ Scripts have proper permissions
- ✅ GitHub Actions workflow is properly configured

The implementation is ready for real-world usage!
// End of docs/testing/test-results/2025-01-20.md

=====================

// File: go.mod

module github.com/ml0-1337/claude-gate

go 1.23.0

toolchain go1.24.4

require (
	github.com/99designs/keyring v1.2.2
	github.com/alecthomas/kong v1.11.0
	github.com/charmbracelet/bubbles v0.21.0
	github.com/charmbracelet/bubbletea v1.3.5
	github.com/charmbracelet/lipgloss v1.1.0
	github.com/mattn/go-isatty v0.0.20
	github.com/muesli/termenv v0.16.0
	github.com/stretchr/testify v1.10.0
)

require (
	github.com/99designs/go-keychain v0.0.0-20191008050251-8e49817e8af4 // indirect
	github.com/atotto/clipboard v0.1.4 // indirect
	github.com/aymanbagabas/go-osc52/v2 v2.0.1 // indirect
	github.com/charmbracelet/colorprofile v0.2.3-0.20250311203215-f60798e515dc // indirect
	github.com/charmbracelet/harmonica v0.2.0 // indirect
	github.com/charmbracelet/x/ansi v0.8.0 // indirect
	github.com/charmbracelet/x/cellbuf v0.0.13-0.20250311204145-2c3ea96c31dd // indirect
	github.com/charmbracelet/x/term v0.2.1 // indirect
	github.com/danieljoos/wincred v1.1.2 // indirect
	github.com/davecgh/go-spew v1.1.1 // indirect
	github.com/dvsekhvalnov/jose2go v1.5.0 // indirect
	github.com/erikgeiser/coninput v0.0.0-20211004153227-1c3628e74d0f // indirect
	github.com/godbus/dbus v0.0.0-20190726142602-4481cbc300e2 // indirect
	github.com/gsterjov/go-libsecret v0.0.0-20161001094733-a6f4afe4910c // indirect
	github.com/lucasb-eyer/go-colorful v1.2.0 // indirect
	github.com/mattn/go-localereader v0.0.1 // indirect
	github.com/mattn/go-runewidth v0.0.16 // indirect
	github.com/mtibben/percent v0.2.1 // indirect
	github.com/muesli/ansi v0.0.0-20230316100256-276c6243b2f6 // indirect
	github.com/muesli/cancelreader v0.2.2 // indirect
	github.com/pmezard/go-difflib v1.0.0 // indirect
	github.com/rivo/uniseg v0.4.7 // indirect
	github.com/xo/terminfo v0.0.0-20220910002029-abceb7e1c41e // indirect
	golang.org/x/sync v0.13.0 // indirect
	golang.org/x/sys v0.32.0 // indirect
	golang.org/x/term v0.3.0 // indirect
	golang.org/x/text v0.3.8 // indirect
	gopkg.in/yaml.v3 v3.0.1 // indirect
)

// End of go.mod

=====================

// File: go.sum

github.com/99designs/go-keychain v0.0.0-20191008050251-8e49817e8af4 h1:/vQbFIOMbk2FiG/kXiLl8BRyzTWDw7gX/Hz7Dd5eDMs=
github.com/99designs/go-keychain v0.0.0-20191008050251-8e49817e8af4/go.mod h1:hN7oaIRCjzsZ2dE+yG5k+rsdt3qcwykqK6HVGcKwsw4=
github.com/99designs/keyring v1.2.2 h1:pZd3neh/EmUzWONb35LxQfvuY7kiSXAq3HQd97+XBn0=
github.com/99designs/keyring v1.2.2/go.mod h1:wes/FrByc8j7lFOAGLGSNEg8f/PaI3cgTBqhFkHUrPk=
github.com/alecthomas/assert/v2 v2.11.0 h1:2Q9r3ki8+JYXvGsDyBXwH3LcJ+WK5D0gc5E8vS6K3D0=
github.com/alecthomas/assert/v2 v2.11.0/go.mod h1:Bze95FyfUr7x34QZrjL+XP+0qgp/zg8yS+TtBj1WA3k=
github.com/alecthomas/kong v1.11.0 h1:y++1gI7jf8O7G7l4LZo5ASFhrhJvzc+WgF/arranEmM=
github.com/alecthomas/kong v1.11.0/go.mod h1:p2vqieVMeTAnaC83txKtXe8FLke2X07aruPWXyMPQrU=
github.com/alecthomas/repr v0.4.0 h1:GhI2A8MACjfegCPVq9f1FLvIBS+DrQ2KQBFZP1iFzXc=
github.com/alecthomas/repr v0.4.0/go.mod h1:Fr0507jx4eOXV7AlPV6AVZLYrLIuIeSOWtW57eE/O/4=
github.com/atotto/clipboard v0.1.4 h1:EH0zSVneZPSuFR11BlR9YppQTVDbh5+16AmcJi4g1z4=
github.com/atotto/clipboard v0.1.4/go.mod h1:ZY9tmq7sm5xIbd9bOK4onWV4S6X0u6GY7Vn0Yu86PYI=
github.com/aymanbagabas/go-osc52/v2 v2.0.1 h1:HwpRHbFMcZLEVr42D4p7XBqjyuxQH5SMiErDT4WkJ2k=
github.com/aymanbagabas/go-osc52/v2 v2.0.1/go.mod h1:uYgXzlJ7ZpABp8OJ+exZzJJhRNQ2ASbcXHWsFqH8hp8=
github.com/charmbracelet/bubbles v0.21.0 h1:9TdC97SdRVg/1aaXNVWfFH3nnLAwOXr8Fn6u6mfQdFs=
github.com/charmbracelet/bubbles v0.21.0/go.mod h1:HF+v6QUR4HkEpz62dx7ym2xc71/KBHg+zKwJtMw+qtg=
github.com/charmbracelet/bubbletea v1.3.5 h1:JAMNLTbqMOhSwoELIr0qyP4VidFq72/6E9j7HHmRKQc=
github.com/charmbracelet/bubbletea v1.3.5/go.mod h1:TkCnmH+aBd4LrXhXcqrKiYwRs7qyQx5rBgH5fVY3v54=
github.com/charmbracelet/colorprofile v0.2.3-0.20250311203215-f60798e515dc h1:4pZI35227imm7yK2bGPcfpFEmuY1gc2YSTShr4iJBfs=
github.com/charmbracelet/colorprofile v0.2.3-0.20250311203215-f60798e515dc/go.mod h1:X4/0JoqgTIPSFcRA/P6INZzIuyqdFY5rm8tb41s9okk=
github.com/charmbracelet/harmonica v0.2.0 h1:8NxJWRWg/bzKqqEaaeFNipOu77YR5t8aSwG4pgaUBiQ=
github.com/charmbracelet/harmonica v0.2.0/go.mod h1:KSri/1RMQOZLbw7AHqgcBycp8pgJnQMYYT8QZRqZ1Ao=
github.com/charmbracelet/lipgloss v1.1.0 h1:vYXsiLHVkK7fp74RkV7b2kq9+zDLoEU4MZoFqR/noCY=
github.com/charmbracelet/lipgloss v1.1.0/go.mod h1:/6Q8FR2o+kj8rz4Dq0zQc3vYf7X+B0binUUBwA0aL30=
github.com/charmbracelet/x/ansi v0.8.0 h1:9GTq3xq9caJW8ZrBTe0LIe2fvfLR/bYXKTx2llXn7xE=
github.com/charmbracelet/x/ansi v0.8.0/go.mod h1:wdYl/ONOLHLIVmQaxbIYEC/cRKOQyjTkowiI4blgS9Q=
github.com/charmbracelet/x/cellbuf v0.0.13-0.20250311204145-2c3ea96c31dd h1:vy0GVL4jeHEwG5YOXDmi86oYw2yuYUGqz6a8sLwg0X8=
github.com/charmbracelet/x/cellbuf v0.0.13-0.20250311204145-2c3ea96c31dd/go.mod h1:xe0nKWGd3eJgtqZRaN9RjMtK7xUYchjzPr7q6kcvCCs=
github.com/charmbracelet/x/term v0.2.1 h1:AQeHeLZ1OqSXhrAWpYUtZyX1T3zVxfpZuEQMIQaGIAQ=
github.com/charmbracelet/x/term v0.2.1/go.mod h1:oQ4enTYFV7QN4m0i9mzHrViD7TQKvNEEkHUMCmsxdUg=
github.com/danieljoos/wincred v1.1.2 h1:QLdCxFs1/Yl4zduvBdcHB8goaYk9RARS2SgLLRuAyr0=
github.com/danieljoos/wincred v1.1.2/go.mod h1:GijpziifJoIBfYh+S7BbkdUTU4LfM+QnGqR5Vl2tAx0=
github.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=
github.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/dvsekhvalnov/jose2go v1.5.0 h1:3j8ya4Z4kMCwT5nXIKFSV84YS+HdqSSO0VsTQxaLAeM=
github.com/dvsekhvalnov/jose2go v1.5.0/go.mod h1:QsHjhyTlD/lAVqn/NSbVZmSCGeDehTB/mPZadG+mhXU=
github.com/erikgeiser/coninput v0.0.0-20211004153227-1c3628e74d0f h1:Y/CXytFA4m6baUTXGLOoWe4PQhGxaX0KpnayAqC48p4=
github.com/erikgeiser/coninput v0.0.0-20211004153227-1c3628e74d0f/go.mod h1:vw97MGsxSvLiUE2X8qFplwetxpGLQrlU1Q9AUEIzCaM=
github.com/godbus/dbus v0.0.0-20190726142602-4481cbc300e2 h1:ZpnhV/YsD2/4cESfV5+Hoeu/iUR3ruzNvZ+yQfO03a0=
github.com/godbus/dbus v0.0.0-20190726142602-4481cbc300e2/go.mod h1:bBOAhwG1umN6/6ZUMtDFBMQR8jRg9O75tm9K00oMsK4=
github.com/gsterjov/go-libsecret v0.0.0-20161001094733-a6f4afe4910c h1:6rhixN/i8ZofjG1Y75iExal34USq5p+wiN1tpie8IrU=
github.com/gsterjov/go-libsecret v0.0.0-20161001094733-a6f4afe4910c/go.mod h1:NMPJylDgVpX0MLRlPy15sqSwOFv/U1GZ2m21JhFfek0=
github.com/hexops/gotextdiff v1.0.3 h1:gitA9+qJrrTCsiCl7+kh75nPqQt1cx4ZkudSTLoUqJM=
github.com/hexops/gotextdiff v1.0.3/go.mod h1:pSWU5MAI3yDq+fZBTazCSJysOMbxWL1BSow5/V2vxeg=
github.com/kr/pty v1.1.1/go.mod h1:pFQYn66WHrOpPYNljwOMqo10TkYh1fy3cYio2l3bCsQ=
github.com/kr/text v0.1.0 h1:45sCR5RtlFHMR4UwH9sdQ5TC8v0qDQCHnXt+kaKSTVE=
github.com/kr/text v0.1.0/go.mod h1:4Jbv+DJW3UT/LiOwJeYQe1efqtUx/iVham/4vfdArNI=
github.com/lucasb-eyer/go-colorful v1.2.0 h1:1nnpGOrhyZZuNyfu1QjKiUICQ74+3FNCN69Aj6K7nkY=
github.com/lucasb-eyer/go-colorful v1.2.0/go.mod h1:R4dSotOR9KMtayYi1e77YzuveK+i7ruzyGqttikkLy0=
github.com/mattn/go-isatty v0.0.20 h1:xfD0iDuEKnDkl03q4limB+vH+GxLEtL/jb4xVJSWWEY=
github.com/mattn/go-isatty v0.0.20/go.mod h1:W+V8PltTTMOvKvAeJH7IuucS94S2C6jfK/D7dTCTo3Y=
github.com/mattn/go-localereader v0.0.1 h1:ygSAOl7ZXTx4RdPYinUpg6W99U8jWvWi9Ye2JC/oIi4=
github.com/mattn/go-localereader v0.0.1/go.mod h1:8fBrzywKY7BI3czFoHkuzRoWE9C+EiG4R1k4Cjx5p88=
github.com/mattn/go-runewidth v0.0.16 h1:E5ScNMtiwvlvB5paMFdw9p4kSQzbXFikJ5SQO6TULQc=
github.com/mattn/go-runewidth v0.0.16/go.mod h1:Jdepj2loyihRzMpdS35Xk/zdY8IAYHsh153qUoGf23w=
github.com/mtibben/percent v0.2.1 h1:5gssi8Nqo8QU/r2pynCm+hBQHpkB/uNK7BJCFogWdzs=
github.com/mtibben/percent v0.2.1/go.mod h1:KG9uO+SZkUp+VkRHsCdYQV3XSZrrSpR3O9ibNBTZrns=
github.com/muesli/ansi v0.0.0-20230316100256-276c6243b2f6 h1:ZK8zHtRHOkbHy6Mmr5D264iyp3TiX5OmNcI5cIARiQI=
github.com/muesli/ansi v0.0.0-20230316100256-276c6243b2f6/go.mod h1:CJlz5H+gyd6CUWT45Oy4q24RdLyn7Md9Vj2/ldJBSIo=
github.com/muesli/cancelreader v0.2.2 h1:3I4Kt4BQjOR54NavqnDogx/MIoWBFa0StPA8ELUXHmA=
github.com/muesli/cancelreader v0.2.2/go.mod h1:3XuTXfFS2VjM+HTLZY9Ak0l6eUKfijIfMUZ4EgX0QYo=
github.com/muesli/termenv v0.16.0 h1:S5AlUN9dENB57rsbnkPyfdGuWIlkmzJjbFf0Tf5FWUc=
github.com/muesli/termenv v0.16.0/go.mod h1:ZRfOIKPFDYQoDFF4Olj7/QJbW60Ol/kL1pU3VfY/Cnk=
github.com/niemeyer/pretty v0.0.0-20200227124842-a10e7caefd8e h1:fD57ERR4JtEqsWbfPhv4DMiApHyliiK5xCTNVSPiaAs=
github.com/niemeyer/pretty v0.0.0-20200227124842-a10e7caefd8e/go.mod h1:zD1mROLANZcx1PVRCS0qkT7pwLkGfwJo4zjcN/Tysno=
github.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=
github.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=
github.com/rivo/uniseg v0.2.0/go.mod h1:J6wj4VEh+S6ZtnVlnTBMWIodfgj8LQOQFoIToxlJtxc=
github.com/rivo/uniseg v0.4.7 h1:WUdvkW8uEhrYfLC4ZzdpI2ztxP1I582+49Oc5Mq64VQ=
github.com/rivo/uniseg v0.4.7/go.mod h1:FN3SvrM+Zdj16jyLfmOkMNblXMcoc8DfTHruCPUcx88=
github.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=
github.com/stretchr/objx v0.5.2 h1:xuMeJ0Sdp5ZMRXx/aWO6RZxdr3beISkG5/G/aIRr3pY=
github.com/stretchr/objx v0.5.2/go.mod h1:FRsXN1f5AsAjCGJKqEizvkpNtU+EGNCLh3NxZ/8L+MA=
github.com/stretchr/testify v1.7.0/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=
github.com/stretchr/testify v1.10.0 h1:Xv5erBjTwe/5IxqUQTdXv5kgmIvbHo3QQyRwhJsOfJA=
github.com/stretchr/testify v1.10.0/go.mod h1:r2ic/lqez/lEtzL7wO/rwa5dbSLXVDPFyf8C91i36aY=
github.com/xo/terminfo v0.0.0-20220910002029-abceb7e1c41e h1:JVG44RsyaB9T2KIHavMF/ppJZNG9ZpyihvCd0w101no=
github.com/xo/terminfo v0.0.0-20220910002029-abceb7e1c41e/go.mod h1:RbqR21r5mrJuqunuUZ/Dhy/avygyECGrLceyNeo4LiM=
golang.org/x/exp v0.0.0-20220909182711-5c715a9e8561 h1:MDc5xs78ZrZr3HMQugiXOAkSZtfTpbJLDr/lwfgO53E=
golang.org/x/exp v0.0.0-20220909182711-5c715a9e8561/go.mod h1:cyybsKvd6eL0RnXn6p/Grxp8F5bW7iYuBgsNCOHpMYE=
golang.org/x/sync v0.13.0 h1:AauUjRAJ9OSnvULf/ARrrVywoJDy0YS2AwQ98I37610=
golang.org/x/sync v0.13.0/go.mod h1:1dzgHSNfp02xaA81J2MS99Qcpr2w7fw1gpm99rleRqA=
golang.org/x/sys v0.0.0-20210809222454-d867a43fc93e/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.0.0-20210819135213-f52c844e1c1c/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.6.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.32.0 h1:s77OFDvIQeibCmezSnk/q6iAfkdiQaJi4VzroCFrN20=
golang.org/x/sys v0.32.0/go.mod h1:BJP2sWEmIv4KK5OTEluFJCKSidICx8ciO85XgH3Ak8k=
golang.org/x/term v0.3.0 h1:qoo4akIqOcDME5bhc/NgxUdovd6BSS2uMsVjB56q1xI=
golang.org/x/term v0.3.0/go.mod h1:q750SLmJuPmVoN1blW3UFBPREJfb1KmY3vwxfr+nFDA=
golang.org/x/text v0.3.8 h1:nAL+RVCQ9uMn3vJZbV+MRnydTJFPf8qqY42YiA6MrqY=
golang.org/x/text v0.3.8/go.mod h1:E6s5w1FMmriuDzIBO73fBruAKo1PCIq6d2Q6DHfQ8WQ=
gopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
gopkg.in/check.v1 v1.0.0-20200902074654-038fdea0a05b h1:QRR6H1YWRnHb4Y/HeNFCTJLFVxaq6wH4YuVdsUOr75U=
gopkg.in/check.v1 v1.0.0-20200902074654-038fdea0a05b/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
gopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=
gopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=
gopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=

// End of go.sum

=====================

// File: internal/auth/client.go

package auth

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"strings"
	"sync"
	"time"
)

// OAuthTokenProvider implements TokenProvider interface for the proxy
type OAuthTokenProvider struct {
	client      *OAuthClient
	storage     StorageBackend
	cachedToken *TokenInfo
	cacheMutex  sync.RWMutex
}

// NewOAuthTokenProvider creates a new OAuth token provider
func NewOAuthTokenProvider(storage StorageBackend) *OAuthTokenProvider {
	return &OAuthTokenProvider{
		client:  NewOAuthClient(),
		storage: storage,
	}
}

// GetAccessToken returns a valid access token, refreshing if necessary
func (p *OAuthTokenProvider) GetAccessToken() (string, error) {
	// First, check if we have a valid cached token
	p.cacheMutex.RLock()
	if p.cachedToken != nil && p.cachedToken.Type == "oauth" && !p.cachedToken.NeedsRefresh() {
		token := p.cachedToken.AccessToken
		p.cacheMutex.RUnlock()
		return token, nil
	}
	p.cacheMutex.RUnlock()
	
	// Need to fetch or refresh token - use write lock
	p.cacheMutex.Lock()
	defer p.cacheMutex.Unlock()
	
	// Double-check after acquiring write lock (another goroutine might have refreshed)
	if p.cachedToken != nil && p.cachedToken.Type == "oauth" && !p.cachedToken.NeedsRefresh() {
		return p.cachedToken.AccessToken, nil
	}
	
	// Fetch token from storage
	token, err := p.storage.Get("anthropic")
	if err != nil {
		return "", fmt.Errorf("failed to get token from storage: %w", err)
	}
	
	if token == nil || token.Type != "oauth" {
		return "", fmt.Errorf("no OAuth token found - please authenticate first")
	}
	
	// Check if token needs refresh
	if token.NeedsRefresh() {
		// Refresh the token
		newToken, err := p.client.RefreshToken(token.RefreshToken)
		if err != nil {
			return "", fmt.Errorf("failed to refresh token: %w", err)
		}
		
		// Update storage
		if err := p.storage.Set("anthropic", newToken); err != nil {
			return "", fmt.Errorf("failed to save refreshed token: %w", err)
		}
		
		// Update cache
		p.cachedToken = newToken
		return newToken.AccessToken, nil
	}
	
	// Update cache with the token from storage
	p.cachedToken = token
	return token.AccessToken, nil
}

// ExchangeCode exchanges an authorization code for tokens
func (c *OAuthClient) ExchangeCode(code, verifier string) (*TokenInfo, error) {
	// Parse code and state
	parsedCode, parsedState := c.parseCodeAndState(code)
	
	// Build request body
	reqBody := map[string]interface{}{
		"code":          parsedCode,
		"grant_type":    "authorization_code",
		"client_id":     c.ClientID,
		"redirect_uri":  c.RedirectURI,
		"code_verifier": verifier,
	}
	
	// Include state if present
	if parsedState != "" {
		reqBody["state"] = parsedState
	}
	
	// Make request
	return c.makeTokenRequest(reqBody)
}

// RefreshToken refreshes an access token using a refresh token
func (c *OAuthClient) RefreshToken(refreshToken string) (*TokenInfo, error) {
	reqBody := map[string]interface{}{
		"grant_type":    "refresh_token",
		"refresh_token": refreshToken,
		"client_id":     c.ClientID,
	}
	
	return c.makeTokenRequest(reqBody)
}

// makeTokenRequest makes a token request to the OAuth server
func (c *OAuthClient) makeTokenRequest(body map[string]interface{}) (*TokenInfo, error) {
	jsonBody, err := json.Marshal(body)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal request body: %w", err)
	}
	
	req, err := http.NewRequestWithContext(context.Background(), "POST", c.TokenURL, strings.NewReader(string(jsonBody)))
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}
	
	req.Header.Set("Content-Type", "application/json")
	
	client := &http.Client{Timeout: 30 * time.Second}
	resp, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("failed to make token request: %w", err)
	}
	defer resp.Body.Close()
	
	if resp.StatusCode != http.StatusOK {
		var errorResp map[string]interface{}
		if err := json.NewDecoder(resp.Body).Decode(&errorResp); err == nil {
			return nil, fmt.Errorf("token request failed: %v", errorResp)
		}
		return nil, fmt.Errorf("token request failed with status %d", resp.StatusCode)
	}
	
	var tokenResp struct {
		AccessToken  string `json:"access_token"`
		RefreshToken string `json:"refresh_token"`
		ExpiresIn    int    `json:"expires_in"`
		TokenType    string `json:"token_type"`
	}
	
	if err := json.NewDecoder(resp.Body).Decode(&tokenResp); err != nil {
		return nil, fmt.Errorf("failed to decode token response: %w", err)
	}
	
	return &TokenInfo{
		Type:         "oauth",
		AccessToken:  tokenResp.AccessToken,
		RefreshToken: tokenResp.RefreshToken,
		ExpiresAt:    time.Now().Unix() + int64(tokenResp.ExpiresIn),
	}, nil
}
// End of internal/auth/client.go

=====================

// File: internal/auth/client_test.go

package auth

import (
	"encoding/json"
	"net/http"
	"net/http/httptest"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestOAuthTokenExchange(t *testing.T) {
	t.Run("successful token exchange", func(t *testing.T) {
		// Mock OAuth server
		server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			assert.Equal(t, "POST", r.Method)
			assert.Equal(t, "application/json", r.Header.Get("Content-Type"))
			
			var body map[string]interface{}
			err := json.NewDecoder(r.Body).Decode(&body)
			require.NoError(t, err)
			
			// Verify request body
			assert.Equal(t, "authorization_code", body["grant_type"])
			assert.Equal(t, "test-code", body["code"])
			assert.Equal(t, "test-verifier", body["code_verifier"])
			
			// Send response
			resp := map[string]interface{}{
				"access_token":  "test-access-token",
				"refresh_token": "test-refresh-token",
				"expires_in":    3600,
				"token_type":    "Bearer",
			}
			w.Header().Set("Content-Type", "application/json")
			json.NewEncoder(w).Encode(resp)
		}))
		defer server.Close()
		
		client := NewOAuthClient()
		client.TokenURL = server.URL
		
		token, err := client.ExchangeCode("test-code", "test-verifier")
		require.NoError(t, err)
		assert.Equal(t, "oauth", token.Type)
		assert.Equal(t, "test-access-token", token.AccessToken)
		assert.Equal(t, "test-refresh-token", token.RefreshToken)
		assert.Greater(t, token.ExpiresAt, time.Now().Unix())
	})
	
	t.Run("handles code with state", func(t *testing.T) {
		server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			var body map[string]interface{}
			json.NewDecoder(r.Body).Decode(&body)
			
			assert.Equal(t, "test-code", body["code"])
			assert.Equal(t, "test-state", body["state"])
			
			resp := map[string]interface{}{
				"access_token":  "test-access-token",
				"refresh_token": "test-refresh-token",
				"expires_in":    3600,
				"token_type":    "Bearer",
			}
			w.Header().Set("Content-Type", "application/json")
			json.NewEncoder(w).Encode(resp)
		}))
		defer server.Close()
		
		client := NewOAuthClient()
		client.TokenURL = server.URL
		
		token, err := client.ExchangeCode("test-code#test-state", "test-verifier")
		require.NoError(t, err)
		assert.NotNil(t, token)
	})
	
	t.Run("handles token exchange error", func(t *testing.T) {
		server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			w.Header().Set("Content-Type", "application/json")
			w.WriteHeader(http.StatusBadRequest)
			json.NewEncoder(w).Encode(map[string]interface{}{
				"error":             "invalid_grant",
				"error_description": "Invalid authorization code",
			})
		}))
		defer server.Close()
		
		client := NewOAuthClient()
		client.TokenURL = server.URL
		
		token, err := client.ExchangeCode("bad-code", "test-verifier")
		assert.Error(t, err)
		assert.Nil(t, token)
		assert.Contains(t, err.Error(), "token request failed")
	})
}

func TestOAuthTokenRefresh(t *testing.T) {
	t.Run("successful token refresh", func(t *testing.T) {
		server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			var body map[string]interface{}
			err := json.NewDecoder(r.Body).Decode(&body)
			require.NoError(t, err)
			
			assert.Equal(t, "refresh_token", body["grant_type"])
			assert.Equal(t, "old-refresh-token", body["refresh_token"])
			
			resp := map[string]interface{}{
				"access_token":  "new-access-token",
				"refresh_token": "new-refresh-token",
				"expires_in":    3600,
				"token_type":    "Bearer",
			}
			w.Header().Set("Content-Type", "application/json")
			json.NewEncoder(w).Encode(resp)
		}))
		defer server.Close()
		
		client := NewOAuthClient()
		client.TokenURL = server.URL
		
		token, err := client.RefreshToken("old-refresh-token")
		require.NoError(t, err)
		assert.Equal(t, "new-access-token", token.AccessToken)
		assert.Equal(t, "new-refresh-token", token.RefreshToken)
	})
}

func TestOAuthTokenProvider(t *testing.T) {
	t.Run("returns valid token", func(t *testing.T) {
		tempDir := t.TempDir()
		storage := NewFileStorage(tempDir + "/auth.json")
		
		// Store a valid token
		validToken := &TokenInfo{
			Type:         "oauth",
			AccessToken:  "valid-token",
			RefreshToken: "refresh-token",
			ExpiresAt:    time.Now().Add(time.Hour).Unix(),
		}
		err := storage.Set("anthropic", validToken)
		require.NoError(t, err)
		
		provider := NewOAuthTokenProvider(storage)
		token, err := provider.GetAccessToken()
		require.NoError(t, err)
		assert.Equal(t, "valid-token", token)
	})
	
	t.Run("refreshes expired token", func(t *testing.T) {
		// Mock OAuth server for refresh
		server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			resp := map[string]interface{}{
				"access_token":  "refreshed-token",
				"refresh_token": "new-refresh-token",
				"expires_in":    3600,
				"token_type":    "Bearer",
			}
			w.Header().Set("Content-Type", "application/json")
			json.NewEncoder(w).Encode(resp)
		}))
		defer server.Close()
		
		tempDir := t.TempDir()
		storage := NewFileStorage(tempDir + "/auth.json")
		
		// Store an expired token
		expiredToken := &TokenInfo{
			Type:         "oauth",
			AccessToken:  "expired-token",
			RefreshToken: "refresh-token",
			ExpiresAt:    time.Now().Add(-time.Hour).Unix(), // Expired
		}
		err := storage.Set("anthropic", expiredToken)
		require.NoError(t, err)
		
		provider := NewOAuthTokenProvider(storage)
		provider.client.TokenURL = server.URL
		
		token, err := provider.GetAccessToken()
		require.NoError(t, err)
		assert.Equal(t, "refreshed-token", token)
		
		// Verify token was saved
		savedToken, err := storage.Get("anthropic")
		require.NoError(t, err)
		assert.Equal(t, "refreshed-token", savedToken.AccessToken)
	})
	
	t.Run("returns error when no token", func(t *testing.T) {
		tempDir := t.TempDir()
		storage := NewFileStorage(tempDir + "/auth.json")
		
		provider := NewOAuthTokenProvider(storage)
		token, err := provider.GetAccessToken()
		assert.Error(t, err)
		assert.Empty(t, token)
		assert.Contains(t, err.Error(), "no OAuth token found")
	})
	
	t.Run("caches token to avoid repeated storage access", func(t *testing.T) {
		tempDir := t.TempDir()
		storage := NewFileStorage(tempDir + "/auth.json")
		
		// Store a valid token
		validToken := &TokenInfo{
			Type:         "oauth",
			AccessToken:  "cached-token",
			RefreshToken: "refresh-token",
			ExpiresAt:    time.Now().Add(time.Hour).Unix(),
		}
		err := storage.Set("anthropic", validToken)
		require.NoError(t, err)
		
		// Create a mock storage wrapper to count accesses
		mockStorage := &mockStorageCounter{
			StorageBackend: storage,
			getCalls:       0,
		}
		
		provider := NewOAuthTokenProvider(mockStorage)
		
		// First call should access storage
		token1, err := provider.GetAccessToken()
		require.NoError(t, err)
		assert.Equal(t, "cached-token", token1)
		assert.Equal(t, 1, mockStorage.getCalls)
		
		// Second call should use cache
		token2, err := provider.GetAccessToken()
		require.NoError(t, err)
		assert.Equal(t, "cached-token", token2)
		assert.Equal(t, 1, mockStorage.getCalls) // No additional storage access
		
		// Multiple calls should still use cache
		for i := 0; i < 10; i++ {
			token, err := provider.GetAccessToken()
			require.NoError(t, err)
			assert.Equal(t, "cached-token", token)
		}
		assert.Equal(t, 1, mockStorage.getCalls) // Still only one storage access
	})
	
	t.Run("refreshes cache when token needs refresh", func(t *testing.T) {
		// Mock OAuth server for refresh
		server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			resp := map[string]interface{}{
				"access_token":  "refreshed-cached-token",
				"refresh_token": "new-refresh-token",
				"expires_in":    3600,
				"token_type":    "Bearer",
			}
			w.Header().Set("Content-Type", "application/json")
			json.NewEncoder(w).Encode(resp)
		}))
		defer server.Close()
		
		tempDir := t.TempDir()
		storage := NewFileStorage(tempDir + "/auth.json")
		
		// Store a token that needs refresh (expires in 4 minutes)
		needsRefreshToken := &TokenInfo{
			Type:         "oauth",
			AccessToken:  "needs-refresh",
			RefreshToken: "refresh-token",
			ExpiresAt:    time.Now().Add(4 * time.Minute).Unix(),
		}
		err := storage.Set("anthropic", needsRefreshToken)
		require.NoError(t, err)
		
		provider := NewOAuthTokenProvider(storage)
		provider.client.TokenURL = server.URL
		
		// First call should trigger refresh and cache new token
		token1, err := provider.GetAccessToken()
		require.NoError(t, err)
		assert.Equal(t, "refreshed-cached-token", token1)
		
		// Second call should use cached refreshed token
		token2, err := provider.GetAccessToken()
		require.NoError(t, err)
		assert.Equal(t, "refreshed-cached-token", token2)
	})
	
	t.Run("concurrent access is thread-safe", func(t *testing.T) {
		tempDir := t.TempDir()
		storage := NewFileStorage(tempDir + "/auth.json")
		
		// Store a valid token
		validToken := &TokenInfo{
			Type:         "oauth",
			AccessToken:  "concurrent-token",
			RefreshToken: "refresh-token",
			ExpiresAt:    time.Now().Add(time.Hour).Unix(),
		}
		err := storage.Set("anthropic", validToken)
		require.NoError(t, err)
		
		provider := NewOAuthTokenProvider(storage)
		
		// Run concurrent GetAccessToken calls
		done := make(chan bool)
		errors := make(chan error, 100)
		tokens := make(chan string, 100)
		
		for i := 0; i < 100; i++ {
			go func() {
				token, err := provider.GetAccessToken()
				if err != nil {
					errors <- err
				} else {
					tokens <- token
				}
				done <- true
			}()
		}
		
		// Wait for all goroutines
		for i := 0; i < 100; i++ {
			<-done
		}
		close(errors)
		close(tokens)
		
		// Check no errors occurred
		for err := range errors {
			t.Errorf("Concurrent access error: %v", err)
		}
		
		// Check all tokens are correct
		count := 0
		for token := range tokens {
			assert.Equal(t, "concurrent-token", token)
			count++
		}
		assert.Equal(t, 100, count)
	})
}

// mockStorageCounter wraps a StorageBackend to count Get calls
type mockStorageCounter struct {
	StorageBackend
	getCalls int
}

func (m *mockStorageCounter) Get(provider string) (*TokenInfo, error) {
	m.getCalls++
	return m.StorageBackend.Get(provider)
}
// End of internal/auth/client_test.go

=====================

// File: internal/auth/file_storage.go

package auth

import (
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"sync"
	"time"
)

// TokenInfo represents stored authentication information
type TokenInfo struct {
	Type         string `json:"type"`          // "oauth" or "api"
	RefreshToken string `json:"refresh,omitempty"`
	AccessToken  string `json:"access,omitempty"`
	ExpiresAt    int64  `json:"expires,omitempty"`
	APIKey       string `json:"key,omitempty"`
}

// IsExpired checks if the token is expired
func (t *TokenInfo) IsExpired() bool {
	if t.Type != "oauth" || t.ExpiresAt == 0 {
		return false
	}
	return time.Now().Unix() >= t.ExpiresAt
}

// NeedsRefresh checks if the token needs refresh (5 minutes before expiry)
func (t *TokenInfo) NeedsRefresh() bool {
	if t.Type != "oauth" || t.ExpiresAt == 0 {
		return false
	}
	return time.Now().Unix() >= (t.ExpiresAt - 300) // 5 minutes buffer
}

// FileStorage implements StorageBackend using JSON file storage
type FileStorage struct {
	path    string
	mu      sync.RWMutex
	metrics StorageMetrics
}

// NewFileStorage creates a new file-based storage backend
func NewFileStorage(path string) *FileStorage {
	return &FileStorage{
		path: path,
		metrics: StorageMetrics{
			Operations: make(map[string]int64),
			Errors:     make(map[string]int64),
			Latencies:  make(map[string]time.Duration),
		},
	}
}

// Get retrieves token information for a provider
func (s *FileStorage) Get(provider string) (*TokenInfo, error) {
	s.mu.RLock()
	defer s.mu.RUnlock()
	
	start := time.Now()
	s.recordOperation("get")
	
	data, err := s.loadData()
	if err != nil {
		s.recordError("get", err)
		return nil, err
	}
	
	if tokenData, exists := data[provider]; exists {
		var token TokenInfo
		// Re-marshal and unmarshal to convert map to struct
		jsonData, err := json.Marshal(tokenData)
		if err != nil {
			s.recordError("get_marshal", err)
			return nil, fmt.Errorf("failed to marshal token data: %w", err)
		}
		if err := json.Unmarshal(jsonData, &token); err != nil {
			s.recordError("get_unmarshal", err)
			return nil, fmt.Errorf("failed to unmarshal token data: %w", err)
		}
		s.recordLatency("get", time.Since(start))
		return &token, nil
	}
	
	s.recordLatency("get", time.Since(start))
	return nil, nil
}

// Set stores token information for a provider
func (s *FileStorage) Set(provider string, token *TokenInfo) error {
	s.mu.Lock()
	defer s.mu.Unlock()
	
	start := time.Now()
	s.recordOperation("set")
	
	// Ensure directory exists
	dir := filepath.Dir(s.path)
	if err := os.MkdirAll(dir, 0700); err != nil {
		s.recordError("set_mkdir", err)
		return fmt.Errorf("failed to create directory: %w", err)
	}
	
	data, err := s.loadData()
	if err != nil {
		s.recordError("set_load", err)
		return err
	}
	
	data[provider] = token
	
	// Write data to file
	jsonData, err := json.MarshalIndent(data, "", "  ")
	if err != nil {
		s.recordError("set_marshal", err)
		return fmt.Errorf("failed to marshal data: %w", err)
	}
	
	if err := os.WriteFile(s.path, jsonData, 0600); err != nil {
		s.recordError("set_write", err)
		return fmt.Errorf("failed to write file: %w", err)
	}
	
	s.recordLatency("set", time.Since(start))
	return nil
}

// Remove deletes token information for a provider
func (s *FileStorage) Remove(provider string) error {
	s.mu.Lock()
	defer s.mu.Unlock()
	
	start := time.Now()
	s.recordOperation("remove")
	
	data, err := s.loadData()
	if err != nil {
		s.recordError("remove_load", err)
		return err
	}
	
	delete(data, provider)
	
	if len(data) == 0 {
		// Remove file if no data left
		err := os.Remove(s.path)
		if err != nil && !os.IsNotExist(err) {
			s.recordError("remove_file", err)
			return err
		}
		s.recordLatency("remove", time.Since(start))
		return nil
	}
	
	// Write updated data
	jsonData, err := json.MarshalIndent(data, "", "  ")
	if err != nil {
		s.recordError("remove_marshal", err)
		return fmt.Errorf("failed to marshal data: %w", err)
	}
	
	if err := os.WriteFile(s.path, jsonData, 0600); err != nil {
		s.recordError("remove_write", err)
		return fmt.Errorf("failed to write file: %w", err)
	}
	
	s.recordLatency("remove", time.Since(start))
	return nil
}

// List returns all stored provider names
func (s *FileStorage) List() ([]string, error) {
	s.mu.RLock()
	defer s.mu.RUnlock()
	
	start := time.Now()
	s.recordOperation("list")
	
	data, err := s.loadData()
	if err != nil {
		s.recordError("list", err)
		return nil, err
	}
	
	providers := make([]string, 0, len(data))
	for provider := range data {
		providers = append(providers, provider)
	}
	
	s.recordLatency("list", time.Since(start))
	return providers, nil
}

// IsAvailable checks if the backend is available on this system
func (s *FileStorage) IsAvailable() bool {
	// File storage is always available
	return true
}

// RequiresUnlock checks if the backend needs to be unlocked
func (s *FileStorage) RequiresUnlock() bool {
	// File storage doesn't require unlock
	return false
}

// Unlock attempts to unlock the backend
func (s *FileStorage) Unlock() error {
	// No-op for file storage
	return nil
}

// Lock locks the backend
func (s *FileStorage) Lock() error {
	// No-op for file storage
	return nil
}

// Name returns the backend name for identification
func (s *FileStorage) Name() string {
	return "file:" + s.path
}

// loadData loads the stored data from file
func (s *FileStorage) loadData() (map[string]interface{}, error) {
	data := make(map[string]interface{})
	
	fileData, err := os.ReadFile(s.path)
	if err != nil {
		if os.IsNotExist(err) {
			return data, nil
		}
		return nil, fmt.Errorf("failed to read file: %w", err)
	}
	
	if len(fileData) > 0 {
		if err := json.Unmarshal(fileData, &data); err != nil {
			return nil, fmt.Errorf("failed to unmarshal data: %w", err)
		}
	}
	
	return data, nil
}

// Metrics tracking methods
func (s *FileStorage) recordOperation(op string) {
	s.metrics.Operations[op]++
	s.metrics.LastAccess = time.Now()
}

func (s *FileStorage) recordError(op string, err error) {
	s.metrics.Errors[op]++
	s.metrics.LastError = err
}

func (s *FileStorage) recordLatency(op string, duration time.Duration) {
	s.metrics.Latencies[op] = duration
}


// End of internal/auth/file_storage.go

=====================

// File: internal/auth/keyring_storage_darwin_test.go

// +build darwin

package auth

import (
	"runtime"
	"testing"

	"github.com/99designs/keyring"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestKeyringStorage_macOSConfig(t *testing.T) {
	// Only run on macOS
	if runtime.GOOS != "darwin" {
		t.Skip("macOS-specific test")
	}

	tests := []struct {
		name                           string
		config                         KeyringConfig
		expectedTrustApp               bool
		expectedAccessibleWhenUnlocked bool
		expectedSynchronizable         bool
	}{
		{
			name: "custom macOS settings",
			config: KeyringConfig{
				ServiceName:                    "test-service",
				KeychainTrustApplication:       true,
				KeychainAccessibleWhenUnlocked: true,
				KeychainSynchronizable:         false,
			},
			expectedTrustApp:               true,
			expectedAccessibleWhenUnlocked: true,
			expectedSynchronizable:         false,
		},
		{
			name: "all false settings",
			config: KeyringConfig{
				ServiceName:                    "test-service",
				KeychainTrustApplication:       false,
				KeychainAccessibleWhenUnlocked: false,
				KeychainSynchronizable:         false,
			},
			expectedTrustApp:               false,
			expectedAccessibleWhenUnlocked: false,
			expectedSynchronizable:         false,
		},
		{
			name: "sync enabled",
			config: KeyringConfig{
				ServiceName:                    "test-service",
				KeychainTrustApplication:       true,
				KeychainAccessibleWhenUnlocked: true,
				KeychainSynchronizable:         true,
			},
			expectedTrustApp:               true,
			expectedAccessibleWhenUnlocked: true,
			expectedSynchronizable:         true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Mock the keyring creation to verify the config
			var capturedConfig keyring.Config
			originalOpen := openKeyring
			openKeyring = func(cfg keyring.Config) (keyring.Keyring, error) {
				capturedConfig = cfg
				return &mockKeyring{}, nil
			}
			defer func() { openKeyring = originalOpen }()

			_, err := NewKeyringStorage(tt.config)
			require.NoError(t, err)

			// Verify macOS-specific settings were applied
			assert.Equal(t, tt.expectedTrustApp, capturedConfig.KeychainTrustApplication)
			assert.Equal(t, tt.expectedAccessibleWhenUnlocked, capturedConfig.KeychainAccessibleWhenUnlocked)
			assert.Equal(t, tt.expectedSynchronizable, capturedConfig.KeychainSynchronizable)
		})
	}
}

// Mock keyring for testing
type mockKeyring struct{}

func (m *mockKeyring) Get(key string) (keyring.Item, error) {
	return keyring.Item{}, keyring.ErrKeyNotFound
}

func (m *mockKeyring) GetMetadata(key string) (keyring.Metadata, error) {
	return keyring.Metadata{}, nil
}

func (m *mockKeyring) Set(item keyring.Item) error {
	return nil
}

func (m *mockKeyring) Remove(key string) error {
	return nil
}

func (m *mockKeyring) Keys() ([]string, error) {
	return []string{}, nil
}


// End of internal/auth/keyring_storage_darwin_test.go

=====================

// File: internal/auth/keyring_storage.go

package auth

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"sync"
	"time"

	"github.com/99designs/keyring"
)

// KeyringStorage implements StorageBackend using OS-native secure storage
type KeyringStorage struct {
	keyring   keyring.Keyring
	config    KeyringConfig
	mu        sync.RWMutex
	metricsMu sync.Mutex // Separate mutex for metrics to avoid lock contention
	metrics   StorageMetrics
}

// KeyringConfig holds configuration for keyring storage
type KeyringConfig struct {
	ServiceName     string
	AllowedBackends []keyring.BackendType
	FileDir         string
	PasswordPrompt  keyring.PromptFunc
	Debug           bool
	
	// macOS-specific settings
	KeychainTrustApplication       bool // Whether the app should be trusted by default
	KeychainAccessibleWhenUnlocked bool // Whether items are accessible when device is locked
	KeychainSynchronizable         bool // Whether items can sync to iCloud
}

// NewKeyringStorage creates a new keyring-based storage backend
func NewKeyringStorage(config KeyringConfig) (*KeyringStorage, error) {
	// Set default service name if not provided
	if config.ServiceName == "" {
		config.ServiceName = "claude-gate"
	}

	// Set default file directory for FileBackend fallback
	if config.FileDir == "" {
		homeDir, _ := os.UserHomeDir()
		config.FileDir = homeDir + "/.claude-gate/keyring"
	}

	// Configure keyring
	keyringConfig := keyring.Config{
		ServiceName:     config.ServiceName,
		AllowedBackends: config.AllowedBackends,
		FileDir:         config.FileDir,
		FilePasswordFunc: config.PasswordPrompt,
	}
	
	// Apply macOS-specific settings on Darwin
	if runtime.GOOS == "darwin" {
		keyringConfig.KeychainTrustApplication = config.KeychainTrustApplication
		keyringConfig.KeychainAccessibleWhenUnlocked = config.KeychainAccessibleWhenUnlocked
		keyringConfig.KeychainSynchronizable = config.KeychainSynchronizable
	}

	// If no backends specified, use platform defaults
	if len(config.AllowedBackends) == 0 {
		keyringConfig.AllowedBackends = getPlatformBackends()
	}

	// Open keyring (use function variable for testing)
	kr, err := openKeyring(keyringConfig)
	if err != nil {
		return nil, fmt.Errorf("failed to open keyring: %w", err)
	}

	return &KeyringStorage{
		keyring: kr,
		config:  config,
		metrics: StorageMetrics{
			Operations: make(map[string]int64),
			Errors:     make(map[string]int64),
			Latencies:  make(map[string]time.Duration),
		},
	}, nil
}

// getPlatformBackends returns the recommended backends for the current platform
func getPlatformBackends() []keyring.BackendType {
	switch runtime.GOOS {
	case "darwin":
		return []keyring.BackendType{
			keyring.KeychainBackend,
			keyring.FileBackend,
		}
	case "linux":
		return []keyring.BackendType{
			keyring.SecretServiceBackend,
			keyring.KWalletBackend,
			keyring.FileBackend,
		}
	case "windows":
		return []keyring.BackendType{
			keyring.WinCredBackend,
			keyring.FileBackend,
		}
	default:
		return []keyring.BackendType{
			keyring.FileBackend,
		}
	}
}

// Get retrieves token information for a provider
func (s *KeyringStorage) Get(provider string) (*TokenInfo, error) {
	s.mu.RLock()
	defer s.mu.RUnlock()

	start := time.Now()
	s.recordOperation("get")
	
	item, err := s.keyring.Get(s.getKey(provider))
	if err != nil {
		if err == keyring.ErrKeyNotFound {
			return nil, nil // Not an error, just not found
		}
		s.recordError("get", err)
		return nil, s.wrapError("get", err)
	}

	var token TokenInfo
	if err := json.Unmarshal(item.Data, &token); err != nil {
		s.recordError("get_unmarshal", err)
		return nil, fmt.Errorf("failed to unmarshal token data: %w", err)
	}

	s.recordLatency("get", time.Since(start))
	return &token, nil
}

// Set stores token information for a provider
func (s *KeyringStorage) Set(provider string, token *TokenInfo) error {
	s.mu.Lock()
	defer s.mu.Unlock()

	start := time.Now()
	s.recordOperation("set")

	data, err := json.Marshal(token)
	if err != nil {
		s.recordError("set_marshal", err)
		return fmt.Errorf("failed to marshal token data: %w", err)
	}

	item := keyring.Item{
		Key:         s.getKey(provider),
		Data:        data,
		Label:       fmt.Sprintf("Claude Gate - %s", provider),
		Description: fmt.Sprintf("OAuth token for %s", provider),
		// Trust this application by default (false = trust, due to double negative)
		KeychainNotTrustApplication: false,
		// Don't sync to iCloud for security
		KeychainNotSynchronizable:   true,
	}

	if err := s.keyring.Set(item); err != nil {
		s.recordError("set", err)
		return s.wrapError("set", err)
	}

	s.recordLatency("set", time.Since(start))
	return nil
}

// Remove deletes token information for a provider
func (s *KeyringStorage) Remove(provider string) error {
	s.mu.Lock()
	defer s.mu.Unlock()

	start := time.Now()
	s.recordOperation("remove")

	if err := s.keyring.Remove(s.getKey(provider)); err != nil {
		if err == keyring.ErrKeyNotFound {
			return nil // Not an error if already removed
		}
		s.recordError("remove", err)
		return s.wrapError("remove", err)
	}

	s.recordLatency("remove", time.Since(start))
	return nil
}

// List returns all stored provider names
func (s *KeyringStorage) List() ([]string, error) {
	s.mu.RLock()
	defer s.mu.RUnlock()

	start := time.Now()
	s.recordOperation("list")

	keys, err := s.keyring.Keys()
	if err != nil {
		s.recordError("list", err)
		return nil, s.wrapError("list", err)
	}

	providers := make([]string, 0, len(keys))
	prefix := s.config.ServiceName + "."
	
	for _, key := range keys {
		if len(key) > len(prefix) && key[:len(prefix)] == prefix {
			providers = append(providers, key[len(prefix):])
		}
	}

	s.recordLatency("list", time.Since(start))
	return providers, nil
}

// IsAvailable checks if the backend is available on this system
func (s *KeyringStorage) IsAvailable() bool {
	// Try a simple operation to check availability
	_, err := s.keyring.Keys()
	return err == nil
}

// RequiresUnlock checks if the backend needs to be unlocked
func (s *KeyringStorage) RequiresUnlock() bool {
	// Most keyrings unlock automatically when needed
	// This is mainly for FileBackend with password
	return false
}

// Unlock attempts to unlock the backend
func (s *KeyringStorage) Unlock() error {
	// Most backends handle this automatically
	return nil
}

// Lock locks the backend
func (s *KeyringStorage) Lock() error {
	// Most backends handle this automatically
	return nil
}

// Name returns the backend name for identification
func (s *KeyringStorage) Name() string {
	return fmt.Sprintf("keyring:%s", s.config.ServiceName)
}

// getKey returns the full key name for a provider
func (s *KeyringStorage) getKey(provider string) string {
	return fmt.Sprintf("%s.%s", s.config.ServiceName, provider)
}

// wrapError wraps keyring errors with more context
func (s *KeyringStorage) wrapError(operation string, err error) error {
	switch err {
	case keyring.ErrKeyNotFound:
		return fmt.Errorf("%s: key not found", operation)
	// Note: ErrUnsupportedBackend might not be exported in all versions
	// Handle by checking error message instead
	default:
		// Check for common error patterns
		errStr := err.Error()
		switch {
		case contains(errStr, "locked", "unlock"):
			return ErrKeyringLocked
		case contains(errStr, "denied", "permission"):
			return ErrKeyringAccessDenied
		case contains(errStr, "timeout"):
			return ErrKeyringTimeout
		case contains(errStr, "unsupported", "not supported"):
			return ErrKeyringUnavailable
		default:
			return fmt.Errorf("%s failed: %w", operation, err)
		}
	}
}

// contains checks if any of the substrings are in s (case-insensitive)
func contains(s string, substrs ...string) bool {
	for _, substr := range substrs {
		if containsIgnoreCase(s, substr) {
			return true
		}
	}
	return false
}

// containsIgnoreCase checks if substr is in s (case-insensitive)
func containsIgnoreCase(s, substr string) bool {
	return len(s) >= len(substr) && 
		(s == substr || 
		 containsIgnoreCase(s[1:], substr) || 
		 (len(s) > 0 && len(substr) > 0 && 
		  (s[0] == substr[0] || s[0] == substr[0]+32 || s[0] == substr[0]-32) && 
		  s[1:len(substr)] == substr[1:]))
}

// Metrics tracking methods
func (s *KeyringStorage) recordOperation(op string) {
	s.metricsMu.Lock()
	defer s.metricsMu.Unlock()
	s.metrics.Operations[op]++
	s.metrics.LastAccess = time.Now()
}

func (s *KeyringStorage) recordError(op string, err error) {
	s.metricsMu.Lock()
	defer s.metricsMu.Unlock()
	s.metrics.Errors[op]++
	s.metrics.LastError = err
}

func (s *KeyringStorage) recordLatency(op string, duration time.Duration) {
	s.metricsMu.Lock()
	defer s.metricsMu.Unlock()
	s.metrics.Latencies[op] = duration
}

// openKeyring is a variable to allow mocking in tests
var openKeyring = keyring.Open
// End of internal/auth/keyring_storage.go

=====================

// File: internal/auth/keyring_storage_test.go

package auth

import (
	"fmt"
	"testing"
	"time"

	"github.com/99designs/keyring"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

// MockKeyring implements a mock keyring for testing
type MockKeyring struct {
	items      map[string]keyring.Item
	keys       []string
	locked     bool
	failNext   bool
	failError  error
}

func NewMockKeyring() *MockKeyring {
	return &MockKeyring{
		items: make(map[string]keyring.Item),
		keys:  []string{},
	}
}

func (m *MockKeyring) Get(key string) (keyring.Item, error) {
	if m.failNext {
		m.failNext = false
		if m.failError != nil {
			return keyring.Item{}, m.failError
		}
		return keyring.Item{}, fmt.Errorf("mock error")
	}
	
	if m.locked {
		return keyring.Item{}, fmt.Errorf("keyring is locked")
	}
	
	item, exists := m.items[key]
	if !exists {
		return keyring.Item{}, keyring.ErrKeyNotFound
	}
	
	return item, nil
}

func (m *MockKeyring) Set(item keyring.Item) error {
	if m.failNext {
		m.failNext = false
		if m.failError != nil {
			return m.failError
		}
		return fmt.Errorf("mock error")
	}
	
	if m.locked {
		return fmt.Errorf("keyring is locked")
	}
	
	m.items[item.Key] = item
	
	// Update keys list
	found := false
	for _, k := range m.keys {
		if k == item.Key {
			found = true
			break
		}
	}
	if !found {
		m.keys = append(m.keys, item.Key)
	}
	
	return nil
}

func (m *MockKeyring) Remove(key string) error {
	if m.failNext {
		m.failNext = false
		if m.failError != nil {
			return m.failError
		}
		return fmt.Errorf("mock error")
	}
	
	if m.locked {
		return fmt.Errorf("keyring is locked")
	}
	
	if _, exists := m.items[key]; !exists {
		return keyring.ErrKeyNotFound
	}
	
	delete(m.items, key)
	
	// Update keys list
	newKeys := []string{}
	for _, k := range m.keys {
		if k != key {
			newKeys = append(newKeys, k)
		}
	}
	m.keys = newKeys
	
	return nil
}

func (m *MockKeyring) Keys() ([]string, error) {
	if m.failNext {
		m.failNext = false
		if m.failError != nil {
			return nil, m.failError
		}
		return nil, fmt.Errorf("mock error")
	}
	
	if m.locked {
		return nil, fmt.Errorf("keyring is locked")
	}
	
	return m.keys, nil
}

func (m *MockKeyring) GetMetadata(key string) (keyring.Metadata, error) {
	// Mock implementation - metadata not supported
	return keyring.Metadata{}, fmt.Errorf("metadata not supported")
}

// Test helpers
func createTestKeyringStorage(t *testing.T) (*KeyringStorage, *MockKeyring) {
	mock := NewMockKeyring()
	storage := &KeyringStorage{
		keyring: mock,
		config: KeyringConfig{
			ServiceName: "test-service",
		},
		metrics: StorageMetrics{
			Operations: make(map[string]int64),
			Errors:     make(map[string]int64),
			Latencies:  make(map[string]time.Duration),
		},
	}
	return storage, mock
}

func createTestToken() *TokenInfo {
	return &TokenInfo{
		Type:         "oauth",
		RefreshToken: "test-refresh-token",
		AccessToken:  "test-access-token",
		ExpiresAt:    time.Now().Add(time.Hour).Unix(),
	}
}

// Tests

func TestKeyringStorage_Get(t *testing.T) {
	storage, _ := createTestKeyringStorage(t)
	token := createTestToken()
	
	// Test getting non-existent token
	result, err := storage.Get("anthropic")
	assert.NoError(t, err)
	assert.Nil(t, result)
	
	// Set a token
	err = storage.Set("anthropic", token)
	require.NoError(t, err)
	
	// Get the token
	result, err = storage.Get("anthropic")
	assert.NoError(t, err)
	assert.NotNil(t, result)
	assert.Equal(t, token.AccessToken, result.AccessToken)
	assert.Equal(t, token.RefreshToken, result.RefreshToken)
	
	// Check metrics
	assert.Equal(t, int64(2), storage.metrics.Operations["get"]) // Two get operations
	assert.Equal(t, int64(1), storage.metrics.Operations["set"])
}

func TestKeyringStorage_Set(t *testing.T) {
	storage, mock := createTestKeyringStorage(t)
	token := createTestToken()
	
	// Set a token
	err := storage.Set("anthropic", token)
	assert.NoError(t, err)
	
	// Verify it was stored
	assert.Len(t, mock.items, 1)
	item, exists := mock.items["test-service.anthropic"]
	assert.True(t, exists)
	assert.Equal(t, "Claude Gate - anthropic", item.Label)
	
	// Verify metrics
	assert.Equal(t, int64(1), storage.metrics.Operations["set"])
}

func TestKeyringStorage_Remove(t *testing.T) {
	storage, mock := createTestKeyringStorage(t)
	token := createTestToken()
	
	// Set a token
	err := storage.Set("anthropic", token)
	require.NoError(t, err)
	
	// Remove it
	err = storage.Remove("anthropic")
	assert.NoError(t, err)
	
	// Verify it was removed
	assert.Len(t, mock.items, 0)
	
	// Remove non-existent (should not error)
	err = storage.Remove("nonexistent")
	assert.NoError(t, err)
}

func TestKeyringStorage_List(t *testing.T) {
	storage, _ := createTestKeyringStorage(t)
	
	// List empty
	providers, err := storage.List()
	assert.NoError(t, err)
	assert.Empty(t, providers)
	
	// Add some tokens
	token := createTestToken()
	storage.Set("anthropic", token)
	storage.Set("openai", token)
	
	// List providers
	providers, err = storage.List()
	assert.NoError(t, err)
	assert.Len(t, providers, 2)
	assert.Contains(t, providers, "anthropic")
	assert.Contains(t, providers, "openai")
}

func TestKeyringStorage_LockedKeychain(t *testing.T) {
	storage, mock := createTestKeyringStorage(t)
	mock.locked = true
	
	// Test all operations with locked keychain
	token := createTestToken()
	
	err := storage.Set("anthropic", token)
	assert.ErrorIs(t, err, ErrKeyringLocked)
	
	_, err = storage.Get("anthropic")
	assert.ErrorIs(t, err, ErrKeyringLocked)
	
	err = storage.Remove("anthropic")
	assert.ErrorIs(t, err, ErrKeyringLocked)
	
	_, err = storage.List()
	assert.ErrorIs(t, err, ErrKeyringLocked)
}

func TestKeyringStorage_ErrorHandling(t *testing.T) {
	storage, mock := createTestKeyringStorage(t)
	
	// Test various error scenarios
	testCases := []struct {
		name      string
		setupMock func()
		operation func() error
		wantError error
	}{
		{
			name: "permission denied",
			setupMock: func() {
				mock.failNext = true
				mock.failError = fmt.Errorf("permission denied")
			},
			operation: func() error {
				return storage.Set("test", createTestToken())
			},
			wantError: ErrKeyringAccessDenied,
		},
		{
			name: "timeout",
			setupMock: func() {
				mock.failNext = true
				mock.failError = fmt.Errorf("operation timeout")
			},
			operation: func() error {
				_, err := storage.Get("test")
				return err
			},
			wantError: ErrKeyringTimeout,
		},
	}
	
	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			tc.setupMock()
			err := tc.operation()
			assert.ErrorIs(t, err, tc.wantError)
		})
	}
}

func TestKeyringStorage_Concurrency(t *testing.T) {
	storage, _ := createTestKeyringStorage(t)
	token := createTestToken()
	
	// Run concurrent operations
	done := make(chan bool)
	
	// Writers
	for i := 0; i < 5; i++ {
		go func(id int) {
			provider := fmt.Sprintf("provider%d", id)
			err := storage.Set(provider, token)
			assert.NoError(t, err)
			done <- true
		}(i)
	}
	
	// Readers
	for i := 0; i < 5; i++ {
		go func(id int) {
			provider := fmt.Sprintf("provider%d", id)
			storage.Get(provider)
			done <- true
		}(i)
	}
	
	// Wait for all operations
	for i := 0; i < 10; i++ {
		<-done
	}
	
	// Verify all providers were stored
	providers, err := storage.List()
	assert.NoError(t, err)
	assert.Len(t, providers, 5)
}

func TestKeyringStorage_TokenExpiry(t *testing.T) {
	storage, _ := createTestKeyringStorage(t)
	
	// Create expired token
	expiredToken := &TokenInfo{
		Type:         "oauth",
		RefreshToken: "expired-refresh",
		AccessToken:  "expired-access",
		ExpiresAt:    time.Now().Add(-time.Hour).Unix(),
	}
	
	// Store expired token
	err := storage.Set("anthropic", expiredToken)
	assert.NoError(t, err)
	
	// Retrieve and check
	retrieved, err := storage.Get("anthropic")
	assert.NoError(t, err)
	assert.True(t, retrieved.IsExpired())
	assert.True(t, retrieved.NeedsRefresh())
}

func TestKeyringStorage_Metrics(t *testing.T) {
	storage, _ := createTestKeyringStorage(t)
	token := createTestToken()
	
	// Perform operations
	storage.Set("test", token)
	storage.Get("test")
	storage.List()
	storage.Remove("test")
	
	// Check metrics
	assert.Equal(t, int64(1), storage.metrics.Operations["set"])
	assert.Equal(t, int64(1), storage.metrics.Operations["get"])
	assert.Equal(t, int64(1), storage.metrics.Operations["list"])
	assert.Equal(t, int64(1), storage.metrics.Operations["remove"])
	
	// Check latencies were recorded
	assert.Contains(t, storage.metrics.Latencies, "set")
	assert.Contains(t, storage.metrics.Latencies, "get")
	assert.Contains(t, storage.metrics.Latencies, "list")
	assert.Contains(t, storage.metrics.Latencies, "remove")
}
// End of internal/auth/keyring_storage_test.go

=====================

// File: internal/auth/keyring_storage_trust_test.go

package auth

import (
	"testing"
	"time"

	"github.com/99designs/keyring"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestKeyringStorage_SetWithTrustSettings(t *testing.T) {
	tests := []struct {
		name                               string
		token                              *TokenInfo
		expectedKeyPrefix                  string
		expectedNotTrustApplication        bool
		expectedNotSynchronizable          bool
	}{
		{
			name: "OAuth token with trust settings",
			token: &TokenInfo{
				Type:         "oauth",
				AccessToken:  "test-access-token",
				RefreshToken: "test-refresh-token",
				ExpiresAt:    1234567890,
			},
			expectedKeyPrefix:           "test-service.anthropic",
			expectedNotTrustApplication: false, // false = trust the app
			expectedNotSynchronizable:   true,  // true = don't sync to iCloud
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Create a mock keyring that captures the item
			var capturedItem keyring.Item
			mockKeyring := &mockKeyringWithCapture{
				captureSet: func(item keyring.Item) error {
					capturedItem = item
					return nil
				},
			}

			// Create storage with mock
			storage := &KeyringStorage{
				keyring: mockKeyring,
				config: KeyringConfig{
					ServiceName: "test-service",
				},
				metrics: StorageMetrics{
					Operations: make(map[string]int64),
					Errors:     make(map[string]int64),
					Latencies:  make(map[string]time.Duration),
				},
			}

			// Set the token
			err := storage.Set("anthropic", tt.token)
			require.NoError(t, err)

			// Verify the item was created with correct trust settings
			assert.Equal(t, tt.expectedKeyPrefix, capturedItem.Key)
			assert.Equal(t, tt.expectedNotTrustApplication, capturedItem.KeychainNotTrustApplication,
				"KeychainNotTrustApplication should be false to trust the app")
			assert.Equal(t, tt.expectedNotSynchronizable, capturedItem.KeychainNotSynchronizable,
				"KeychainNotSynchronizable should be true to prevent iCloud sync")
			assert.Equal(t, "Claude Gate - anthropic", capturedItem.Label)
			assert.Equal(t, "OAuth token for anthropic", capturedItem.Description)
		})
	}
}

// mockKeyringWithCapture allows capturing the item passed to Set
type mockKeyringWithCapture struct {
	captureSet func(item keyring.Item) error
}

func (m *mockKeyringWithCapture) Get(key string) (keyring.Item, error) {
	return keyring.Item{}, keyring.ErrKeyNotFound
}

func (m *mockKeyringWithCapture) GetMetadata(key string) (keyring.Metadata, error) {
	return keyring.Metadata{}, nil
}

func (m *mockKeyringWithCapture) Set(item keyring.Item) error {
	if m.captureSet != nil {
		return m.captureSet(item)
	}
	return nil
}

func (m *mockKeyringWithCapture) Remove(key string) error {
	return nil
}

func (m *mockKeyringWithCapture) Keys() ([]string, error) {
	return []string{}, nil
}
// End of internal/auth/keyring_storage_trust_test.go

=====================

// File: internal/auth/oauth.go

package auth

import (
	"crypto/rand"
	"crypto/sha256"
	"encoding/base64"
	"fmt"
	"net/url"
	"strings"
)

// OAuthClient handles OAuth authentication with Anthropic
type OAuthClient struct {
	ClientID     string
	AuthorizeURL string
	TokenURL     string
	RedirectURI  string
	Scopes       string
}

// AuthData contains authorization URL and PKCE verifier
type AuthData struct {
	URL      string
	Verifier string
}

// NewOAuthClient creates a new OAuth client with Anthropic configuration
func NewOAuthClient() *OAuthClient {
	return &OAuthClient{
		// OAuth client ID is public by design for CLI applications (OAuth public clients).
		// Security is provided by PKCE flow, not by keeping the client ID secret.
		// This follows the same pattern as GitHub CLI, Google Cloud SDK, and other major CLI tools.
		ClientID:     "9d1c250a-e61b-44d9-88ed-5944d1962f5e",
		AuthorizeURL: "https://claude.ai/oauth/authorize",
		TokenURL:     "https://console.anthropic.com/v1/oauth/token",
		RedirectURI:  "https://console.anthropic.com/oauth/code/callback",
		Scopes:       "org:create_api_key user:profile user:inference",
	}
}

// GeneratePKCE generates PKCE verifier and challenge for OAuth flow
func GeneratePKCE() (verifier, challenge string, err error) {
	// Generate 32 bytes of random data
	verifierBytes := make([]byte, 32)
	if _, err := rand.Read(verifierBytes); err != nil {
		return "", "", fmt.Errorf("failed to generate random bytes: %w", err)
	}
	
	// Encode verifier as base64url without padding
	verifier = base64.RawURLEncoding.EncodeToString(verifierBytes)
	
	// Generate challenge by SHA256 hashing the verifier
	h := sha256.Sum256([]byte(verifier))
	challenge = base64.RawURLEncoding.EncodeToString(h[:])
	
	return verifier, challenge, nil
}

// GetAuthorizationURL generates the authorization URL with PKCE parameters
func (c *OAuthClient) GetAuthorizationURL() (*AuthData, error) {
	verifier, challenge, err := GeneratePKCE()
	if err != nil {
		return nil, fmt.Errorf("failed to generate PKCE: %w", err)
	}
	
	params := url.Values{
		"code":                  {"true"},
		"client_id":             {c.ClientID},
		"response_type":         {"code"},
		"redirect_uri":          {c.RedirectURI},
		"scope":                 {c.Scopes},
		"code_challenge":        {challenge},
		"code_challenge_method": {"S256"},
		"state":                 {verifier}, // Using verifier as state (following Python impl)
	}
	
	authURL := fmt.Sprintf("%s?%s", c.AuthorizeURL, params.Encode())
	
	return &AuthData{
		URL:      authURL,
		Verifier: verifier,
	}, nil
}

// parseCodeAndState parses the authorization code and state from the callback
func (c *OAuthClient) parseCodeAndState(code string) (parsedCode, parsedState string) {
	splits := strings.Split(code, "#")
	parsedCode = splits[0]
	if len(splits) > 1 {
		parsedState = splits[1]
	}
	return
}
// End of internal/auth/oauth.go

=====================

// File: internal/auth/oauth_test.go

package auth

import (
	"encoding/base64"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestGeneratePKCE(t *testing.T) {
	t.Run("generates valid PKCE verifier and challenge", func(t *testing.T) {
		verifier, challenge, err := GeneratePKCE()
		require.NoError(t, err)
		
		// Verifier should be base64url encoded without padding
		assert.NotEmpty(t, verifier)
		assert.NotContains(t, verifier, "=")
		assert.NotContains(t, verifier, "+")
		assert.NotContains(t, verifier, "/")
		
		// Decode verifier to check it's 32 bytes
		decoded, err := base64.RawURLEncoding.DecodeString(verifier)
		require.NoError(t, err)
		assert.Len(t, decoded, 32)
		
		// Challenge should be base64url encoded without padding
		assert.NotEmpty(t, challenge)
		assert.NotContains(t, challenge, "=")
		assert.NotContains(t, challenge, "+")
		assert.NotContains(t, challenge, "/")
		
		// Challenge should be SHA256 of verifier
		challengeDecoded, err := base64.RawURLEncoding.DecodeString(challenge)
		require.NoError(t, err)
		assert.Len(t, challengeDecoded, 32) // SHA256 is 32 bytes
	})
	
	t.Run("generates different values each time", func(t *testing.T) {
		v1, c1, err := GeneratePKCE()
		require.NoError(t, err)
		
		v2, c2, err := GeneratePKCE()
		require.NoError(t, err)
		
		assert.NotEqual(t, v1, v2)
		assert.NotEqual(t, c1, c2)
	})
}

func TestOAuthClient(t *testing.T) {
	client := NewOAuthClient()
	
	t.Run("has correct configuration", func(t *testing.T) {
		assert.Equal(t, "9d1c250a-e61b-44d9-88ed-5944d1962f5e", client.ClientID)
		assert.Equal(t, "https://claude.ai/oauth/authorize", client.AuthorizeURL)
		assert.Equal(t, "https://console.anthropic.com/v1/oauth/token", client.TokenURL)
		assert.Equal(t, "https://console.anthropic.com/oauth/code/callback", client.RedirectURI)
		assert.Equal(t, "org:create_api_key user:profile user:inference", client.Scopes)
	})
	
	t.Run("generates authorization URL", func(t *testing.T) {
		authData, err := client.GetAuthorizationURL()
		require.NoError(t, err)
		
		assert.NotEmpty(t, authData.URL)
		assert.Contains(t, authData.URL, client.AuthorizeURL)
		assert.Contains(t, authData.URL, "client_id="+client.ClientID)
		assert.Contains(t, authData.URL, "response_type=code")
		assert.Contains(t, authData.URL, "redirect_uri=")
		assert.Contains(t, authData.URL, "scope=")
		assert.Contains(t, authData.URL, "code_challenge=")
		assert.Contains(t, authData.URL, "code_challenge_method=S256")
		assert.Contains(t, authData.URL, "state=")
		assert.NotEmpty(t, authData.Verifier)
	})
}

func TestTokenExchange(t *testing.T) {
	client := NewOAuthClient()
	
	t.Run("handles code with state", func(t *testing.T) {
		// This will be tested with integration tests
		// For now, we test the code parsing logic
		code := "test-code#test-state"
		parsedCode, parsedState := client.parseCodeAndState(code)
		
		assert.Equal(t, "test-code", parsedCode)
		assert.Equal(t, "test-state", parsedState)
	})
	
	t.Run("handles code without state", func(t *testing.T) {
		code := "test-code"
		parsedCode, parsedState := client.parseCodeAndState(code)
		
		assert.Equal(t, "test-code", parsedCode)
		assert.Empty(t, parsedState)
	})
}
// End of internal/auth/oauth_test.go

=====================

// File: internal/auth/storage_backend.go

package auth

import (
	"errors"
	"time"
)

// Common storage errors
var (
	ErrKeyringLocked       = errors.New("keyring is locked - unlock required")
	ErrKeyringUnavailable  = errors.New("keyring backend not available")
	ErrKeyringAccessDenied = errors.New("keyring access denied")
	ErrKeyringCorrupted    = errors.New("keyring data corrupted")
	ErrKeyringTimeout      = errors.New("keyring operation timed out")
)

// StorageBackend defines the interface for token storage implementations
type StorageBackend interface {
	// Get retrieves token information for a provider
	Get(provider string) (*TokenInfo, error)
	
	// Set stores token information for a provider
	Set(provider string, token *TokenInfo) error
	
	// Remove deletes token information for a provider
	Remove(provider string) error
	
	// List returns all stored provider names
	List() ([]string, error)
	
	// IsAvailable checks if the backend is available on this system
	IsAvailable() bool
	
	// RequiresUnlock checks if the backend needs to be unlocked
	RequiresUnlock() bool
	
	// Unlock attempts to unlock the backend (if supported)
	Unlock() error
	
	// Lock locks the backend (if supported)
	Lock() error
	
	// Name returns the backend name for identification
	Name() string
}

// StorageMetrics tracks storage operation metrics
type StorageMetrics struct {
	Operations map[string]int64
	Errors     map[string]int64
	Latencies  map[string]time.Duration
	LastError  error
	LastAccess time.Time
}

// BackendHealth represents the health status of a storage backend
type BackendHealth struct {
	Available   bool
	Locked      bool
	LastChecked time.Time
	Error       error
}
// End of internal/auth/storage_backend.go

=====================

// File: internal/auth/storage_factory_darwin_test.go

// +build darwin

package auth

import (
	"runtime"
	"testing"

	"github.com/99designs/keyring"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestStorageFactory_macOSDefaults(t *testing.T) {
	// Only run on macOS
	if runtime.GOOS != "darwin" {
		t.Skip("macOS-specific test")
	}

	tests := []struct {
		name   string
		config StorageFactoryConfig
		verify func(t *testing.T, factory *StorageFactory)
	}{
		{
			name: "applies macOS defaults when fields are zero values",
			config: StorageFactoryConfig{
				Type:        StorageTypeKeyring,
				ServiceName: "test-service",
			},
			verify: func(t *testing.T, factory *StorageFactory) {
				// Should have macOS defaults applied
				assert.True(t, factory.keyringConfig.KeychainTrustApplication)
				assert.True(t, factory.keyringConfig.KeychainAccessibleWhenUnlocked)
				assert.False(t, factory.keyringConfig.KeychainSynchronizable)
			},
		},
		{
			name: "respects custom macOS settings",
			config: StorageFactoryConfig{
				Type:                           StorageTypeKeyring,
				ServiceName:                    "test-service",
				KeychainTrustApp:               false,
				KeychainAccessibleWhenUnlocked: false,
				KeychainSynchronizable:         true,
			},
			verify: func(t *testing.T, factory *StorageFactory) {
				// Should use custom settings
				assert.False(t, factory.keyringConfig.KeychainTrustApplication)
				assert.False(t, factory.keyringConfig.KeychainAccessibleWhenUnlocked)
				assert.True(t, factory.keyringConfig.KeychainSynchronizable)
			},
		},
		{
			name: "mixed custom settings",
			config: StorageFactoryConfig{
				Type:                           StorageTypeKeyring,
				ServiceName:                    "test-service",
				KeychainTrustApp:               true,
				KeychainAccessibleWhenUnlocked: false,
				KeychainSynchronizable:         false,
			},
			verify: func(t *testing.T, factory *StorageFactory) {
				// Should use mixed settings
				assert.True(t, factory.keyringConfig.KeychainTrustApplication)
				assert.False(t, factory.keyringConfig.KeychainAccessibleWhenUnlocked)
				assert.False(t, factory.keyringConfig.KeychainSynchronizable)
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			factory := NewStorageFactory(tt.config)
			require.NotNil(t, factory)
			tt.verify(t, factory)
		})
	}
}

func TestStorageFactory_CreateWithMacOSSettings(t *testing.T) {
	// Only run on macOS
	if runtime.GOOS != "darwin" {
		t.Skip("macOS-specific test")
	}

	// Create factory with custom macOS settings
	config := StorageFactoryConfig{
		Type:                           StorageTypeKeyring,
		ServiceName:                    "test-service",
		KeychainTrustApp:               true,
		KeychainAccessibleWhenUnlocked: true,
		KeychainSynchronizable:         false,
	}

	factory := NewStorageFactory(config)

	// Mock the keyring creation to verify settings are passed through
	originalOpen := openKeyring
	var capturedTrustApp bool
	openKeyring = func(cfg keyring.Config) (keyring.Keyring, error) {
		capturedTrustApp = cfg.KeychainTrustApplication
		return &mockKeyring{}, nil
	}
	defer func() { openKeyring = originalOpen }()

	storage, err := factory.Create()
	require.NoError(t, err)
	require.NotNil(t, storage)

	// Verify the trust app setting was passed through
	assert.True(t, capturedTrustApp)
}
// End of internal/auth/storage_factory_darwin_test.go

=====================

// File: internal/auth/storage_factory.go

package auth

import (
	"fmt"
	"os"
	"runtime"

	"github.com/99designs/keyring"
)

// StorageType represents the type of storage backend
type StorageType string

const (
	StorageTypeAuto    StorageType = "auto"    // Automatically select best available
	StorageTypeKeyring StorageType = "keyring" // Force keyring storage
	StorageTypeFile    StorageType = "file"    // Force file storage
)

// StorageFactory creates storage backends based on configuration
type StorageFactory struct {
	storageType    StorageType
	filePath       string
	keyringConfig  KeyringConfig
	passwordPrompt keyring.PromptFunc
}

// StorageFactoryConfig holds configuration for the storage factory
type StorageFactoryConfig struct {
	Type           StorageType
	FilePath       string
	ServiceName    string
	PasswordPrompt keyring.PromptFunc
	
	// macOS-specific settings
	KeychainTrustApp               bool
	KeychainAccessibleWhenUnlocked bool
	KeychainSynchronizable         bool
}

// NewStorageFactory creates a new storage factory
func NewStorageFactory(config StorageFactoryConfig) *StorageFactory {
	// Set defaults
	if config.Type == "" {
		config.Type = StorageTypeAuto
	}
	
	if config.ServiceName == "" {
		config.ServiceName = "claude-gate"
	}
	
	if config.FilePath == "" {
		homeDir, _ := os.UserHomeDir()
		config.FilePath = homeDir + "/.claude-gate/auth.json"
	}
	
	// Default password prompt if not provided
	if config.PasswordPrompt == nil {
		config.PasswordPrompt = defaultPasswordPrompt
	}
	
	// Set keyring config
	keyringCfg := KeyringConfig{
		ServiceName:    config.ServiceName,
		PasswordPrompt: config.PasswordPrompt,
		Debug:          false,
	}
	
	// Apply macOS settings from config (with defaults if not set)
	if runtime.GOOS == "darwin" {
		// Use config values, but default to true/true/false if not explicitly set
		keyringCfg.KeychainTrustApplication = config.KeychainTrustApp
		keyringCfg.KeychainAccessibleWhenUnlocked = config.KeychainAccessibleWhenUnlocked
		keyringCfg.KeychainSynchronizable = config.KeychainSynchronizable
		
		// If the struct fields are zero values and we're on macOS, apply sensible defaults
		// This handles backward compatibility when the fields aren't explicitly set
		if !config.KeychainTrustApp && !config.KeychainAccessibleWhenUnlocked && !config.KeychainSynchronizable {
			keyringCfg.KeychainTrustApplication = true       // Trust app by default
			keyringCfg.KeychainAccessibleWhenUnlocked = true // Accessible when unlocked
			keyringCfg.KeychainSynchronizable = false        // Don't sync to iCloud
		}
	}
	
	return &StorageFactory{
		storageType:    config.Type,
		filePath:       config.FilePath,
		keyringConfig:  keyringCfg,
		passwordPrompt: config.PasswordPrompt,
	}
}

// Create creates a storage backend based on configuration
func (f *StorageFactory) Create() (StorageBackend, error) {
	switch f.storageType {
	case StorageTypeFile:
		return NewFileStorage(f.filePath), nil
		
	case StorageTypeKeyring:
		ks, err := NewKeyringStorage(f.keyringConfig)
		if err != nil {
			return nil, fmt.Errorf("failed to create keyring storage: %w", err)
		}
		return ks, nil
		
	case StorageTypeAuto:
		// Try keyring first, fall back to file
		if isKeyringAvailable() {
			ks, err := NewKeyringStorage(f.keyringConfig)
			if err == nil && ks.IsAvailable() {
				return ks, nil
			}
			// Log warning and fall back
			fmt.Fprintf(os.Stderr, "Warning: Keyring storage unavailable, falling back to file storage: %v\n", err)
		}
		return NewFileStorage(f.filePath), nil
		
	default:
		return nil, fmt.Errorf("unknown storage type: %s", f.storageType)
	}
}

// CreateWithMigration creates a storage backend and migrates data if needed
func (f *StorageFactory) CreateWithMigration() (StorageBackend, error) {
	// Create the target storage
	storage, err := f.Create()
	if err != nil {
		return nil, err
	}
	
	// Check if we need to migrate from file storage
	if f.storageType != StorageTypeFile {
		fileStorage := NewFileStorage(f.filePath)
		
		// Check if file storage has data
		providers, err := fileStorage.List()
		if err == nil && len(providers) > 0 {
			// Migrate data
			migrator := NewStorageMigrator(fileStorage, storage)
			if err := migrator.Migrate(); err != nil {
				return nil, fmt.Errorf("failed to migrate storage: %w", err)
			}
			
			fmt.Fprintf(os.Stderr, "Successfully migrated %d tokens to %s\n", len(providers), storage.Name())
		}
	}
	
	return storage, nil
}

// isKeyringAvailable checks if keyring functionality is available on this system
func isKeyringAvailable() bool {
	switch runtime.GOOS {
	case "darwin":
		// macOS always has Keychain
		return true
	case "linux":
		// Check for Secret Service or KWallet
		// This is a simplified check - in reality we'd check D-Bus
		return os.Getenv("DISPLAY") != "" || os.Getenv("WAYLAND_DISPLAY") != ""
	// case "windows":
	// 	// Windows always has Credential Manager
	// 	return true
	default:
		return false
	}
}

// defaultPasswordPrompt provides a default password prompt function
func defaultPasswordPrompt(prompt string) (string, error) {
	// In a real implementation, this would use terminal input
	// For now, return an error to force non-interactive mode
	return "", fmt.Errorf("interactive password prompt not implemented - use environment variable or config file")
}
// End of internal/auth/storage_factory.go

=====================

// File: internal/auth/storage_factory_test.go

package auth

import (
	"runtime"
	"os"
	"path/filepath"
	"strings"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestStorageFactory_Create(t *testing.T) {
	// Test file storage creation
	t.Run("file storage", func(t *testing.T) {
		testPath := filepath.Join(os.TempDir(), "test-auth.json")
		factory := NewStorageFactory(StorageFactoryConfig{
			Type:     StorageTypeFile,
			FilePath: testPath,
		})
		
		storage, err := factory.Create()
		assert.NoError(t, err)
		assert.NotNil(t, storage)
		assert.IsType(t, &FileStorage{}, storage)
		assert.Equal(t, "file:"+testPath, storage.Name())
	})
	
	// Test auto storage creation
	t.Run("auto storage", func(t *testing.T) {
		testPath := filepath.Join(os.TempDir(), "test-auth.json")
		factory := NewStorageFactory(StorageFactoryConfig{
			Type:     StorageTypeAuto,
			FilePath: testPath,
		})
		
		storage, err := factory.Create()
		assert.NoError(t, err)
		assert.NotNil(t, storage)
		// Auto mode will select best available backend
		// Could be either keyring or file depending on system
		assert.True(t, storage.Name() == "keyring:claude-gate" || strings.Contains(storage.Name(), "file:"))
	})
	
	// Test unknown storage type
	t.Run("unknown storage type", func(t *testing.T) {
		factory := &StorageFactory{
			storageType: StorageType("unknown"),
		}
		
		storage, err := factory.Create()
		assert.Error(t, err)
		assert.Nil(t, storage)
		assert.Contains(t, err.Error(), "unknown storage type")
	})
}

func TestStorageFactory_CreateWithMigration(t *testing.T) {
	// Create temporary directory for test
	tempDir := t.TempDir()
	jsonPath := filepath.Join(tempDir, "auth.json")
	
	// Create file storage with test data
	fileStorage := NewFileStorage(jsonPath)
	testToken := &TokenInfo{
		Type:         "oauth",
		RefreshToken: "test-refresh",
		AccessToken:  "test-access",
		ExpiresAt:    1234567890,
	}
	
	err := fileStorage.Set("anthropic", testToken)
	require.NoError(t, err)
	
	// Create factory that will migrate to file storage (simulating keyring)
	factory := NewStorageFactory(StorageFactoryConfig{
		Type:     StorageTypeFile,
		FilePath: filepath.Join(tempDir, "auth-migrated.json"),
	})
	
	// Create with migration
	storage, err := factory.CreateWithMigration()
	assert.NoError(t, err)
	assert.NotNil(t, storage)
	
	// Original file should still exist
	_, err = os.Stat(jsonPath)
	assert.NoError(t, err)
}

func TestStorageFactory_Defaults(t *testing.T) {
	// Test with empty config
	factory := NewStorageFactory(StorageFactoryConfig{})
	
	assert.Equal(t, StorageTypeAuto, factory.storageType)
	assert.Equal(t, "claude-gate", factory.keyringConfig.ServiceName)
	assert.Contains(t, factory.filePath, ".claude-gate/auth.json")
	assert.NotNil(t, factory.passwordPrompt)
}

func TestIsKeyringAvailable(t *testing.T) {
	// This test is platform-specific
	available := isKeyringAvailable()
	
	switch runtime.GOOS {
	case "darwin":
		// Should always be available on macOS
		assert.True(t, available)
	case "linux":
		// Depends on display environment
		hasDisplay := os.Getenv("DISPLAY") != "" || os.Getenv("WAYLAND_DISPLAY") != ""
		assert.Equal(t, hasDisplay, available)
	default:
		// Other platforms should return false
		assert.False(t, available)
	}
}
// End of internal/auth/storage_factory_test.go

=====================

// File: internal/auth/storage_migrator.go

package auth

import (
	"fmt"
	"os"
	"path/filepath"
	"time"
)

// StorageMigrator handles migration between storage backends
type StorageMigrator struct {
	source      StorageBackend
	destination StorageBackend
	backup      bool
}

// NewStorageMigrator creates a new storage migrator
func NewStorageMigrator(source, destination StorageBackend) *StorageMigrator {
	return &StorageMigrator{
		source:      source,
		destination: destination,
		backup:      true,
	}
}

// Migrate performs the migration from source to destination
func (m *StorageMigrator) Migrate() error {
	// Get all providers from source
	providers, err := m.source.List()
	if err != nil {
		return fmt.Errorf("failed to list providers from source: %w", err)
	}
	
	if len(providers) == 0 {
		return nil // Nothing to migrate
	}
	
	// Create backup if requested
	if m.backup {
		if err := m.createBackup(); err != nil {
			// Log warning but continue
			fmt.Fprintf(os.Stderr, "Warning: Failed to create backup: %v\n", err)
		}
	}
	
	// Track migration results
	migrated := 0
	failed := 0
	
	// Migrate each provider
	for _, provider := range providers {
		// Get token from source
		token, err := m.source.Get(provider)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Warning: Failed to get token for %s: %v\n", provider, err)
			failed++
			continue
		}
		
		if token == nil {
			continue // Skip empty entries
		}
		
		// Set token in destination
		if err := m.destination.Set(provider, token); err != nil {
			fmt.Fprintf(os.Stderr, "Warning: Failed to set token for %s: %v\n", provider, err)
			failed++
			continue
		}
		
		migrated++
	}
	
	// Report results
	if failed > 0 {
		return fmt.Errorf("migration completed with errors: %d migrated, %d failed", migrated, failed)
	}
	
	// Mark source as migrated (don't delete yet)
	if err := m.markSourceMigrated(); err != nil {
		// Non-fatal error
		fmt.Fprintf(os.Stderr, "Warning: Failed to mark source as migrated: %v\n", err)
	}
	
	return nil
}

// MigrateProvider migrates a single provider
func (m *StorageMigrator) MigrateProvider(provider string) error {
	// Get token from source
	token, err := m.source.Get(provider)
	if err != nil {
		return fmt.Errorf("failed to get token from source: %w", err)
	}
	
	if token == nil {
		return fmt.Errorf("no token found for provider: %s", provider)
	}
	
	// Set token in destination
	if err := m.destination.Set(provider, token); err != nil {
		return fmt.Errorf("failed to set token in destination: %w", err)
	}
	
	return nil
}

// Rollback attempts to rollback a failed migration
func (m *StorageMigrator) Rollback() error {
	// Swap source and destination
	rollbackMigrator := &StorageMigrator{
		source:      m.destination,
		destination: m.source,
		backup:      false, // Don't create backup during rollback
	}
	
	return rollbackMigrator.Migrate()
}

// createBackup creates a backup of the source storage
func (m *StorageMigrator) createBackup() error {
	// Only backup file storage
	fileStorage, ok := m.source.(*FileStorage)
	if !ok {
		return nil // Can't backup non-file storage
	}
	
	// Create backup directory
	homeDir, _ := os.UserHomeDir()
	backupDir := filepath.Join(homeDir, ".claude-gate", "backups")
	if err := os.MkdirAll(backupDir, 0700); err != nil {
		return fmt.Errorf("failed to create backup directory: %w", err)
	}
	
	// Generate backup filename with timestamp
	timestamp := time.Now().Format("20060102-150405")
	backupPath := filepath.Join(backupDir, fmt.Sprintf("auth-%s.json", timestamp))
	
	// Copy file
	sourceData, err := os.ReadFile(fileStorage.path)
	if err != nil {
		return fmt.Errorf("failed to read source file: %w", err)
	}
	
	if err := os.WriteFile(backupPath, sourceData, 0600); err != nil {
		return fmt.Errorf("failed to write backup file: %w", err)
	}
	
	fmt.Fprintf(os.Stderr, "Created backup at: %s\n", backupPath)
	return nil
}

// markSourceMigrated marks the source as migrated
func (m *StorageMigrator) markSourceMigrated() error {
	// Only mark file storage
	fileStorage, ok := m.source.(*FileStorage)
	if !ok {
		return nil
	}
	
	// Rename file to indicate migration
	migratedPath := fileStorage.path + ".migrated"
	
	// Check if already exists
	if _, err := os.Stat(migratedPath); err == nil {
		// Already migrated, remove old one
		os.Remove(migratedPath)
	}
	
	return os.Rename(fileStorage.path, migratedPath)
}

// VerifyMigration verifies that all data was migrated correctly
func (m *StorageMigrator) VerifyMigration() error {
	// Get all providers from source
	sourceProviders, err := m.source.List()
	if err != nil {
		return fmt.Errorf("failed to list source providers: %w", err)
	}
	
	// Check each provider in destination
	for _, provider := range sourceProviders {
		sourceToken, err := m.source.Get(provider)
		if err != nil {
			return fmt.Errorf("failed to get source token for %s: %w", provider, err)
		}
		
		destToken, err := m.destination.Get(provider)
		if err != nil {
			return fmt.Errorf("failed to get destination token for %s: %w", provider, err)
		}
		
		// Compare tokens
		if !tokensEqual(sourceToken, destToken) {
			return fmt.Errorf("token mismatch for provider %s", provider)
		}
	}
	
	return nil
}

// tokensEqual compares two tokens for equality
func tokensEqual(a, b *TokenInfo) bool {
	if a == nil && b == nil {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	
	return a.Type == b.Type &&
		a.RefreshToken == b.RefreshToken &&
		a.AccessToken == b.AccessToken &&
		a.ExpiresAt == b.ExpiresAt &&
		a.APIKey == b.APIKey
}
// End of internal/auth/storage_migrator.go

=====================

// File: internal/auth/storage_migrator_test.go

package auth

import (
	"fmt"
	"os"
	"path/filepath"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestStorageMigrator_Migrate(t *testing.T) {
	// Create source storage with test data
	source := createTestFileStorage(t)
	tokens := map[string]*TokenInfo{
		"anthropic": {
			Type:         "oauth",
			RefreshToken: "refresh1",
			AccessToken:  "access1",
			ExpiresAt:    1234567890,
		},
		"openai": {
			Type:         "oauth",
			RefreshToken: "refresh2",
			AccessToken:  "access2",
			ExpiresAt:    9876543210,
		},
	}
	
	// Populate source
	for provider, token := range tokens {
		err := source.Set(provider, token)
		require.NoError(t, err)
	}
	
	// Create destination storage
	destination := createTestFileStorage(t)
	
	// Create migrator
	migrator := NewStorageMigrator(source, destination)
	
	// Perform migration
	err := migrator.Migrate()
	assert.NoError(t, err)
	
	// Verify all tokens were migrated
	for provider, expectedToken := range tokens {
		actualToken, err := destination.Get(provider)
		assert.NoError(t, err)
		assert.Equal(t, expectedToken, actualToken)
	}
	
	// Verify source was marked as migrated
	_, err = os.Stat(source.path + ".migrated")
	assert.NoError(t, err)
}

func TestStorageMigrator_MigrateEmpty(t *testing.T) {
	// Create empty source
	source := createTestFileStorage(t)
	destination := createTestFileStorage(t)
	
	migrator := NewStorageMigrator(source, destination)
	
	// Migrate empty storage
	err := migrator.Migrate()
	assert.NoError(t, err)
	
	// Verify destination is still empty
	providers, err := destination.List()
	assert.NoError(t, err)
	assert.Empty(t, providers)
}

func TestStorageMigrator_MigrateWithErrors(t *testing.T) {
	// Create source with test data
	source := createTestFileStorage(t)
	source.Set("provider1", &TokenInfo{Type: "oauth", AccessToken: "token1"})
	source.Set("provider2", &TokenInfo{Type: "oauth", AccessToken: "token2"})
	
	// Create destination that will fail on second provider
	destination := &mockFailingStorage{
		FileStorage: createTestFileStorage(t),
		failOn:      "provider2",
	}
	
	migrator := NewStorageMigrator(source, destination)
	
	// Perform migration
	err := migrator.Migrate()
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "1 migrated, 1 failed")
	
	// Verify first provider was migrated
	token, err := destination.Get("provider1")
	assert.NoError(t, err)
	assert.NotNil(t, token)
}

func TestStorageMigrator_Rollback(t *testing.T) {
	// Create storages
	original := createTestFileStorage(t)
	migrated := createTestFileStorage(t)
	
	// Add test data to migrated storage
	testToken := &TokenInfo{
		Type:        "oauth",
		AccessToken: "rolled-back-token",
	}
	migrated.Set("anthropic", testToken)
	
	// Create migrator (note: source and destination are swapped for rollback)
	migrator := NewStorageMigrator(original, migrated)
	
	// Perform rollback
	err := migrator.Rollback()
	assert.NoError(t, err)
	
	// Verify token is back in original
	token, err := original.Get("anthropic")
	assert.NoError(t, err)
	assert.Equal(t, testToken, token)
}

func TestStorageMigrator_Backup(t *testing.T) {
	// Create source storage with test data
	source := createTestFileStorage(t)
	source.Set("anthropic", &TokenInfo{Type: "oauth", AccessToken: "backup-me"})
	
	destination := createTestFileStorage(t)
	
	// Create migrator with backup enabled
	migrator := NewStorageMigrator(source, destination)
	migrator.backup = true
	
	// Perform migration
	err := migrator.Migrate()
	assert.NoError(t, err)
	
	// Check that backup was created
	homeDir, _ := os.UserHomeDir()
	backupDir := filepath.Join(homeDir, ".claude-gate", "backups")
	entries, err := os.ReadDir(backupDir)
	if err == nil && len(entries) > 0 {
		// At least one backup exists
		assert.NotEmpty(t, entries)
	}
}

func TestStorageMigrator_VerifyMigration(t *testing.T) {
	// Create storages with identical data
	source := createTestFileStorage(t)
	destination := createTestFileStorage(t)
	
	tokens := map[string]*TokenInfo{
		"provider1": {Type: "oauth", AccessToken: "token1"},
		"provider2": {Type: "oauth", AccessToken: "token2"},
	}
	
	for provider, token := range tokens {
		source.Set(provider, token)
		destination.Set(provider, token)
	}
	
	migrator := NewStorageMigrator(source, destination)
	
	// Verify migration
	err := migrator.VerifyMigration()
	assert.NoError(t, err)
	
	// Modify one token
	destination.Set("provider1", &TokenInfo{Type: "oauth", AccessToken: "modified"})
	
	// Verify should fail
	err = migrator.VerifyMigration()
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "token mismatch")
}

func TestTokensEqual(t *testing.T) {
	token1 := &TokenInfo{
		Type:         "oauth",
		RefreshToken: "refresh",
		AccessToken:  "access",
		ExpiresAt:    1234567890,
	}
	
	token2 := &TokenInfo{
		Type:         "oauth",
		RefreshToken: "refresh",
		AccessToken:  "access",
		ExpiresAt:    1234567890,
	}
	
	token3 := &TokenInfo{
		Type:         "oauth",
		RefreshToken: "different",
		AccessToken:  "access",
		ExpiresAt:    1234567890,
	}
	
	assert.True(t, tokensEqual(token1, token2))
	assert.False(t, tokensEqual(token1, token3))
	assert.True(t, tokensEqual(nil, nil))
	assert.False(t, tokensEqual(token1, nil))
	assert.False(t, tokensEqual(nil, token1))
}

// Helper functions

func createTestFileStorage(t *testing.T) *FileStorage {
	tempDir := t.TempDir()
	return NewFileStorage(filepath.Join(tempDir, "test-auth.json"))
}

// mockFailingStorage simulates a storage that fails on specific operations
type mockFailingStorage struct {
	*FileStorage
	failOn string
}

func (m *mockFailingStorage) Set(provider string, token *TokenInfo) error {
	if provider == m.failOn {
		return fmt.Errorf("simulated failure for %s", provider)
	}
	return m.FileStorage.Set(provider, token)
}
// End of internal/auth/storage_migrator_test.go

=====================

// File: internal/auth/storage_test.go

package auth

import (
	"os"
	"path/filepath"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestTokenStorage(t *testing.T) {
	// Use temp directory for tests
	tempDir := t.TempDir()
	
	t.Run("creates storage with correct path", func(t *testing.T) {
		storage := NewFileStorage(filepath.Join(tempDir, ".claude-gate", "auth.json"))
		assert.NotNil(t, storage)
		assert.Contains(t, storage.path, ".claude-gate")
		assert.Contains(t, storage.path, "auth.json")
	})
	
	t.Run("stores and retrieves OAuth token", func(t *testing.T) {
		storage := NewFileStorage(filepath.Join(tempDir, "test1", "auth.json"))
		
		token := &TokenInfo{
			Type:         "oauth",
			RefreshToken: "test-refresh-token",
			AccessToken:  "test-access-token",
			ExpiresAt:    time.Now().Add(time.Hour).Unix(),
		}
		
		err := storage.Set("anthropic", token)
		require.NoError(t, err)
		
		retrieved, err := storage.Get("anthropic")
		require.NoError(t, err)
		assert.NotNil(t, retrieved)
		assert.Equal(t, "oauth", retrieved.Type)
		assert.Equal(t, "test-refresh-token", retrieved.RefreshToken)
		assert.Equal(t, "test-access-token", retrieved.AccessToken)
		assert.Equal(t, token.ExpiresAt, retrieved.ExpiresAt)
	})
	
	t.Run("stores and retrieves API key", func(t *testing.T) {
		storage := NewFileStorage(filepath.Join(tempDir, "test2", "auth.json"))
		
		token := &TokenInfo{
			Type:   "api",
			APIKey: "sk-test-key",
		}
		
		err := storage.Set("anthropic", token)
		require.NoError(t, err)
		
		retrieved, err := storage.Get("anthropic")
		require.NoError(t, err)
		assert.NotNil(t, retrieved)
		assert.Equal(t, "api", retrieved.Type)
		assert.Equal(t, "sk-test-key", retrieved.APIKey)
	})
	
	t.Run("returns nil for non-existent provider", func(t *testing.T) {
		storage := NewFileStorage(filepath.Join(tempDir, "test3", "auth.json"))
		
		retrieved, err := storage.Get("non-existent")
		assert.NoError(t, err)
		assert.Nil(t, retrieved)
	})
	
	t.Run("removes token", func(t *testing.T) {
		storage := NewFileStorage(filepath.Join(tempDir, "test4", "auth.json"))
		
		token := &TokenInfo{
			Type:   "api",
			APIKey: "sk-test-key",
		}
		
		err := storage.Set("anthropic", token)
		require.NoError(t, err)
		
		err = storage.Remove("anthropic")
		require.NoError(t, err)
		
		retrieved, err := storage.Get("anthropic")
		require.NoError(t, err)
		assert.Nil(t, retrieved)
	})
	
	t.Run("creates directory if not exists", func(t *testing.T) {
		authPath := filepath.Join(tempDir, "new-dir", "auth.json")
		storage := NewFileStorage(authPath)
		
		token := &TokenInfo{
			Type:   "api",
			APIKey: "sk-test-key",
		}
		
		err := storage.Set("anthropic", token)
		require.NoError(t, err)
		
		// Check directory was created
		_, err = os.Stat(filepath.Dir(authPath))
		assert.NoError(t, err)
	})
	
	t.Run("sets secure file permissions", func(t *testing.T) {
		authPath := filepath.Join(tempDir, "perms", "auth.json")
		storage := NewFileStorage(authPath)
		
		token := &TokenInfo{
			Type:   "api",
			APIKey: "sk-test-key",
		}
		
		err := storage.Set("anthropic", token)
		require.NoError(t, err)
		
		// Check file permissions (owner read/write only)
		info, err := os.Stat(authPath)
		require.NoError(t, err)
		assert.Equal(t, os.FileMode(0600), info.Mode().Perm())
	})
	
	t.Run("handles multiple providers", func(t *testing.T) {
		storage := NewFileStorage(filepath.Join(tempDir, "multi", "auth.json"))
		
		token1 := &TokenInfo{
			Type:   "api",
			APIKey: "sk-test-1",
		}
		token2 := &TokenInfo{
			Type:   "api",
			APIKey: "sk-test-2",
		}
		
		err := storage.Set("anthropic", token1)
		require.NoError(t, err)
		err = storage.Set("openai", token2)
		require.NoError(t, err)
		
		retrieved1, err := storage.Get("anthropic")
		require.NoError(t, err)
		assert.Equal(t, "sk-test-1", retrieved1.APIKey)
		
		retrieved2, err := storage.Get("openai")
		require.NoError(t, err)
		assert.Equal(t, "sk-test-2", retrieved2.APIKey)
	})
}

func TestTokenInfo(t *testing.T) {
	t.Run("checks if token is expired", func(t *testing.T) {
		token := &TokenInfo{
			Type:        "oauth",
			AccessToken: "test",
			ExpiresAt:   time.Now().Add(-time.Hour).Unix(), // Expired 1 hour ago
		}
		assert.True(t, token.IsExpired())
		
		token.ExpiresAt = time.Now().Add(time.Hour).Unix() // Expires in 1 hour
		assert.False(t, token.IsExpired())
	})
	
	t.Run("needs refresh when close to expiry", func(t *testing.T) {
		token := &TokenInfo{
			Type:        "oauth",
			AccessToken: "test",
			ExpiresAt:   time.Now().Add(30 * time.Second).Unix(), // Expires in 30 seconds
		}
		assert.True(t, token.NeedsRefresh())
		
		token.ExpiresAt = time.Now().Add(10 * time.Minute).Unix() // Expires in 10 minutes
		assert.False(t, token.NeedsRefresh())
	})
}
// End of internal/auth/storage_test.go

=====================

// File: internal/config/config.go

package config

import (
	"os"
	"path/filepath"
	"strconv"
	"time"
)

// Config holds all configuration for the proxy server
type Config struct {
	// Server settings
	Host string
	Port int
	
	// Anthropic API settings
	AnthropicBaseURL string
	
	// Proxy authentication
	ProxyAuthToken string
	
	// Request settings
	RequestTimeout time.Duration
	MaxRequestSize int
	
	// Logging
	LogLevel     string
	LogRequests  bool
	
	// Rate limiting
	EnableRateLimit     bool
	RateLimitPerMinute  int
	
	// CORS settings
	CORSAllowOrigins []string
	
	// Storage settings
	AuthStoragePath   string
	AuthStorageType   string  // "auto", "keyring", or "file"
	KeyringService    string  // Service name for keyring
	AutoMigrateTokens bool    // Automatically migrate tokens to keyring
	
	// macOS Keychain settings
	KeychainTrustApp               bool // Trust the app by default (macOS only)
	KeychainAccessibleWhenUnlocked bool // Items accessible when unlocked (macOS only)
	KeychainSynchronizable         bool // Sync items to iCloud (macOS only)
}

// DefaultConfig returns default configuration
func DefaultConfig() *Config {
	homeDir, _ := os.UserHomeDir()
	
	return &Config{
		Host:                "127.0.0.1",
		Port:                5789,
		AnthropicBaseURL:    "https://api.anthropic.com",
		RequestTimeout:      600 * time.Second,
		MaxRequestSize:      10 * 1024 * 1024, // 10MB
		LogLevel:            "INFO",
		LogRequests:         true,
		EnableRateLimit:     false,
		RateLimitPerMinute:  60,
		CORSAllowOrigins:    []string{"*"},
		AuthStoragePath:     filepath.Join(homeDir, ".claude-gate", "auth.json"),
		AuthStorageType:     "auto",
		KeyringService:      "claude-gate",
		AutoMigrateTokens:   true,
		KeychainTrustApp:               true,  // Trust by default on macOS
		KeychainAccessibleWhenUnlocked: true,  // Standard accessibility
		KeychainSynchronizable:         false, // Don't sync tokens to iCloud
	}
}

// LoadFromEnv loads configuration from environment variables
func (c *Config) LoadFromEnv() {
	// Server settings
	if host := os.Getenv("CLAUDE_GATE_HOST"); host != "" {
		c.Host = host
	}
	if port := os.Getenv("CLAUDE_GATE_PORT"); port != "" {
		if p, err := strconv.Atoi(port); err == nil {
			c.Port = p
		}
	}
	
	// Anthropic API
	if url := os.Getenv("CLAUDE_GATE_ANTHROPIC_BASE_URL"); url != "" {
		c.AnthropicBaseURL = url
	}
	
	// Proxy auth
	if token := os.Getenv("CLAUDE_GATE_PROXY_AUTH_TOKEN"); token != "" {
		c.ProxyAuthToken = token
	}
	
	// Request settings
	if timeout := os.Getenv("CLAUDE_GATE_REQUEST_TIMEOUT"); timeout != "" {
		if d, err := time.ParseDuration(timeout); err == nil {
			c.RequestTimeout = d
		}
	}
	if size := os.Getenv("CLAUDE_GATE_MAX_REQUEST_SIZE"); size != "" {
		if s, err := strconv.Atoi(size); err == nil {
			c.MaxRequestSize = s
		}
	}
	
	// Logging
	if level := os.Getenv("CLAUDE_GATE_LOG_LEVEL"); level != "" {
		c.LogLevel = level
	}
	if logReq := os.Getenv("CLAUDE_GATE_LOG_REQUESTS"); logReq != "" {
		c.LogRequests = logReq == "true" || logReq == "1"
	}
	
	// Rate limiting
	if enable := os.Getenv("CLAUDE_GATE_ENABLE_RATE_LIMIT"); enable != "" {
		c.EnableRateLimit = enable == "true" || enable == "1"
	}
	if limit := os.Getenv("CLAUDE_GATE_RATE_LIMIT_PER_MINUTE"); limit != "" {
		if l, err := strconv.Atoi(limit); err == nil {
			c.RateLimitPerMinute = l
		}
	}
	
	// Storage settings
	if path := os.Getenv("CLAUDE_GATE_AUTH_STORAGE_PATH"); path != "" {
		c.AuthStoragePath = path
	}
	if storageType := os.Getenv("CLAUDE_GATE_AUTH_STORAGE_TYPE"); storageType != "" {
		c.AuthStorageType = storageType
	}
	if service := os.Getenv("CLAUDE_GATE_KEYRING_SERVICE"); service != "" {
		c.KeyringService = service
	}
	if autoMigrate := os.Getenv("CLAUDE_GATE_AUTO_MIGRATE_TOKENS"); autoMigrate != "" {
		c.AutoMigrateTokens = autoMigrate == "true" || autoMigrate == "1"
	}
	
	// macOS Keychain settings
	if trustApp := os.Getenv("CLAUDE_GATE_KEYCHAIN_TRUST_APP"); trustApp != "" {
		c.KeychainTrustApp = trustApp == "true" || trustApp == "1"
	}
	if accessible := os.Getenv("CLAUDE_GATE_KEYCHAIN_ACCESSIBLE_WHEN_UNLOCKED"); accessible != "" {
		c.KeychainAccessibleWhenUnlocked = accessible == "true" || accessible == "1"
	}
	if sync := os.Getenv("CLAUDE_GATE_KEYCHAIN_SYNCHRONIZABLE"); sync != "" {
		c.KeychainSynchronizable = sync == "true" || sync == "1"
	}
}

// GetBindAddress returns the server bind address
func (c *Config) GetBindAddress() string {
	return c.Host + ":" + strconv.Itoa(c.Port)
}
// End of internal/config/config.go

=====================

// File: internal/config/config_test.go

package config

import (
	"os"
	"testing"

	"github.com/stretchr/testify/assert"
)

func TestConfig_macOSKeychainDefaults(t *testing.T) {
	cfg := DefaultConfig()

	// Check macOS keychain defaults
	assert.True(t, cfg.KeychainTrustApp, "KeychainTrustApp should default to true")
	assert.True(t, cfg.KeychainAccessibleWhenUnlocked, "KeychainAccessibleWhenUnlocked should default to true")
	assert.False(t, cfg.KeychainSynchronizable, "KeychainSynchronizable should default to false")
}

func TestConfig_LoadFromEnv_macOSKeychain(t *testing.T) {
	tests := []struct {
		name     string
		envVars  map[string]string
		validate func(t *testing.T, cfg *Config)
	}{
		{
			name: "trust app enabled",
			envVars: map[string]string{
				"CLAUDE_GATE_KEYCHAIN_TRUST_APP": "true",
			},
			validate: func(t *testing.T, cfg *Config) {
				assert.True(t, cfg.KeychainTrustApp)
			},
		},
		{
			name: "trust app disabled",
			envVars: map[string]string{
				"CLAUDE_GATE_KEYCHAIN_TRUST_APP": "false",
			},
			validate: func(t *testing.T, cfg *Config) {
				assert.False(t, cfg.KeychainTrustApp)
			},
		},
		{
			name: "accessible when unlocked disabled",
			envVars: map[string]string{
				"CLAUDE_GATE_KEYCHAIN_ACCESSIBLE_WHEN_UNLOCKED": "false",
			},
			validate: func(t *testing.T, cfg *Config) {
				assert.False(t, cfg.KeychainAccessibleWhenUnlocked)
			},
		},
		{
			name: "synchronizable enabled",
			envVars: map[string]string{
				"CLAUDE_GATE_KEYCHAIN_SYNCHRONIZABLE": "true",
			},
			validate: func(t *testing.T, cfg *Config) {
				assert.True(t, cfg.KeychainSynchronizable)
			},
		},
		{
			name: "all macOS settings",
			envVars: map[string]string{
				"CLAUDE_GATE_KEYCHAIN_TRUST_APP":                "false",
				"CLAUDE_GATE_KEYCHAIN_ACCESSIBLE_WHEN_UNLOCKED": "false",
				"CLAUDE_GATE_KEYCHAIN_SYNCHRONIZABLE":           "true",
			},
			validate: func(t *testing.T, cfg *Config) {
				assert.False(t, cfg.KeychainTrustApp)
				assert.False(t, cfg.KeychainAccessibleWhenUnlocked)
				assert.True(t, cfg.KeychainSynchronizable)
			},
		},
		{
			name: "numeric values (1 and 0)",
			envVars: map[string]string{
				"CLAUDE_GATE_KEYCHAIN_TRUST_APP":                "1",
				"CLAUDE_GATE_KEYCHAIN_ACCESSIBLE_WHEN_UNLOCKED": "0",
				"CLAUDE_GATE_KEYCHAIN_SYNCHRONIZABLE":           "1",
			},
			validate: func(t *testing.T, cfg *Config) {
				assert.True(t, cfg.KeychainTrustApp)
				assert.False(t, cfg.KeychainAccessibleWhenUnlocked)
				assert.True(t, cfg.KeychainSynchronizable)
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Set environment variables
			for k, v := range tt.envVars {
				os.Setenv(k, v)
				defer os.Unsetenv(k)
			}

			cfg := DefaultConfig()
			cfg.LoadFromEnv()

			tt.validate(t, cfg)
		})
	}
}

func TestConfig_createStorageFactoryConfig(t *testing.T) {
	cfg := &Config{
		AuthStorageType:                "keyring",
		AuthStoragePath:                "/test/path",
		KeyringService:                 "test-service",
		KeychainTrustApp:               true,
		KeychainAccessibleWhenUnlocked: false,
		KeychainSynchronizable:         true,
	}

	// This would be tested in the main package
	// Just verify the config has the expected values
	assert.Equal(t, "keyring", cfg.AuthStorageType)
	assert.Equal(t, "/test/path", cfg.AuthStoragePath)
	assert.Equal(t, "test-service", cfg.KeyringService)
	assert.True(t, cfg.KeychainTrustApp)
	assert.False(t, cfg.KeychainAccessibleWhenUnlocked)
	assert.True(t, cfg.KeychainSynchronizable)
}
// End of internal/config/config_test.go

=====================

// File: internal/logger/logger.go

package logger

import (
	"context"
	"log/slog"
	"os"
	"strings"
)

// contextKey is a custom type for context keys to avoid collisions
type contextKey string

const loggerKey contextKey = "logger"

// LogLevel represents the logging level
type LogLevel string

const (
	DEBUG   LogLevel = "DEBUG"
	INFO    LogLevel = "INFO"
	WARNING LogLevel = "WARNING"
	ERROR   LogLevel = "ERROR"
)

// New creates a new structured logger with the specified level
func New(level LogLevel) *slog.Logger {
	var slogLevel slog.Level
	
	switch level {
	case DEBUG:
		slogLevel = slog.LevelDebug
	case INFO:
		slogLevel = slog.LevelInfo
	case WARNING:
		slogLevel = slog.LevelWarn
	case ERROR:
		slogLevel = slog.LevelError
	default:
		slogLevel = slog.LevelInfo
	}
	
	opts := &slog.HandlerOptions{
		Level: slogLevel,
		ReplaceAttr: func(groups []string, a slog.Attr) slog.Attr {
			// Customize time format
			if a.Key == slog.TimeKey {
				return slog.Attr{
					Key:   a.Key,
					Value: slog.StringValue(a.Value.Time().Format("2006-01-02T15:04:05.000Z07:00")),
				}
			}
			return a
		},
	}
	
	handler := slog.NewTextHandler(os.Stderr, opts)
	return slog.New(handler)
}

// ParseLevel converts a string to LogLevel
func ParseLevel(s string) LogLevel {
	switch strings.ToUpper(s) {
	case "DEBUG":
		return DEBUG
	case "INFO":
		return INFO
	case "WARNING", "WARN":
		return WARNING
	case "ERROR":
		return ERROR
	default:
		return INFO
	}
}

// WithContext adds the logger to the context
func WithContext(ctx context.Context, logger *slog.Logger) context.Context {
	return context.WithValue(ctx, loggerKey, logger)
}

// FromContext retrieves the logger from the context
func FromContext(ctx context.Context) *slog.Logger {
	if logger, ok := ctx.Value(loggerKey).(*slog.Logger); ok {
		return logger
	}
	// Return a default logger if none in context
	return slog.Default()
}
// End of internal/logger/logger.go

=====================

// File: internal/proxy/handler.go

package proxy

import (
	"bufio"
	"bytes"
	"context"
	"encoding/json"
	"io"
	"log/slog"
	"math/rand"
	"net/http"
	"net/url"
	"strings"
	"time"
	
	"github.com/ml0-1337/claude-gate/internal/auth"
)

// TokenProvider interface for OAuth token management
type TokenProvider interface {
	GetAccessToken() (string, error)
}

// ProxyConfig holds configuration for the proxy handler
type ProxyConfig struct {
	UpstreamURL   string
	TokenProvider TokenProvider
	Transformer   *RequestTransformer
	Timeout       time.Duration
	Logger        *slog.Logger
}

// ProxyHandler handles HTTP requests and proxies them to Anthropic API
type ProxyHandler struct {
	config     *ProxyConfig
	httpClient *http.Client
	logger     *slog.Logger
}

// NewProxyHandler creates a new proxy handler
func NewProxyHandler(config *ProxyConfig) *ProxyHandler {
	if config.Timeout == 0 {
		config.Timeout = 600 * time.Second // 10 minutes default
	}
	
	// Use default logger if none provided
	logger := config.Logger
	if logger == nil {
		logger = slog.Default()
	}
	
	// Create HTTP client with custom transport for better streaming support
	transport := &http.Transport{
		MaxIdleConns:        100,
		MaxIdleConnsPerHost: 20,
		IdleConnTimeout:     90 * time.Second,
		DisableCompression:  true, // Important for SSE
	}
	
	return &ProxyHandler{
		config: config,
		httpClient: &http.Client{
			Transport: transport,
			Timeout:   config.Timeout,
		},
		logger: logger,
	}
}

// ServeHTTP implements http.Handler interface
func (h *ProxyHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	// Log request details
	h.logger.Info("incoming request",
		"method", r.Method,
		"path", r.URL.Path,
		"remote_addr", r.RemoteAddr,
		"user_agent", r.Header.Get("User-Agent"),
	)
	
	// Handle CORS preflight requests
	if r.Method == "OPTIONS" {
		h.handleCORS(w, r)
		return
	}
	
	// Set CORS headers for all requests
	h.setCORSHeaders(w, r)
	
	// Get OAuth token
	token, err := h.config.TokenProvider.GetAccessToken()
	if err != nil {
		h.logger.Error("failed to get OAuth token", "error", err)
		h.writeError(w, http.StatusUnauthorized, "OAuth token error", err.Error())
		return
	}
	h.logger.Debug("OAuth token retrieved successfully")
	
	// Read request body
	body, err := io.ReadAll(r.Body)
	if err != nil {
		h.writeError(w, http.StatusBadRequest, "Failed to read request body", err.Error())
		return
	}
	defer r.Body.Close()
	
	// Check if this is a streaming request
	isStreamingRequest := false
	if len(body) > 0 {
		var reqData map[string]interface{}
		if err := json.Unmarshal(body, &reqData); err == nil {
			if stream, ok := reqData["stream"].(bool); ok && stream {
				isStreamingRequest = true
			}
		}
	}
	h.logger.Debug("streaming detection", "is_streaming", isStreamingRequest, "body_length", len(body))
	
	// Transform request body if needed
	path := r.URL.Path
	transformedBody, err := h.config.Transformer.TransformRequestBody(body, path)
	if err != nil {
		h.writeError(w, http.StatusInternalServerError, "Failed to transform request", err.Error())
		return
	}
	
	// Transform path for OpenAI endpoints
	upstreamPath := path
	if path == "/v1/chat/completions" {
		upstreamPath = "/v1/messages"
	}
	
	// Build upstream URL
	upstreamURL, err := url.Parse(h.config.UpstreamURL)
	if err != nil {
		h.writeError(w, http.StatusInternalServerError, "Invalid upstream URL", err.Error())
		return
	}
	upstreamURL.Path = upstreamPath
	upstreamURL.RawQuery = r.URL.RawQuery
	
	// Create upstream request
	upstreamReq, err := http.NewRequest(r.Method, upstreamURL.String(), bytes.NewReader(transformedBody))
	if err != nil {
		h.writeError(w, http.StatusInternalServerError, "Failed to create upstream request", err.Error())
		return
	}
	
	// For streaming requests, ensure proper connection handling
	if isStreamingRequest {
		// Set headers to prevent connection reuse for SSE
		r.Header.Set("Connection", "close")
		r.Header.Set("Cache-Control", "no-cache")
	}
	
	// Inject OAuth headers
	upstreamReq.Header = h.config.Transformer.InjectHeaders(r.Header, token)
	
	// Make upstream request
	h.logger.Debug("sending request to upstream",
		"url", upstreamReq.URL.String(),
		"method", upstreamReq.Method,
		"has_connection_header", upstreamReq.Header.Get("Connection") != "",
	)
	
	resp, err := h.httpClient.Do(upstreamReq)
	if err != nil {
		h.logger.Error("upstream request failed", "error", err)
		h.writeError(w, http.StatusBadGateway, "Upstream request failed", err.Error())
		return
	}
	defer resp.Body.Close()
	
	h.logger.Debug("received upstream response",
		"status", resp.StatusCode,
		"content_type", resp.Header.Get("Content-Type"),
		"transfer_encoding", resp.Header.Get("Transfer-Encoding"),
	)
	
	// Check if this is a streaming response
	isStreaming := strings.Contains(resp.Header.Get("Content-Type"), "text/event-stream") ||
		strings.Contains(r.URL.RawQuery, "stream=true")
	
	// Also check the request body for stream parameter
	if !isStreaming && len(body) > 0 {
		var reqData map[string]interface{}
		if err := json.Unmarshal(body, &reqData); err == nil {
			if stream, ok := reqData["stream"].(bool); ok && stream {
				isStreaming = true
			}
		}
	}
	
	h.logger.Info("response type determined",
		"is_streaming", isStreaming,
		"path", path,
		"status", resp.StatusCode,
	)
	
	// Handle response body
	if isStreaming {
		// Copy response headers for streaming
		for key, values := range resp.Header {
			for _, value := range values {
				w.Header().Add(key, value)
			}
		}
		
		// Add headers to prevent proxy buffering and connection reuse
		w.Header().Set("X-Accel-Buffering", "no") // Disable nginx buffering
		w.Header().Set("Cache-Control", "no-cache")
		w.Header().Set("Connection", "close") // Close connection after SSE stream
		
		// Write status code
		w.WriteHeader(resp.StatusCode)
		
		// For OpenAI endpoints, convert SSE format
		if path == "/v1/chat/completions" {
			h.logger.Info("streaming OpenAI-compatible response", "path", path)
			h.streamOpenAIResponse(w, resp, path)
		} else {
			// For SSE, we need to flush after each write
			h.logger.Info("streaming native Anthropic response", "path", path)
			h.streamResponse(w, resp)
		}
	} else {
		// For OpenAI endpoints, transform response back
		if path == "/v1/chat/completions" {
			respBody, err := io.ReadAll(resp.Body)
			if err != nil {
				h.writeError(w, http.StatusInternalServerError, "Failed to read response", err.Error())
				return
			}
			
			// Transform Anthropic response to OpenAI format
			transformedResp, err := h.config.Transformer.TransformResponseBody(respBody, path)
			if err != nil {
				// If transformation fails, return original
				// Copy headers excluding Content-Length
				for key, values := range resp.Header {
					if strings.ToLower(key) != "content-length" {
						for _, value := range values {
							w.Header().Add(key, value)
						}
					}
				}
				w.WriteHeader(resp.StatusCode)
				w.Write(respBody)
				return
			}
			
			// Copy headers excluding Content-Length and Content-Encoding
			for key, values := range resp.Header {
				if strings.ToLower(key) != "content-length" && strings.ToLower(key) != "content-encoding" {
					for _, value := range values {
						w.Header().Add(key, value)
					}
				}
			}
			
			// Write status code
			w.WriteHeader(resp.StatusCode)
			
			// Write transformed response (Go will set correct Content-Length)
			w.Write(transformedResp)
		} else {
			// Regular response - copy headers and body
			for key, values := range resp.Header {
				for _, value := range values {
					w.Header().Add(key, value)
				}
			}
			
			// Write status code
			w.WriteHeader(resp.StatusCode)
			
			// Just copy
			io.Copy(w, resp.Body)
		}
	}
}

// streamResponse handles Server-Sent Events streaming
func (h *ProxyHandler) streamResponse(w http.ResponseWriter, resp *http.Response) {
	flusher, ok := w.(http.Flusher)
	if !ok {
		h.logger.Warn("response writer does not support flushing, falling back to copy")
		// Fallback to regular copy if flusher not available
		io.Copy(w, resp.Body)
		return
	}
	
	h.logger.Debug("starting native SSE streaming")
	
	// Create a custom writer that flushes after each write
	buf := make([]byte, 4096)
	bytesStreamed := 0
	for {
		n, err := resp.Body.Read(buf)
		if n > 0 {
			if _, writeErr := w.Write(buf[:n]); writeErr != nil {
				h.logger.Error("error writing to response", "error", writeErr)
				return
			}
			flusher.Flush()
			bytesStreamed += n
			h.logger.Debug("streamed chunk", "bytes", n, "total_bytes", bytesStreamed)
		}
		if err != nil {
			if err != io.EOF {
				h.logger.Error("error reading from upstream", "error", err)
			} else {
				h.logger.Debug("streaming completed", "total_bytes", bytesStreamed)
			}
			return
		}
	}
}

// streamOpenAIResponse converts Anthropic SSE to OpenAI SSE format
func (h *ProxyHandler) streamOpenAIResponse(w http.ResponseWriter, resp *http.Response, path string) {
	flusher, ok := w.(http.Flusher)
	if !ok {
		h.logger.Warn("response writer does not support flushing for OpenAI streaming")
		// Fallback to regular streaming if flusher not available
		h.streamResponse(w, resp)
		return
	}
	
	h.logger.Debug("starting OpenAI SSE conversion")
	
	// Generate message ID and timestamp for consistency
	messageID := "chatcmpl-" + generateRandomID()
	created := time.Now().Unix()
	model := "claude-3-5-sonnet-20241022" // Default model
	
	h.logger.Debug("OpenAI SSE session",
		"message_id", messageID,
		"created", created,
		"default_model", model,
	)
	
	scanner := bufio.NewScanner(resp.Body)
	var currentEvent string
	eventCount := 0
	
	for scanner.Scan() {
		line := scanner.Text()
		
		if strings.HasPrefix(line, "event: ") {
			currentEvent = strings.TrimPrefix(line, "event: ")
			h.logger.Debug("SSE event received", "event", currentEvent)
		} else if strings.HasPrefix(line, "data: ") {
			data := strings.TrimPrefix(line, "data: ")
			
			// Extract model from message_start if available
			if currentEvent == "message_start" {
				var msgData map[string]interface{}
				if err := json.Unmarshal([]byte(data), &msgData); err == nil {
					if msg, ok := msgData["message"].(map[string]interface{}); ok {
						if m, ok := msg["model"].(string); ok {
							model = m
							h.logger.Debug("extracted model from message_start", "model", model)
						}
					}
				}
			}
			
			// Convert the SSE event
			converted, err := ConvertAnthropicSSEToOpenAIWithLogger(currentEvent, data, messageID, model, created, h.logger)
			if err == nil && converted != "" {
				eventCount++
				h.logger.Debug("converted SSE event",
					"event_type", currentEvent,
					"event_count", eventCount,
					"output_length", len(converted),
				)
				
				n, writeErr := w.Write([]byte(converted))
				if writeErr != nil {
					h.logger.Error("failed to write converted event", "error", writeErr)
					return
				}
				flusher.Flush()
				h.logger.Debug("flushed SSE event", "bytes_written", n)
			} else if err != nil {
				h.logger.Error("failed to convert SSE event", "event", currentEvent, "error", err)
			}
		}
	}
	
	// Check for scanner errors
	if err := scanner.Err(); err != nil {
		h.logger.Error("scanner error during SSE streaming", "error", err)
		// The connection might have been closed by the client
		return
	}
	
	h.logger.Info("SSE streaming completed, sending [DONE] marker", "total_events", eventCount)
	
	// Send the [DONE] marker to properly close the OpenAI SSE stream
	n, err := w.Write([]byte("data: [DONE]\n\n"))
	if err != nil {
		h.logger.Error("failed to write [DONE] marker", "error", err)
		return
	}
	flusher.Flush()
	h.logger.Debug("sent [DONE] marker", "bytes_written", n)
}

// generateRandomID generates a random ID for OpenAI format
func generateRandomID() string {
	const charset = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
	b := make([]byte, 29)
	for i := range b {
		b[i] = charset[rand.Intn(len(charset))]
	}
	return string(b)
}

// writeError writes an error response in Anthropic's error format
func (h *ProxyHandler) writeError(w http.ResponseWriter, statusCode int, errorType, message string) {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(statusCode)
	
	errorResp := map[string]interface{}{
		"error": map[string]interface{}{
			"type":    errorType,
			"message": message,
		},
	}
	
	json.NewEncoder(w).Encode(errorResp)
}

// setCORSHeaders sets CORS headers for all responses
func (h *ProxyHandler) setCORSHeaders(w http.ResponseWriter, r *http.Request) {
	origin := r.Header.Get("Origin")
	if origin == "" {
		origin = "*"
	}
	
	w.Header().Set("Access-Control-Allow-Origin", origin)
	w.Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
	w.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization, X-Requested-With")
	w.Header().Set("Access-Control-Allow-Credentials", "true")
	w.Header().Set("Access-Control-Max-Age", "3600")
}

// handleCORS handles CORS preflight requests
func (h *ProxyHandler) handleCORS(w http.ResponseWriter, r *http.Request) {
	h.setCORSHeaders(w, r)
	w.WriteHeader(http.StatusNoContent)
}

// ProxyServer wraps the handler with additional server functionality
type ProxyServer struct {
	handler *ProxyHandler
	server  *http.Server
}

// NewProxyServer creates a new proxy server with health endpoints
func NewProxyServer(config *ProxyConfig, addr string, storage auth.StorageBackend) *ProxyServer {
	proxyHandler := NewProxyHandler(config)
	healthHandler := NewHealthHandler(storage)
	mux := CreateMux(proxyHandler, healthHandler)
	
	return &ProxyServer{
		handler: proxyHandler,
		server: &http.Server{
			Addr:         addr,
			Handler:      mux,
			ReadTimeout:  30 * time.Second,
			WriteTimeout: config.Timeout + 10*time.Second, // Slightly more than request timeout
			IdleTimeout:  120 * time.Second,
		},
	}
}

// Start starts the proxy server
func (s *ProxyServer) Start() error {
	return s.server.ListenAndServe()
}

// Stop gracefully stops the proxy server
func (s *ProxyServer) Stop(timeout time.Duration) error {
	ctx, cancel := context.WithTimeout(context.Background(), timeout)
	defer cancel()
	return s.server.Shutdown(ctx)
}
// End of internal/proxy/handler.go

=====================

// File: internal/proxy/handler_test.go

package proxy

import (
	"bytes"
	"encoding/json"
	"io"
	"net/http"
	"net/http/httptest"
	"strings"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

type mockTokenProvider struct {
	token string
	err   error
}

func (m *mockTokenProvider) GetAccessToken() (string, error) {
	return m.token, m.err
}

func TestProxyHandler(t *testing.T) {
	t.Run("proxies request with transformed body and headers", func(t *testing.T) {
		// Create test server to act as Anthropic API
		upstream := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			// Verify headers
			assert.Equal(t, "Bearer test-token", r.Header.Get("Authorization"))
			assert.Equal(t, "oauth-2025-04-20", r.Header.Get("anthropic-beta"))
			assert.Equal(t, "2023-06-01", r.Header.Get("anthropic-version"))
			
			// Verify body transformation
			body, err := io.ReadAll(r.Body)
			require.NoError(t, err)
			
			var data map[string]interface{}
			err = json.Unmarshal(body, &data)
			require.NoError(t, err)
			
			// Check system prompt was transformed
			system, ok := data["system"].([]interface{})
			require.True(t, ok)
			require.Len(t, system, 2)
			
			first := system[0].(map[string]interface{})
			assert.Equal(t, ClaudeCodePrompt, first["text"])
			
			// Check model alias was mapped
			assert.Equal(t, "claude-3-5-sonnet-20241022", data["model"])
			
			// Send response
			w.Header().Set("Content-Type", "application/json")
			json.NewEncoder(w).Encode(map[string]interface{}{
				"id": "msg_123",
				"content": []map[string]interface{}{
					{"type": "text", "text": "Hello from Claude"},
				},
			})
		}))
		defer upstream.Close()
		
		// Create proxy handler
		handler := NewProxyHandler(&ProxyConfig{
			UpstreamURL:   upstream.URL,
			TokenProvider: &mockTokenProvider{token: "test-token"},
			Transformer:   NewRequestTransformer(),
		})
		
		// Create test request
		reqBody := map[string]interface{}{
			"model":  "claude-3-5-sonnet-latest",
			"system": "User prompt",
			"messages": []map[string]interface{}{
				{"role": "user", "content": "Hello"},
			},
		}
		bodyBytes, _ := json.Marshal(reqBody)
		
		req := httptest.NewRequest("POST", "/v1/messages", bytes.NewReader(bodyBytes))
		req.Header.Set("Content-Type", "application/json")
		req.Header.Set("User-Agent", "Test/1.0") // Should be stripped
		
		// Execute request
		w := httptest.NewRecorder()
		handler.ServeHTTP(w, req)
		
		// Verify response
		assert.Equal(t, http.StatusOK, w.Code)
		assert.Equal(t, "application/json", w.Header().Get("Content-Type"))
		
		var response map[string]interface{}
		err := json.Unmarshal(w.Body.Bytes(), &response)
		require.NoError(t, err)
		assert.Equal(t, "msg_123", response["id"])
	})
	
	t.Run("handles streaming SSE responses", func(t *testing.T) {
		// Create test server with SSE response
		upstream := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			w.Header().Set("Content-Type", "text/event-stream")
			w.Header().Set("Cache-Control", "no-cache")
			w.Header().Set("X-Accel-Buffering", "no")
			
			flusher, ok := w.(http.Flusher)
			require.True(t, ok)
			
			// Send SSE events
			events := []string{
				"event: message_start\ndata: {\"type\":\"message_start\"}\n\n",
				"event: content_block_start\ndata: {\"type\":\"content_block_start\"}\n\n",
				"event: content_block_delta\ndata: {\"type\":\"content_block_delta\",\"delta\":{\"text\":\"Hello\"}}\n\n",
				"event: content_block_stop\ndata: {\"type\":\"content_block_stop\"}\n\n",
				"event: message_stop\ndata: {\"type\":\"message_stop\"}\n\n",
			}
			
			for _, event := range events {
				_, err := w.Write([]byte(event))
				require.NoError(t, err)
				flusher.Flush()
				time.Sleep(10 * time.Millisecond) // Simulate streaming delay
			}
		}))
		defer upstream.Close()
		
		// Create proxy handler
		handler := NewProxyHandler(&ProxyConfig{
			UpstreamURL:   upstream.URL,
			TokenProvider: &mockTokenProvider{token: "test-token"},
			Transformer:   NewRequestTransformer(),
		})
		
		// Create streaming request
		reqBody := map[string]interface{}{
			"model":  "claude-3-5-sonnet-20241022",
			"stream": true,
			"messages": []map[string]interface{}{
				{"role": "user", "content": "Hello"},
			},
		}
		bodyBytes, _ := json.Marshal(reqBody)
		
		req := httptest.NewRequest("POST", "/v1/messages", bytes.NewReader(bodyBytes))
		req.Header.Set("Content-Type", "application/json")
		
		// Execute request
		w := httptest.NewRecorder()
		handler.ServeHTTP(w, req)
		
		// Verify response headers
		assert.Equal(t, http.StatusOK, w.Code)
		assert.Equal(t, "text/event-stream", w.Header().Get("Content-Type"))
		assert.Equal(t, "no-cache", w.Header().Get("Cache-Control"))
		
		// Verify we received SSE events
		body := w.Body.String()
		assert.Contains(t, body, "event: message_start")
		assert.Contains(t, body, "event: content_block_delta")
		assert.Contains(t, body, "data: {\"type\":\"content_block_delta\",\"delta\":{\"text\":\"Hello\"}}")
	})
	
	t.Run("handles OpenAI streaming format with [DONE] marker", func(t *testing.T) {
		// Create test server with SSE response
		upstream := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			w.Header().Set("Content-Type", "text/event-stream")
			w.Header().Set("Cache-Control", "no-cache")
			
			flusher, ok := w.(http.Flusher)
			require.True(t, ok)
			
			// Send Anthropic SSE events
			events := []string{
				"event: message_start\ndata: {\"type\":\"message_start\",\"message\":{\"model\":\"claude-3-opus-20240229\"}}\n\n",
				"event: content_block_delta\ndata: {\"type\":\"content_block_delta\",\"delta\":{\"type\":\"text_delta\",\"text\":\"Hello\"}}\n\n",
				"event: message_stop\ndata: {\"type\":\"message_stop\"}\n\n",
			}
			
			for _, event := range events {
				_, err := w.Write([]byte(event))
				require.NoError(t, err)
				flusher.Flush()
			}
		}))
		defer upstream.Close()
		
		// Create proxy handler
		handler := NewProxyHandler(&ProxyConfig{
			UpstreamURL:   upstream.URL,
			TokenProvider: &mockTokenProvider{token: "test-token"},
			Transformer:   NewRequestTransformer(),
		})
		
		// Create OpenAI-style request
		reqBody := map[string]interface{}{
			"model":  "gpt-4",
			"stream": true,
			"messages": []map[string]interface{}{
				{"role": "user", "content": "Hello"},
			},
		}
		bodyBytes, _ := json.Marshal(reqBody)
		
		req := httptest.NewRequest("POST", "/v1/chat/completions", bytes.NewReader(bodyBytes))
		req.Header.Set("Content-Type", "application/json")
		
		// Use a custom ResponseRecorder to capture streaming
		w := httptest.NewRecorder()
		handler.ServeHTTP(w, req)
		
		// Verify we received OpenAI SSE format with [DONE] marker
		body := w.Body.String()
		assert.Contains(t, body, "data: {")
		assert.Contains(t, body, `"object":"chat.completion.chunk"`)
		assert.Contains(t, body, `"finish_reason":"stop"`)
		assert.Contains(t, body, "data: [DONE]") // Should end with [DONE] marker
		
		// Verify [DONE] is at the end
		assert.True(t, strings.HasSuffix(strings.TrimSpace(body), "data: [DONE]"))
	})
	
	t.Run("handles token provider errors", func(t *testing.T) {
		handler := NewProxyHandler(&ProxyConfig{
			UpstreamURL:   "http://example.com",
			TokenProvider: &mockTokenProvider{err: assert.AnError},
			Transformer:   NewRequestTransformer(),
		})
		
		req := httptest.NewRequest("POST", "/v1/messages", bytes.NewReader([]byte("{}")))
		w := httptest.NewRecorder()
		
		handler.ServeHTTP(w, req)
		
		assert.Equal(t, http.StatusUnauthorized, w.Code)
		
		var response map[string]interface{}
		err := json.Unmarshal(w.Body.Bytes(), &response)
		require.NoError(t, err)
		errorObj, ok := response["error"].(map[string]interface{})
		require.True(t, ok)
		assert.Equal(t, "OAuth token error", errorObj["type"])
	})
	
	t.Run("passes through non-messages endpoints without transformation", func(t *testing.T) {
		upstream := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			// Verify no system prompt transformation for non-messages endpoint
			body, _ := io.ReadAll(r.Body)
			w.Header().Set("Content-Type", "application/json")
			w.Write(body) // Echo back
		}))
		defer upstream.Close()
		
		handler := NewProxyHandler(&ProxyConfig{
			UpstreamURL:   upstream.URL,
			TokenProvider: &mockTokenProvider{token: "test-token"},
			Transformer:   NewRequestTransformer(),
		})
		
		reqBody := map[string]interface{}{
			"system": "Should not be transformed",
		}
		bodyBytes, _ := json.Marshal(reqBody)
		
		req := httptest.NewRequest("GET", "/v1/models", bytes.NewReader(bodyBytes))
		req.Header.Set("Content-Type", "application/json")
		
		w := httptest.NewRecorder()
		handler.ServeHTTP(w, req)
		
		assert.Equal(t, http.StatusOK, w.Code)
		
		var response map[string]interface{}
		err := json.Unmarshal(w.Body.Bytes(), &response)
		require.NoError(t, err)
		assert.Equal(t, "Should not be transformed", response["system"])
	})
	
	t.Run("handles upstream errors", func(t *testing.T) {
		upstream := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			w.Header().Set("Content-Type", "application/json")
			w.WriteHeader(http.StatusBadRequest)
			json.NewEncoder(w).Encode(map[string]interface{}{
				"error": map[string]interface{}{
					"type":    "invalid_request_error",
					"message": "Invalid model",
				},
			})
		}))
		defer upstream.Close()
		
		handler := NewProxyHandler(&ProxyConfig{
			UpstreamURL:   upstream.URL,
			TokenProvider: &mockTokenProvider{token: "test-token"},
			Transformer:   NewRequestTransformer(),
		})
		
		req := httptest.NewRequest("POST", "/v1/messages", bytes.NewReader([]byte("{}")))
		w := httptest.NewRecorder()
		
		handler.ServeHTTP(w, req)
		
		assert.Equal(t, http.StatusBadRequest, w.Code)
		
		var response map[string]interface{}
		err := json.Unmarshal(w.Body.Bytes(), &response)
		require.NoError(t, err)
		assert.Equal(t, "invalid_request_error", response["error"].(map[string]interface{})["type"])
	})
	
	t.Run("injects system prompt for requests without one", func(t *testing.T) {
		// Create test server to verify system prompt injection
		upstream := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			body, err := io.ReadAll(r.Body)
			require.NoError(t, err)
			
			var data map[string]interface{}
			err = json.Unmarshal(body, &data)
			require.NoError(t, err)
			
			// Verify system prompt was injected
			system, ok := data["system"].(string)
			require.True(t, ok)
			assert.Equal(t, ClaudeCodePrompt, system)
			
			// Send response
			w.Header().Set("Content-Type", "application/json")
			json.NewEncoder(w).Encode(map[string]interface{}{
				"id": "msg_456",
				"content": []map[string]interface{}{
					{"type": "text", "text": "Response without system prompt"},
				},
			})
		}))
		defer upstream.Close()
		
		// Create proxy handler
		handler := NewProxyHandler(&ProxyConfig{
			UpstreamURL:   upstream.URL,
			TokenProvider: &mockTokenProvider{token: "test-token"},
			Transformer:   NewRequestTransformer(),
		})
		
		// Create test request WITHOUT system prompt
		reqBody := map[string]interface{}{
			"model": "claude-opus-4-20250514",
			"messages": []map[string]interface{}{
				{"role": "user", "content": "Hello, Claude!"},
			},
		}
		bodyBytes, _ := json.Marshal(reqBody)
		
		req := httptest.NewRequest("POST", "/v1/messages", bytes.NewReader(bodyBytes))
		req.Header.Set("Content-Type", "application/json")
		
		// Execute request
		w := httptest.NewRecorder()
		handler.ServeHTTP(w, req)
		
		// Verify response
		assert.Equal(t, http.StatusOK, w.Code)
		
		var response map[string]interface{}
		err := json.Unmarshal(w.Body.Bytes(), &response)
		require.NoError(t, err)
		assert.Equal(t, "msg_456", response["id"])
	})
}
// End of internal/proxy/handler_test.go

=====================

// File: internal/proxy/models_handler.go

package proxy

import (
	"encoding/json"
	"net/http"
	"time"
)

// ModelsHandler handles /v1/models requests for OpenAI compatibility
type ModelsHandler struct{}

// NewModelsHandler creates a new models handler
func NewModelsHandler() *ModelsHandler {
	return &ModelsHandler{}
}

// ServeHTTP handles the models endpoint
func (h *ModelsHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	// Handle CORS
	if r.Method == "OPTIONS" {
		setCORSHeadersStandalone(w, r)
		w.WriteHeader(http.StatusNoContent)
		return
	}
	
	setCORSHeadersStandalone(w, r)
	
	// Return available models in OpenAI format
	models := map[string]interface{}{
		"object": "list",
		"data": []interface{}{
			map[string]interface{}{
				"id":       "claude-3-opus-20240229",
				"object":   "model",
				"created":  1706745600,
				"owned_by": "anthropic",
				"permission": []interface{}{
					map[string]interface{}{
						"allow_create_engine":  false,
						"allow_fine_tuning":    false,
						"allow_logprobs":       false,
						"allow_sampling":       true,
						"allow_search_indices": false,
						"allow_view":           true,
						"created":              int(time.Now().Unix()),
						"group":                nil,
						"id":                   "modelperm-" + "claude-3-opus",
						"is_blocking":          false,
						"object":               "model_permission",
						"organization":         "*",
					},
				},
			},
			map[string]interface{}{
				"id":       "claude-3-5-sonnet-20241022",
				"object":   "model",
				"created":  1729555200,
				"owned_by": "anthropic",
				"permission": []interface{}{
					map[string]interface{}{
						"allow_create_engine":  false,
						"allow_fine_tuning":    false,
						"allow_logprobs":       false,
						"allow_sampling":       true,
						"allow_search_indices": false,
						"allow_view":           true,
						"created":              int(time.Now().Unix()),
						"group":                nil,
						"id":                   "modelperm-" + "claude-3-5-sonnet",
						"is_blocking":          false,
						"object":               "model_permission",
						"organization":         "*",
					},
				},
			},
			map[string]interface{}{
				"id":       "claude-3-5-haiku-20241022",
				"object":   "model",
				"created":  1729555200,
				"owned_by": "anthropic",
				"permission": []interface{}{
					map[string]interface{}{
						"allow_create_engine":  false,
						"allow_fine_tuning":    false,
						"allow_logprobs":       false,
						"allow_sampling":       true,
						"allow_search_indices": false,
						"allow_view":           true,
						"created":              int(time.Now().Unix()),
						"group":                nil,
						"id":                   "modelperm-" + "claude-3-5-haiku",
						"is_blocking":          false,
						"object":               "model_permission",
						"organization":         "*",
					},
				},
			},
			map[string]interface{}{
				"id":       "claude-opus-4-20250514",
				"object":   "model",
				"created":  1747353600,
				"owned_by": "anthropic",
				"permission": []interface{}{
					map[string]interface{}{
						"allow_create_engine":  false,
						"allow_fine_tuning":    false,
						"allow_logprobs":       false,
						"allow_sampling":       true,
						"allow_search_indices": false,
						"allow_view":           true,
						"created":              int(time.Now().Unix()),
						"group":                nil,
						"id":                   "modelperm-" + "claude-opus-4",
						"is_blocking":          false,
						"object":               "model_permission",
						"organization":         "*",
					},
				},
			},
		},
	}
	
	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(models)
}

// setCORSHeadersStandalone is a standalone CORS header setter
func setCORSHeadersStandalone(w http.ResponseWriter, r *http.Request) {
	origin := r.Header.Get("Origin")
	if origin == "" {
		origin = "*"
	}
	
	w.Header().Set("Access-Control-Allow-Origin", origin)
	w.Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
	w.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization, X-Requested-With")
	w.Header().Set("Access-Control-Allow-Credentials", "true")
	w.Header().Set("Access-Control-Max-Age", "3600")
}
// End of internal/proxy/models_handler.go

=====================

// File: internal/proxy/openai_converter.go

package proxy

import (
	"encoding/json"
	"log/slog"
	"strings"
	"time"
)

// ConvertOpenAIToAnthropic converts OpenAI chat/completions format to Anthropic messages format
func ConvertOpenAIToAnthropic(body []byte) ([]byte, error) {
	var openAIRequest map[string]interface{}
	if err := json.Unmarshal(body, &openAIRequest); err != nil {
		return nil, err
	}
	
	// Create Anthropic format request
	anthropicRequest := make(map[string]interface{})
	
	// Convert model name (remove "anthropic/" prefix if present)
	if model, ok := openAIRequest["model"].(string); ok {
		anthropicRequest["model"] = strings.TrimPrefix(model, "anthropic/")
	}
	
	// Extract system messages and convert messages array
	var systemContents []string
	var anthropicMessages []interface{}
	
	if messages, ok := openAIRequest["messages"].([]interface{}); ok {
		for _, msg := range messages {
			msgMap, ok := msg.(map[string]interface{})
			if !ok {
				continue
			}
			
			role, _ := msgMap["role"].(string)
			
			// Handle content - can be string or array
			var content interface{}
			if msgContent, ok := msgMap["content"]; ok {
				switch v := msgContent.(type) {
				case string:
					content = v
				case []interface{}:
					// Handle structured content array
					content = v
				default:
					continue
				}
			}
			
			if role == "system" {
				// Extract text from system message
				switch v := content.(type) {
				case string:
					systemContents = append(systemContents, v)
				case []interface{}:
					// Handle array of content items
					for _, item := range v {
						if itemMap, ok := item.(map[string]interface{}); ok {
							if itemMap["type"] == "text" {
								if text, ok := itemMap["text"].(string); ok {
									systemContents = append(systemContents, text)
								}
							}
						}
					}
				}
			} else {
				// Convert to Anthropic message format
				anthropicMsg := map[string]interface{}{
					"role":    role,
					"content": content,
				}
				anthropicMessages = append(anthropicMessages, anthropicMsg)
			}
		}
	}
	
	// Set messages
	anthropicRequest["messages"] = anthropicMessages
	
	// Build system field with Claude Code prompt first
	systemArray := []interface{}{
		map[string]interface{}{"type": "text", "text": ClaudeCodePrompt},
	}
	
	// Add extracted system messages
	for _, systemContent := range systemContents {
		systemArray = append(systemArray, map[string]interface{}{
			"type": "text",
			"text": systemContent,
		})
	}
	
	anthropicRequest["system"] = systemArray
	
	// Copy other fields
	for key, value := range openAIRequest {
		if key != "model" && key != "messages" {
			anthropicRequest[key] = value
		}
	}
	
	return json.Marshal(anthropicRequest)
}

// ConvertAnthropicToOpenAI converts Anthropic response format to OpenAI chat/completions format
func ConvertAnthropicToOpenAI(body []byte) ([]byte, error) {
	var anthropicResponse map[string]interface{}
	if err := json.Unmarshal(body, &anthropicResponse); err != nil {
		return nil, err
	}
	
	// Check if this is an error response
	if errorObj, hasError := anthropicResponse["error"]; hasError {
		// Convert Anthropic error to OpenAI error format
		return convertAnthropicErrorToOpenAI(errorObj)
	}
	
	// Create OpenAI format response
	openAIResponse := make(map[string]interface{})
	
	// Copy basic fields
	if id, ok := anthropicResponse["id"].(string); ok {
		openAIResponse["id"] = id
	}
	openAIResponse["object"] = "chat.completion"
	if model, ok := anthropicResponse["model"].(string); ok {
		openAIResponse["model"] = model
	}
	openAIResponse["created"] = int(time.Now().Unix())
	
	// Convert content to OpenAI format
	var messageContent string
	if content, ok := anthropicResponse["content"].([]interface{}); ok {
		for _, item := range content {
			if contentMap, ok := item.(map[string]interface{}); ok {
				if contentMap["type"] == "text" {
					if text, ok := contentMap["text"].(string); ok {
						messageContent += text
					}
				}
			}
		}
	}
	
	// Build choices array
	finishReason := "stop"
	if stopReason, ok := anthropicResponse["stop_reason"].(string); ok {
		switch stopReason {
		case "end_turn":
			finishReason = "stop"
		case "max_tokens":
			finishReason = "length"
		case "stop_sequence":
			finishReason = "stop"
		default:
			finishReason = stopReason
		}
	}
	
	choices := []interface{}{
		map[string]interface{}{
			"index": 0,
			"message": map[string]interface{}{
				"role":    "assistant",
				"content": messageContent,
			},
			"finish_reason": finishReason,
		},
	}
	openAIResponse["choices"] = choices
	
	// Convert usage
	if anthropicUsage, ok := anthropicResponse["usage"].(map[string]interface{}); ok {
		inputTokens := 0
		outputTokens := 0
		
		if val, ok := anthropicUsage["input_tokens"].(float64); ok {
			inputTokens = int(val)
		}
		if val, ok := anthropicUsage["output_tokens"].(float64); ok {
			outputTokens = int(val)
		}
		
		openAIResponse["usage"] = map[string]interface{}{
			"prompt_tokens":     inputTokens,
			"completion_tokens": outputTokens,
			"total_tokens":      inputTokens + outputTokens,
		}
	}
	
	return json.Marshal(openAIResponse)
}

// convertAnthropicErrorToOpenAI converts Anthropic error format to OpenAI error format
func convertAnthropicErrorToOpenAI(errorObj interface{}) ([]byte, error) {
	openAIError := map[string]interface{}{
		"error": map[string]interface{}{
			"message": "",
			"type":    "invalid_request_error",
			"param":   nil,
			"code":    nil,
		},
	}
	
	// Extract error details from Anthropic error
	if errorMap, ok := errorObj.(map[string]interface{}); ok {
		if message, ok := errorMap["message"].(string); ok {
			openAIError["error"].(map[string]interface{})["message"] = message
		}
		
		// Map Anthropic error types to OpenAI error types
		if errorType, ok := errorMap["type"].(string); ok {
			switch errorType {
			case "invalid_request_error":
				openAIError["error"].(map[string]interface{})["type"] = "invalid_request_error"
			case "authentication_error":
				openAIError["error"].(map[string]interface{})["type"] = "authentication_error"
			case "permission_error":
				openAIError["error"].(map[string]interface{})["type"] = "permission_denied"
			case "not_found_error":
				openAIError["error"].(map[string]interface{})["type"] = "not_found_error"
			case "rate_limit_error":
				openAIError["error"].(map[string]interface{})["type"] = "rate_limit_error"
			case "api_error":
				openAIError["error"].(map[string]interface{})["type"] = "server_error"
			default:
				openAIError["error"].(map[string]interface{})["type"] = errorType
			}
		}
	}
	
	return json.Marshal(openAIError)
}

// toolState tracks tool use information across SSE events
// Key is Anthropic content block index, value contains tool info and OpenAI tool index
var toolState = make(map[int]map[string]interface{})

// toolCallIndex tracks the next available OpenAI tool call index
var toolCallIndex = 0

// ResetSSEConverterState resets the converter state (useful for testing)
func ResetSSEConverterState() {
	toolState = make(map[int]map[string]interface{})
	toolCallIndex = 0
}

// ConvertAnthropicSSEToOpenAI converts a single Anthropic SSE event to OpenAI format
func ConvertAnthropicSSEToOpenAI(event, data string, messageID string, model string, created int64) (string, error) {
	return ConvertAnthropicSSEToOpenAIWithLogger(event, data, messageID, model, created, nil)
}

// ConvertAnthropicSSEToOpenAIWithLogger converts a single Anthropic SSE event to OpenAI format with optional logging
func ConvertAnthropicSSEToOpenAIWithLogger(event, data string, messageID string, model string, created int64, logger *slog.Logger) (string, error) {
	// Parse the data as JSON
	var eventData map[string]interface{}
	if err := json.Unmarshal([]byte(data), &eventData); err != nil {
		return "", err
	}
	
	eventType, _ := eventData["type"].(string)
	
	switch eventType {
	case "message_start":
		// Reset tool call index for new message
		toolCallIndex = 0
		
		// Convert message_start to initial OpenAI chunk
		chunk := map[string]interface{}{
			"id":      messageID,
			"object":  "chat.completion.chunk",
			"created": created,
			"model":   model,
			"choices": []interface{}{
				map[string]interface{}{
					"index": 0,
					"delta": map[string]interface{}{
						"role": "assistant",
					},
					"finish_reason": nil,
				},
			},
		}
		chunkJSON, _ := json.Marshal(chunk)
		return "data: " + string(chunkJSON) + "\n\n", nil
		
	case "content_block_start":
		// Check if this is a tool use block
		if contentBlock, ok := eventData["content_block"].(map[string]interface{}); ok {
			if contentBlock["type"] == "tool_use" {
				// Extract tool information
				index := int(eventData["index"].(float64))
				toolID, _ := contentBlock["id"].(string)
				toolName, _ := contentBlock["name"].(string)
				
				// Store tool info for this index with OpenAI tool index
				currentToolIndex := toolCallIndex
				toolState[index] = map[string]interface{}{
					"id":        toolID,
					"name":      toolName,
					"toolIndex": currentToolIndex,
				}
				toolCallIndex++
				
				// Send initial tool call chunk
				chunk := map[string]interface{}{
					"id":      messageID,
					"object":  "chat.completion.chunk",
					"created": created,
					"model":   model,
					"choices": []interface{}{
						map[string]interface{}{
							"index": 0,
							"delta": map[string]interface{}{
								"tool_calls": []interface{}{
									map[string]interface{}{
										"index": currentToolIndex,
										"id":    toolID,
										"type":  "function",
										"function": map[string]interface{}{
											"name":      toolName,
											"arguments": "",
										},
									},
								},
							},
							"finish_reason": nil,
						},
					},
				}
				chunkJSON, _ := json.Marshal(chunk)
				return "data: " + string(chunkJSON) + "\n\n", nil
			}
		}
		// For non-tool blocks, return empty to skip
		return "", nil
		
	case "content_block_stop":
		// Clear tool state for the completed block if it was a tool block
		if eventData["index"] != nil {
			index := int(eventData["index"].(float64))
			if _, exists := toolState[index]; exists {
				delete(toolState, index)
				if logger != nil {
					logger.Debug("completed tool use block", "index", index)
				}
			}
		}
		// No output for content_block_stop
		return "", nil
		
	case "content_block_delta":
		// Convert content delta to OpenAI chunk
		if delta, ok := eventData["delta"].(map[string]interface{}); ok {
			if delta["type"] == "text_delta" {
				if text, ok := delta["text"].(string); ok {
					chunk := map[string]interface{}{
						"id":      messageID,
						"object":  "chat.completion.chunk",
						"created": created,
						"model":   model,
						"choices": []interface{}{
							map[string]interface{}{
								"index": 0,
								"delta": map[string]interface{}{
									"content": text,
								},
								"finish_reason": nil,
							},
						},
					}
					chunkJSON, _ := json.Marshal(chunk)
					return "data: " + string(chunkJSON) + "\n\n", nil
				}
			} else if delta["type"] == "input_json_delta" {
				// Handle tool use deltas
				if partialJSON, ok := delta["partial_json"].(string); ok {
					// Get the content block index
					blockIndex := int(eventData["index"].(float64))
					
					// Look up the tool info for this block
					if toolInfo, exists := toolState[blockIndex]; exists {
						toolIndex := toolInfo["toolIndex"].(int)
						toolID := toolInfo["id"].(string)
						
						// Create tool delta chunk with tool ID
						chunk := map[string]interface{}{
							"id":      messageID,
							"object":  "chat.completion.chunk",
							"created": created,
							"model":   model,
							"choices": []interface{}{
								map[string]interface{}{
									"index": 0,
									"delta": map[string]interface{}{
										"tool_calls": []interface{}{
											map[string]interface{}{
												"index": toolIndex,
												"id":    toolID,
												"function": map[string]interface{}{
													"arguments": partialJSON,
												},
											},
										},
									},
									"finish_reason": nil,
								},
							},
						}
						chunkJSON, _ := json.Marshal(chunk)
						return "data: " + string(chunkJSON) + "\n\n", nil
					}
				}
			}
		}
		
	case "message_stop":
		// Send final chunk with finish_reason
		// Note: [DONE] marker should be sent separately by the stream handler
		chunk := map[string]interface{}{
			"id":      messageID,
			"object":  "chat.completion.chunk",
			"created": created,
			"model":   model,
			"choices": []interface{}{
				map[string]interface{}{
					"index":         0,
					"delta":         map[string]interface{}{},
					"finish_reason": "stop",
				},
			},
		}
		chunkJSON, _ := json.Marshal(chunk)
		return "data: " + string(chunkJSON) + "\n\n", nil
		
	case "message_delta":
		// Handle stop reasons from message_delta
		if delta, ok := eventData["delta"].(map[string]interface{}); ok {
			if stopReason, ok := delta["stop_reason"].(string); ok {
				finishReason := "stop"
				if stopReason == "max_tokens" {
					finishReason = "length"
				}
				
				chunk := map[string]interface{}{
					"id":      messageID,
					"object":  "chat.completion.chunk",
					"created": created,
					"model":   model,
					"choices": []interface{}{
						map[string]interface{}{
							"index":         0,
							"delta":         map[string]interface{}{},
							"finish_reason": finishReason,
						},
					},
				}
				chunkJSON, _ := json.Marshal(chunk)
				return "data: " + string(chunkJSON) + "\n\n", nil
			}
		}
		
	default:
		// Log unhandled event types for debugging
		if logger != nil {
			logger.Debug("unhandled SSE event type",
				"event", event,
				"type", eventType,
				"data", data,
			)
		}
	}
	
	// Skip other event types
	return "", nil
}
// End of internal/proxy/openai_converter.go

=====================

// File: internal/proxy/openai_converter_test.go

package proxy

import (
	"encoding/json"
	"fmt"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestConvertOpenAIToAnthropic(t *testing.T) {
	t.Run("should convert OpenAI format with system message to Anthropic format", func(t *testing.T) {
		// Arrange
		openAIRequest := map[string]interface{}{
			"model": "anthropic/claude-opus-4-20250514",
			"messages": []interface{}{
				map[string]interface{}{
					"role":    "system",
					"content": "You are a helpful assistant.",
				},
				map[string]interface{}{
					"role":    "user",
					"content": "Hello, how are you?",
				},
			},
			"max_tokens":  100,
			"temperature": 0.7,
			"stream":      false,
		}
		
		requestBody, err := json.Marshal(openAIRequest)
		require.NoError(t, err)
		
		// Act
		result, err := ConvertOpenAIToAnthropic(requestBody)
		
		// Assert
		require.NoError(t, err)
		
		var anthropicRequest map[string]interface{}
		err = json.Unmarshal(result, &anthropicRequest)
		require.NoError(t, err)
		
		// Check model name (prefix removed)
		assert.Equal(t, "claude-opus-4-20250514", anthropicRequest["model"])
		
		// Check system field (should include Claude Code prompt + original system)
		expectedSystem := []interface{}{
			map[string]interface{}{"type": "text", "text": ClaudeCodePrompt},
			map[string]interface{}{"type": "text", "text": "You are a helpful assistant."},
		}
		assert.Equal(t, expectedSystem, anthropicRequest["system"])
		
		// Check messages (system message removed)
		messages := anthropicRequest["messages"].([]interface{})
		assert.Len(t, messages, 1)
		assert.Equal(t, "user", messages[0].(map[string]interface{})["role"])
		assert.Equal(t, "Hello, how are you?", messages[0].(map[string]interface{})["content"])
		
		// Check other fields preserved
		assert.Equal(t, float64(100), anthropicRequest["max_tokens"])
		assert.Equal(t, 0.7, anthropicRequest["temperature"])
		assert.Equal(t, false, anthropicRequest["stream"])
	})
	
	t.Run("should handle OpenAI format without system message", func(t *testing.T) {
		// Arrange
		openAIRequest := map[string]interface{}{
			"model": "claude-3-opus-20240229",
			"messages": []interface{}{
				map[string]interface{}{
					"role":    "user",
					"content": "What is the weather today?",
				},
			},
			"max_tokens": 50,
		}
		
		requestBody, err := json.Marshal(openAIRequest)
		require.NoError(t, err)
		
		// Act
		result, err := ConvertOpenAIToAnthropic(requestBody)
		
		// Assert
		require.NoError(t, err)
		
		var anthropicRequest map[string]interface{}
		err = json.Unmarshal(result, &anthropicRequest)
		require.NoError(t, err)
		
		// Check system field (should only have Claude Code prompt)
		expectedSystem := []interface{}{
			map[string]interface{}{"type": "text", "text": ClaudeCodePrompt},
		}
		assert.Equal(t, expectedSystem, anthropicRequest["system"])
		
		// Check messages remain unchanged
		messages := anthropicRequest["messages"].([]interface{})
		assert.Len(t, messages, 1)
		assert.Equal(t, "user", messages[0].(map[string]interface{})["role"])
		assert.Equal(t, "What is the weather today?", messages[0].(map[string]interface{})["content"])
	})
	
	t.Run("should remove anthropic/ prefix from model names", func(t *testing.T) {
		// Arrange
		openAIRequest := map[string]interface{}{
			"model": "anthropic/claude-3-5-sonnet-20241022",
			"messages": []interface{}{
				map[string]interface{}{
					"role":    "user",
					"content": "Hello",
				},
			},
		}
		
		requestBody, err := json.Marshal(openAIRequest)
		require.NoError(t, err)
		
		// Act
		result, err := ConvertOpenAIToAnthropic(requestBody)
		
		// Assert
		require.NoError(t, err)
		
		var anthropicRequest map[string]interface{}
		err = json.Unmarshal(result, &anthropicRequest)
		require.NoError(t, err)
		
		assert.Equal(t, "claude-3-5-sonnet-20241022", anthropicRequest["model"])
	})
	
	t.Run("should handle multiple system messages by concatenating them", func(t *testing.T) {
		// Arrange
		openAIRequest := map[string]interface{}{
			"model": "claude-3-opus-20240229",
			"messages": []interface{}{
				map[string]interface{}{
					"role":    "system",
					"content": "You are a helpful assistant.",
				},
				map[string]interface{}{
					"role":    "system",
					"content": "Always be polite and professional.",
				},
				map[string]interface{}{
					"role":    "user",
					"content": "Hello",
				},
			},
		}
		
		requestBody, err := json.Marshal(openAIRequest)
		require.NoError(t, err)
		
		// Act
		result, err := ConvertOpenAIToAnthropic(requestBody)
		
		// Assert
		require.NoError(t, err)
		
		var anthropicRequest map[string]interface{}
		err = json.Unmarshal(result, &anthropicRequest)
		require.NoError(t, err)
		
		// Check system field has all system messages
		expectedSystem := []interface{}{
			map[string]interface{}{"type": "text", "text": ClaudeCodePrompt},
			map[string]interface{}{"type": "text", "text": "You are a helpful assistant."},
			map[string]interface{}{"type": "text", "text": "Always be polite and professional."},
		}
		assert.Equal(t, expectedSystem, anthropicRequest["system"])
		
		// Check only user message remains in messages
		messages := anthropicRequest["messages"].([]interface{})
		assert.Len(t, messages, 1)
		assert.Equal(t, "user", messages[0].(map[string]interface{})["role"])
	})
	
	t.Run("should handle complex content format from Cursor", func(t *testing.T) {
		// Arrange - mimicking Cursor's actual request format
		openAIRequest := map[string]interface{}{
			"model": "anthropic/claude-3-5-sonnet-20241022",
			"messages": []interface{}{
				map[string]interface{}{
					"role": "system",
					"content": []interface{}{
						map[string]interface{}{
							"type": "text",
							"text": "You are an AI programming assistant.",
							"cache_control": map[string]interface{}{
								"type": "ephemeral",
							},
						},
					},
				},
				map[string]interface{}{
					"role": "user",
					"content": []interface{}{
						map[string]interface{}{
							"type": "text",
							"text": "Please help me fix this code",
						},
					},
				},
				map[string]interface{}{
					"role": "assistant",
					"content": []interface{}{
						map[string]interface{}{
							"type": "text",
							"text": "I'll help you fix the code.",
						},
					},
				},
			},
			"max_tokens": 4096,
			"temperature": 0.2,
			"tools": []interface{}{
				map[string]interface{}{
					"type": "function",
					"function": map[string]interface{}{
						"name": "str_replace_editor",
						"description": "Replace text in a file",
					},
				},
			},
		}
		
		requestBody, err := json.Marshal(openAIRequest)
		require.NoError(t, err)
		
		// Act
		result, err := ConvertOpenAIToAnthropic(requestBody)
		
		// Assert
		require.NoError(t, err)
		
		var anthropicRequest map[string]interface{}
		err = json.Unmarshal(result, &anthropicRequest)
		require.NoError(t, err)
		
		// Check model name (prefix removed)
		assert.Equal(t, "claude-3-5-sonnet-20241022", anthropicRequest["model"])
		
		// Check system field extracted correctly
		expectedSystem := []interface{}{
			map[string]interface{}{"type": "text", "text": ClaudeCodePrompt},
			map[string]interface{}{"type": "text", "text": "You are an AI programming assistant."},
		}
		assert.Equal(t, expectedSystem, anthropicRequest["system"])
		
		// Check messages preserved structured content
		messages := anthropicRequest["messages"].([]interface{})
		assert.Len(t, messages, 2) // user and assistant messages
		
		// Check user message
		userMsg := messages[0].(map[string]interface{})
		assert.Equal(t, "user", userMsg["role"])
		userContent := userMsg["content"].([]interface{})
		assert.Equal(t, "text", userContent[0].(map[string]interface{})["type"])
		assert.Equal(t, "Please help me fix this code", userContent[0].(map[string]interface{})["text"])
		
		// Check assistant message
		assistantMsg := messages[1].(map[string]interface{})
		assert.Equal(t, "assistant", assistantMsg["role"])
		
		// Check tools are preserved
		assert.Equal(t, openAIRequest["tools"], anthropicRequest["tools"])
	})
}

func TestConvertAnthropicToOpenAI(t *testing.T) {
	t.Run("should convert Anthropic response to OpenAI format", func(t *testing.T) {
		// Arrange
		anthropicResponse := map[string]interface{}{
			"id":      "msg_123",
			"type":    "message",
			"role":    "assistant",
			"content": []interface{}{
				map[string]interface{}{
					"type": "text",
					"text": "Hello! How can I help you today?",
				},
			},
			"model":         "claude-3-opus-20240229",
			"stop_reason":   "end_turn",
			"stop_sequence": nil,
			"usage": map[string]interface{}{
				"input_tokens":  10,
				"output_tokens": 20,
			},
		}
		
		responseBody, err := json.Marshal(anthropicResponse)
		require.NoError(t, err)
		
		// Act
		result, err := ConvertAnthropicToOpenAI(responseBody)
		
		// Assert
		require.NoError(t, err)
		
		var openAIResponse map[string]interface{}
		err = json.Unmarshal(result, &openAIResponse)
		require.NoError(t, err)
		
		// Check OpenAI format fields
		assert.Equal(t, "msg_123", openAIResponse["id"])
		assert.Equal(t, "chat.completion", openAIResponse["object"])
		assert.Equal(t, "claude-3-opus-20240229", openAIResponse["model"])
		
		// Check choices array
		choices := openAIResponse["choices"].([]interface{})
		assert.Len(t, choices, 1)
		
		choice := choices[0].(map[string]interface{})
		assert.Equal(t, float64(0), choice["index"])
		assert.Equal(t, "stop", choice["finish_reason"])
		
		// Check message in choice
		message := choice["message"].(map[string]interface{})
		assert.Equal(t, "assistant", message["role"])
		assert.Equal(t, "Hello! How can I help you today?", message["content"])
		
		// Check usage
		usage := openAIResponse["usage"].(map[string]interface{})
		assert.Equal(t, float64(10), usage["prompt_tokens"])
		assert.Equal(t, float64(20), usage["completion_tokens"])
		assert.Equal(t, float64(30), usage["total_tokens"])
	})
	
	t.Run("should convert Anthropic error response to OpenAI format", func(t *testing.T) {
		// Arrange
		anthropicError := map[string]interface{}{
			"error": map[string]interface{}{
				"type":    "invalid_request_error",
				"message": "messages: at least one message is required",
			},
		}
		
		errorBody, err := json.Marshal(anthropicError)
		require.NoError(t, err)
		
		// Act
		result, err := ConvertAnthropicToOpenAI(errorBody)
		
		// Assert
		require.NoError(t, err)
		
		var openAIError map[string]interface{}
		err = json.Unmarshal(result, &openAIError)
		require.NoError(t, err)
		
		// Check error format
		errorObj := openAIError["error"].(map[string]interface{})
		assert.Equal(t, "messages: at least one message is required", errorObj["message"])
		assert.Equal(t, "invalid_request_error", errorObj["type"])
		assert.Nil(t, errorObj["param"])
		assert.Nil(t, errorObj["code"])
	})
}

func TestConvertAnthropicSSEToOpenAI(t *testing.T) {
	messageID := "chatcmpl-test123"
	model := "claude-3-opus-20240229"
	created := int64(1719331200)
	
	t.Run("should convert message_start event", func(t *testing.T) {
		// Arrange
		event := "message_start"
		data := `{"type":"message_start","message":{"id":"msg_123","type":"message","role":"assistant","model":"claude-3-opus-20240229","content":[],"stop_reason":null}}`
		
		// Act
		result, err := ConvertAnthropicSSEToOpenAI(event, data, messageID, model, created)
		
		// Assert
		require.NoError(t, err)
		assert.Contains(t, result, "data: ")
		assert.Contains(t, result, `"object":"chat.completion.chunk"`)
		assert.Contains(t, result, `"role":"assistant"`)
		assert.Contains(t, result, messageID)
	})
	
	t.Run("should convert content_block_delta event", func(t *testing.T) {
		// Arrange
		event := "content_block_delta"
		data := `{"type":"content_block_delta","index":0,"delta":{"type":"text_delta","text":"Hello world"}}`
		
		// Act
		result, err := ConvertAnthropicSSEToOpenAI(event, data, messageID, model, created)
		
		// Assert
		require.NoError(t, err)
		assert.Contains(t, result, "data: ")
		assert.Contains(t, result, `"content":"Hello world"`)
		assert.Contains(t, result, `"finish_reason":null`)
	})
	
	t.Run("should convert message_stop event without DONE", func(t *testing.T) {
		// Arrange
		event := "message_stop"
		data := `{"type":"message_stop"}`
		
		// Act
		result, err := ConvertAnthropicSSEToOpenAI(event, data, messageID, model, created)
		
		// Assert
		require.NoError(t, err)
		assert.Contains(t, result, "data: ")
		assert.Contains(t, result, `"finish_reason":"stop"`)
		assert.NotContains(t, result, "[DONE]") // DONE should be sent separately
	})
	
	t.Run("should convert message_delta with stop reason", func(t *testing.T) {
		// Arrange
		event := "message_delta"
		data := `{"type":"message_delta","delta":{"stop_reason":"max_tokens"}}`
		
		// Act
		result, err := ConvertAnthropicSSEToOpenAI(event, data, messageID, model, created)
		
		// Assert
		require.NoError(t, err)
		assert.Contains(t, result, "data: ")
		assert.Contains(t, result, `"finish_reason":"length"`)
	})
	
	t.Run("should skip unhandled events", func(t *testing.T) {
		// Arrange
		event := "ping"
		data := `{"type":"ping"}`
		
		// Act
		result, err := ConvertAnthropicSSEToOpenAI(event, data, messageID, model, created)
		
		// Assert
		require.NoError(t, err)
		assert.Empty(t, result)
	})
	
	t.Run("should convert input_json_delta events to OpenAI tool format", func(t *testing.T) {
		// Reset state
		ResetSSEConverterState()
		
		// First set up a tool
		startEvent := "content_block_start"
		startData := `{"type":"content_block_start","index":1,"content_block":{"type":"tool_use","id":"toolu_123","name":"get_weather"}}`
		_, err := ConvertAnthropicSSEToOpenAI(startEvent, startData, messageID, model, created)
		require.NoError(t, err)
		
		// Arrange
		event := "content_block_delta"
		data := `{"type":"content_block_delta","index":1,"delta":{"type":"input_json_delta","partial_json":"{\"location\": \"San Fra"}}`
		
		// Act
		result, err := ConvertAnthropicSSEToOpenAI(event, data, messageID, model, created)
		
		// Assert
		require.NoError(t, err)
		assert.Contains(t, result, "data: ")
		assert.Contains(t, result, `"tool_calls"`)
		assert.Contains(t, result, `"function"`)
		assert.Contains(t, result, `"arguments":"{\"location\": \"San Fra"`)
	})
	
	t.Run("should handle content_block_start for tool_use", func(t *testing.T) {
		// Reset state
		ResetSSEConverterState()
		
		// Arrange
		event := "content_block_start"
		data := `{"type":"content_block_start","index":1,"content_block":{"type":"tool_use","id":"toolu_123","name":"get_weather"}}`
		
		// Act
		result, err := ConvertAnthropicSSEToOpenAI(event, data, messageID, model, created)
		
		// Assert
		require.NoError(t, err)
		assert.Contains(t, result, "data: ")
		assert.Contains(t, result, `"tool_calls"`)
		assert.Contains(t, result, `"id":"toolu_123"`)
		assert.Contains(t, result, `"type":"function"`)
		assert.Contains(t, result, `"name":"get_weather"`)
	})
	
	t.Run("should handle empty tool input gracefully", func(t *testing.T) {
		// Reset state
		ResetSSEConverterState()
		
		// First set up a tool
		startEvent := "content_block_start"
		startData := `{"type":"content_block_start","index":1,"content_block":{"type":"tool_use","id":"toolu_empty","name":"test_tool"}}`
		_, err := ConvertAnthropicSSEToOpenAI(startEvent, startData, messageID, model, created)
		require.NoError(t, err)
		
		// Arrange
		event := "content_block_delta"
		data := `{"type":"content_block_delta","index":1,"delta":{"type":"input_json_delta","partial_json":""}}`
		
		// Act
		result, err := ConvertAnthropicSSEToOpenAI(event, data, messageID, model, created)
		
		// Assert
		require.NoError(t, err)
		assert.Contains(t, result, "data: ")
		assert.Contains(t, result, `"arguments":""`)
	})
	
	t.Run("should handle multiple tool deltas in sequence", func(t *testing.T) {
		// Reset state
		ResetSSEConverterState()
		
		// Arrange - simulating a sequence of tool use events
		events := []struct {
			event string
			data  string
		}{
			{
				event: "content_block_start",
				data:  `{"type":"content_block_start","index":1,"content_block":{"type":"tool_use","id":"toolu_456","name":"calculate"}}`,
			},
			{
				event: "content_block_delta",
				data:  `{"type":"content_block_delta","index":1,"delta":{"type":"input_json_delta","partial_json":"{\"operation\": \"add\","}}`,
			},
			{
				event: "content_block_delta",
				data:  `{"type":"content_block_delta","index":1,"delta":{"type":"input_json_delta","partial_json":" \"a\": 5, \"b\": 3}"}}`,
			},
		}
		
		// Act & Assert - each event should produce valid output
		for _, tc := range events {
			result, err := ConvertAnthropicSSEToOpenAI(tc.event, tc.data, messageID, model, created)
			require.NoError(t, err)
			assert.NotEmpty(t, result)
			assert.Contains(t, result, "data: ")
		}
	})
	
	t.Run("should include tool ID in input_json_delta events", func(t *testing.T) {
		// Reset state
		ResetSSEConverterState()
		
		// Arrange - first set up a tool
		startEvent := "content_block_start"
		startData := `{"type":"content_block_start","index":1,"content_block":{"type":"tool_use","id":"toolu_789","name":"search"}}`
		
		// Start the tool
		_, err := ConvertAnthropicSSEToOpenAI(startEvent, startData, messageID, model, created)
		require.NoError(t, err)
		
		// Now send a delta
		deltaEvent := "content_block_delta"
		deltaData := `{"type":"content_block_delta","index":1,"delta":{"type":"input_json_delta","partial_json":"{\"query\": \"test\""}}`
		
		// Act
		result, err := ConvertAnthropicSSEToOpenAI(deltaEvent, deltaData, messageID, model, created)
		
		// Assert - the delta should include the tool ID
		require.NoError(t, err)
		assert.Contains(t, result, "data: ")
		assert.Contains(t, result, `"id":"toolu_789"`) // Tool ID should be included
		assert.Contains(t, result, `"arguments":"{\"query\": \"test\""`)
	})
	
	t.Run("should handle multiple tools with correct indices", func(t *testing.T) {
		// Reset state
		ResetSSEConverterState()
		
		// Arrange - simulate multiple tools
		events := []struct {
			event       string
			data        string
			wantToolIdx int // Expected OpenAI tool index
		}{
			{
				event:       "content_block_start",
				data:        `{"type":"content_block_start","index":0,"content_block":{"type":"text","text":""}}`,
				wantToolIdx: -1, // Not a tool
			},
			{
				event:       "content_block_start",
				data:        `{"type":"content_block_start","index":1,"content_block":{"type":"tool_use","id":"toolu_001","name":"first_tool"}}`,
				wantToolIdx: 0, // First tool should be index 0
			},
			{
				event:       "content_block_start",
				data:        `{"type":"content_block_start","index":2,"content_block":{"type":"tool_use","id":"toolu_002","name":"second_tool"}}`,
				wantToolIdx: 1, // Second tool should be index 1
			},
		}
		
		// Act & Assert
		for _, tc := range events {
			result, err := ConvertAnthropicSSEToOpenAI(tc.event, tc.data, messageID, model, created)
			require.NoError(t, err)
			
			if tc.wantToolIdx >= 0 {
				// For tool blocks, check the index
				assert.Contains(t, result, fmt.Sprintf(`"index":%d`, tc.wantToolIdx))
			}
		}
	})
}
// End of internal/proxy/openai_converter_test.go

=====================

// File: internal/proxy/server_enhanced.go

package proxy

import (
	"fmt"
	"net/http"
	"time"
	
	"github.com/ml0-1337/claude-gate/internal/auth"
	"github.com/ml0-1337/claude-gate/internal/ui/dashboard"
)

// EnhancedProxyServer extends ProxyServer with dashboard functionality
type EnhancedProxyServer struct {
	*ProxyServer
	dashboard *dashboard.Model
}

// NewEnhancedProxyServer creates a proxy server with dashboard
func NewEnhancedProxyServer(config *ProxyConfig, address string, storage auth.StorageBackend) *EnhancedProxyServer {
	// Create base proxy server components
	handler := NewProxyHandler(config)
	healthHandler := NewHealthHandler(storage)
	
	// Create dashboard
	dashboardModel := dashboard.New(fmt.Sprintf("http://%s", address))
	
	// Create middleware that logs to dashboard
	middleware := &dashboardMiddleware{
		handler:   CreateMux(handler, healthHandler),
		dashboard: dashboardModel,
	}
	
	// Create enhanced server
	server := &http.Server{
		Addr:         address,
		Handler:      middleware,
		ReadTimeout:  time.Minute,
		WriteTimeout: 10 * time.Minute, // Long timeout for streaming
	}
	
	return &EnhancedProxyServer{
		ProxyServer: &ProxyServer{
			handler: handler,
			server:  server,
		},
		dashboard: dashboardModel,
	}
}

// GetDashboard returns the dashboard model
func (s *EnhancedProxyServer) GetDashboard() *dashboard.Model {
	return s.dashboard
}

// dashboardMiddleware logs requests to the dashboard
type dashboardMiddleware struct {
	handler   http.Handler
	dashboard *dashboard.Model
}

func (m *dashboardMiddleware) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	// Skip health checks and root endpoint
	if r.URL.Path == "/health" || r.URL.Path == "/" {
		m.handler.ServeHTTP(w, r)
		return
	}
	
	// Create a response writer wrapper to capture status and size
	rw := &responseWriter{
		ResponseWriter: w,
		statusCode:     http.StatusOK,
	}
	
	start := time.Now()
	
	// Serve the request
	m.handler.ServeHTTP(rw, r)
	
	// Log to dashboard
	duration := time.Since(start)
	event := dashboard.RequestEvent{
		Method:     r.Method,
		Path:       r.URL.Path,
		StatusCode: rw.statusCode,
		Duration:   duration,
		Timestamp:  start,
		Size:       rw.written,
	}
	
	m.dashboard.SendEvent(event)
}

// responseWriter wraps http.ResponseWriter to capture response details
type responseWriter struct {
	http.ResponseWriter
	statusCode int
	written    int64
}

func (rw *responseWriter) WriteHeader(code int) {
	rw.statusCode = code
	rw.ResponseWriter.WriteHeader(code)
}

func (rw *responseWriter) Write(b []byte) (int, error) {
	n, err := rw.ResponseWriter.Write(b)
	rw.written += int64(n)
	return n, err
}
// End of internal/proxy/server_enhanced.go

=====================

// File: internal/proxy/server.go

package proxy

import (
	"encoding/json"
	"net/http"
	
	"github.com/ml0-1337/claude-gate/internal/auth"
)

// HealthHandler handles health check requests
type HealthHandler struct {
	storage auth.StorageBackend
}

// NewHealthHandler creates a new health handler
func NewHealthHandler(storage auth.StorageBackend) *HealthHandler {
	return &HealthHandler{
		storage: storage,
	}
}

func (h *HealthHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	// Check OAuth status
	oauthStatus := "not_configured"
	if token, err := h.storage.Get("anthropic"); err == nil && token != nil {
		if token.Type == "oauth" {
			oauthStatus = "ready"
		}
	}
	
	response := map[string]interface{}{
		"status":       "healthy",
		"oauth_status": oauthStatus,
		"proxy_auth":   "disabled", // TODO: get from config
	}
	
	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(response)
}

// RootHandler handles the root endpoint
type RootHandler struct{}

func (h *RootHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	response := map[string]interface{}{
		"service":     "Claude OAuth Proxy",
		"description": "Anthropic API proxy with OAuth authentication injection",
		"endpoints": map[string]interface{}{
			"health":       "/health",
			"anthropic_api": "/*",
		},
		"oauth_required": true,
		"proxy_auth": "disabled", // TODO: get from config
	}
	
	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(response)
}

// CreateMux creates the HTTP mux with all routes
func CreateMux(proxyHandler http.Handler, healthHandler http.Handler) http.Handler {
	mux := http.NewServeMux()
	
	// Health check endpoint
	mux.Handle("/health", healthHandler)
	
	// Root endpoint
	mux.Handle("/", &RootHandler{})
	
	// Models endpoint for OpenAI compatibility
	mux.Handle("/v1/models", NewModelsHandler())
	
	// All other paths go to the proxy
	mux.Handle("/v1/", proxyHandler)
	
	return mux
}
// End of internal/proxy/server.go

=====================

// File: internal/proxy/transformer.go

package proxy

import (
	"encoding/json"
	"fmt"
	"net/http"
)

const (
	// ClaudeCodePrompt is the required system prompt for OAuth authentication
	ClaudeCodePrompt = "You are Claude Code, Anthropic's official CLI for Claude."
)

// ModelAliases maps model aliases to their full names for OAuth compatibility
var ModelAliases = map[string]string{
	"claude-3-5-haiku-latest":  "claude-3-5-haiku-20241022",
	"claude-3-5-sonnet-latest": "claude-3-5-sonnet-20241022",
	"claude-3-7-sonnet-latest": "claude-3-7-sonnet-20250219",
	"claude-3-opus-latest":     "claude-3-opus-20240229",
}

// RequestTransformer handles request body and header transformations
type RequestTransformer struct{}

// NewRequestTransformer creates a new request transformer
func NewRequestTransformer() *RequestTransformer {
	return &RequestTransformer{}
}

// TransformSystemPrompt modifies the system prompt to ensure Claude Code identification comes first
func (t *RequestTransformer) TransformSystemPrompt(body []byte) ([]byte, error) {
	var data map[string]interface{}
	if err := json.Unmarshal(body, &data); err != nil {
		return body, nil // Return original if not JSON
	}
	
	// Check if request has a system prompt
	systemRaw, hasSystem := data["system"]
	if !hasSystem {
		// No system prompt, inject Claude Code identification
		data["system"] = ClaudeCodePrompt
		return json.Marshal(data)
	}
	
	switch system := systemRaw.(type) {
	case string:
		// Handle string system prompt
		if system == ClaudeCodePrompt {
			// Already correct, leave as-is
			return body, nil
		}
		// Convert to array with Claude Code first
		data["system"] = []interface{}{
			map[string]interface{}{"type": "text", "text": ClaudeCodePrompt},
			map[string]interface{}{"type": "text", "text": system},
		}
		
	case []interface{}:
		// Handle array system prompt
		if len(system) > 0 {
			// Check if first element has correct text
			if first, ok := system[0].(map[string]interface{}); ok {
				if text, ok := first["text"].(string); ok && text == ClaudeCodePrompt {
					// Already has Claude Code first, return as-is
					return body, nil
				}
			}
		}
		// Prepend Claude Code identification
		newSystem := []interface{}{
			map[string]interface{}{"type": "text", "text": ClaudeCodePrompt},
		}
		data["system"] = append(newSystem, system...)
	}
	
	// Re-marshal the modified data
	return json.Marshal(data)
}

// MapModelAlias maps model aliases to their full names
func (t *RequestTransformer) MapModelAlias(model string) string {
	if mapped, exists := ModelAliases[model]; exists {
		return mapped
	}
	return model
}

// TransformRequestBody applies all necessary transformations to the request body
func (t *RequestTransformer) TransformRequestBody(body []byte, path string) ([]byte, error) {
	// Handle OpenAI chat completions endpoint
	if path == "/v1/chat/completions" {
		// Convert OpenAI format to Anthropic format
		convertedBody, err := ConvertOpenAIToAnthropic(body)
		if err != nil {
			return nil, fmt.Errorf("failed to convert OpenAI format: %w", err)
		}
		
		// Apply standard transformations to the converted body
		return t.TransformRequestBody(convertedBody, "/v1/messages")
	}
	
	// Only transform messages endpoint
	if path != "/v1/messages" {
		return body, nil
	}
	
	var data map[string]interface{}
	if err := json.Unmarshal(body, &data); err != nil {
		return body, nil // Return original if not JSON
	}
	
	// Transform system prompt
	modifiedBody, err := t.TransformSystemPrompt(body)
	if err != nil {
		return nil, fmt.Errorf("failed to transform system prompt: %w", err)
	}
	
	// Re-unmarshal to apply model mapping
	if err := json.Unmarshal(modifiedBody, &data); err != nil {
		return modifiedBody, nil
	}
	
	// Map model alias if present
	if model, ok := data["model"].(string); ok {
		data["model"] = t.MapModelAlias(model)
	}
	
	return json.Marshal(data)
}

// InjectHeaders creates new headers with OAuth authentication and strips problematic ones
func (t *RequestTransformer) InjectHeaders(headers map[string][]string, accessToken string) http.Header {
	// Create fresh headers with only necessary ones
	newHeaders := http.Header{}
	newHeaders.Set("Authorization", fmt.Sprintf("Bearer %s", accessToken))
	newHeaders.Set("anthropic-beta", "oauth-2025-04-20")
	newHeaders.Set("anthropic-version", "2023-06-01")
	
	// Preserve content headers with defaults
	if contentType := getHeader(headers, "Content-Type"); contentType != "" {
		newHeaders.Set("Content-Type", contentType)
	} else {
		newHeaders.Set("Content-Type", "application/json")
	}
	
	if accept := getHeader(headers, "Accept"); accept != "" {
		newHeaders.Set("Accept", accept)
	} else {
		newHeaders.Set("Accept", "*/*")
	}
	
	// Preserve Connection header for proper SSE handling
	if connection := getHeader(headers, "Connection"); connection != "" {
		newHeaders.Set("Connection", connection)
	}
	
	// Preserve cache control headers for SSE
	if cacheControl := getHeader(headers, "Cache-Control"); cacheControl != "" {
		newHeaders.Set("Cache-Control", cacheControl)
	}
	
	return newHeaders
}

// getHeader performs case-insensitive header lookup
func getHeader(headers map[string][]string, key string) string {
	// Direct lookup
	if values, ok := headers[key]; ok && len(values) > 0 {
		return values[0]
	}
	
	// Case-insensitive lookup
	for k, v := range headers {
		if http.CanonicalHeaderKey(k) == http.CanonicalHeaderKey(key) && len(v) > 0 {
			return v[0]
		}
	}
	
	return ""
}

// TransformResponseBody transforms response body based on the endpoint
func (t *RequestTransformer) TransformResponseBody(body []byte, path string) ([]byte, error) {
	if path == "/v1/chat/completions" {
		// Convert Anthropic response to OpenAI format
		return ConvertAnthropicToOpenAI(body)
	}
	return body, nil
}
// End of internal/proxy/transformer.go

=====================

// File: internal/proxy/transformer_test.go

package proxy

import (
	"encoding/json"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

const claudeCodePrompt = "You are Claude Code, Anthropic's official CLI for Claude."

func TestSystemPromptTransformation(t *testing.T) {
	transformer := NewRequestTransformer()
	
	t.Run("converts string system prompt to array", func(t *testing.T) {
		input := map[string]interface{}{
			"system": "Custom user prompt",
			"model":  "claude-3-5-sonnet-20241022",
		}
		
		body, err := json.Marshal(input)
		require.NoError(t, err)
		
		result, err := transformer.TransformSystemPrompt(body)
		require.NoError(t, err)
		
		var output map[string]interface{}
		err = json.Unmarshal(result, &output)
		require.NoError(t, err)
		
		system, ok := output["system"].([]interface{})
		require.True(t, ok)
		require.Len(t, system, 2)
		
		// First element should be Claude Code
		first := system[0].(map[string]interface{})
		assert.Equal(t, "text", first["type"])
		assert.Equal(t, claudeCodePrompt, first["text"])
		
		// Second element should be original prompt
		second := system[1].(map[string]interface{})
		assert.Equal(t, "text", second["type"])
		assert.Equal(t, "Custom user prompt", second["text"])
	})
	
	t.Run("leaves string prompt alone if already Claude Code", func(t *testing.T) {
		input := map[string]interface{}{
			"system": claudeCodePrompt,
			"model":  "claude-3-5-sonnet-20241022",
		}
		
		body, err := json.Marshal(input)
		require.NoError(t, err)
		
		result, err := transformer.TransformSystemPrompt(body)
		require.NoError(t, err)
		
		var output map[string]interface{}
		err = json.Unmarshal(result, &output)
		require.NoError(t, err)
		
		// Should remain as string
		system, ok := output["system"].(string)
		require.True(t, ok)
		assert.Equal(t, claudeCodePrompt, system)
	})
	
	t.Run("prepends to array if Claude Code not first", func(t *testing.T) {
		input := map[string]interface{}{
			"system": []interface{}{
				map[string]interface{}{"type": "text", "text": "User prompt 1"},
				map[string]interface{}{"type": "text", "text": "User prompt 2"},
			},
			"model": "claude-3-5-sonnet-20241022",
		}
		
		body, err := json.Marshal(input)
		require.NoError(t, err)
		
		result, err := transformer.TransformSystemPrompt(body)
		require.NoError(t, err)
		
		var output map[string]interface{}
		err = json.Unmarshal(result, &output)
		require.NoError(t, err)
		
		system, ok := output["system"].([]interface{})
		require.True(t, ok)
		require.Len(t, system, 3)
		
		// First element should be Claude Code
		first := system[0].(map[string]interface{})
		assert.Equal(t, "text", first["type"])
		assert.Equal(t, claudeCodePrompt, first["text"])
		
		// Original prompts should follow
		second := system[1].(map[string]interface{})
		assert.Equal(t, "User prompt 1", second["text"])
		
		third := system[2].(map[string]interface{})
		assert.Equal(t, "User prompt 2", third["text"])
	})
	
	t.Run("leaves array alone if Claude Code already first", func(t *testing.T) {
		input := map[string]interface{}{
			"system": []interface{}{
				map[string]interface{}{"type": "text", "text": claudeCodePrompt},
				map[string]interface{}{"type": "text", "text": "User prompt"},
			},
			"model": "claude-3-5-sonnet-20241022",
		}
		
		body, err := json.Marshal(input)
		require.NoError(t, err)
		
		result, err := transformer.TransformSystemPrompt(body)
		require.NoError(t, err)
		
		var output map[string]interface{}
		err = json.Unmarshal(result, &output)
		require.NoError(t, err)
		
		system, ok := output["system"].([]interface{})
		require.True(t, ok)
		require.Len(t, system, 2)
		
		// Should remain unchanged
		first := system[0].(map[string]interface{})
		assert.Equal(t, claudeCodePrompt, first["text"])
	})
	
	t.Run("handles request without system prompt", func(t *testing.T) {
		input := map[string]interface{}{
			"model": "claude-3-5-sonnet-20241022",
			"messages": []interface{}{
				map[string]interface{}{"role": "user", "content": "Hello"},
			},
		}
		
		body, err := json.Marshal(input)
		require.NoError(t, err)
		
		result, err := transformer.TransformSystemPrompt(body)
		require.NoError(t, err)
		
		// Should inject Claude Code prompt
		var data map[string]interface{}
		err = json.Unmarshal(result, &data)
		require.NoError(t, err)
		
		assert.Equal(t, claudeCodePrompt, data["system"])
	})
}

func TestModelAliasMapping(t *testing.T) {
	transformer := NewRequestTransformer()
	
	testCases := []struct {
		input    string
		expected string
	}{
		{"claude-3-5-haiku-latest", "claude-3-5-haiku-20241022"},
		{"claude-3-5-sonnet-latest", "claude-3-5-sonnet-20241022"},
		{"claude-3-7-sonnet-latest", "claude-3-7-sonnet-20250219"},
		{"claude-3-opus-latest", "claude-3-opus-20240229"},
		{"claude-3-5-sonnet-20241022", "claude-3-5-sonnet-20241022"}, // No change
		{"gpt-4", "gpt-4"}, // Unknown model, no change
	}
	
	for _, tc := range testCases {
		t.Run(tc.input, func(t *testing.T) {
			result := transformer.MapModelAlias(tc.input)
			assert.Equal(t, tc.expected, result)
		})
	}
}

func TestHeaderInjection(t *testing.T) {
	transformer := NewRequestTransformer()
	
	t.Run("injects OAuth headers and strips problematic ones", func(t *testing.T) {
		headers := map[string][]string{
			"User-Agent":   {"Zed/0.191.7 (macos; aarch64)"}, // Should be stripped
			"Content-Type": {"application/json"},
			"Accept":       {"application/json"},
			"X-Custom":     {"value"},
		}
		
		token := "test-access-token"
		result := transformer.InjectHeaders(headers, token)
		
		// Check OAuth headers are added
		assert.Equal(t, "Bearer test-access-token", result.Get("Authorization"))
		assert.Equal(t, "oauth-2025-04-20", result.Get("anthropic-beta"))
		assert.Equal(t, "2023-06-01", result.Get("anthropic-version"))
		
		// Check content headers are preserved
		assert.Equal(t, "application/json", result.Get("Content-Type"))
		assert.Equal(t, "application/json", result.Get("Accept"))
		
		// Check User-Agent is stripped
		assert.Empty(t, result.Get("User-Agent"))
		
		// Check other headers are stripped
		assert.Empty(t, result.Get("X-Custom"))
	})
	
	t.Run("uses defaults for missing headers", func(t *testing.T) {
		headers := map[string][]string{}
		
		token := "test-access-token"
		result := transformer.InjectHeaders(headers, token)
		
		assert.Equal(t, "application/json", result.Get("Content-Type"))
		assert.Equal(t, "*/*", result.Get("Accept"))
	})
	
	t.Run("preserves streaming headers", func(t *testing.T) {
		headers := map[string][]string{
			"Content-Type":  {"application/json"},
			"Accept":        {"text/event-stream"},
			"Connection":    {"close"},
			"Cache-Control": {"no-cache"},
		}
		
		token := "test-access-token"
		result := transformer.InjectHeaders(headers, token)
		
		// Check streaming headers are preserved
		assert.Equal(t, "close", result.Get("Connection"))
		assert.Equal(t, "no-cache", result.Get("Cache-Control"))
		assert.Equal(t, "text/event-stream", result.Get("Accept"))
		
		// Check OAuth headers are still added
		assert.Equal(t, "Bearer test-access-token", result.Get("Authorization"))
		assert.Equal(t, "oauth-2025-04-20", result.Get("anthropic-beta"))
	})
}
// End of internal/proxy/transformer_test.go

=====================

// File: internal/test/e2e/cli_e2e_test.go

//go:build e2e
// +build e2e

package e2e_test

import (
	"bytes"
	"context"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"

	"github.com/ml0-1337/claude-gate/internal/test/helpers"
)

func TestCLI_CompleteWorkflow(t *testing.T) {
	// Skip if binary not built
	binPath := filepath.Join("..", "..", "..", "claude-gate")
	if _, err := os.Stat(binPath); os.IsNotExist(err) {
		t.Skip("Binary not found. Run 'make build' first")
	}

	// Setup mock servers
	mockOAuth := helpers.CreateMockOAuthServer(t)
	defer mockOAuth.Close()

	mockAPI := helpers.CreateMockAPIServer(t)
	defer mockAPI.Close()

	// Get free port for proxy
	proxyPort := helpers.GetFreePort()

	// Test version command
	t.Run("version", func(t *testing.T) {
		cmd := exec.Command(binPath, "version")
		output, err := cmd.CombinedOutput()
		require.NoError(t, err)
		assert.Contains(t, string(output), "Claude Gate")
		assert.Contains(t, string(output), "Version:")
	})

	// Test help command
	t.Run("help", func(t *testing.T) {
		cmd := exec.Command(binPath, "--help")
		output, err := cmd.CombinedOutput()
		require.NoError(t, err)
		assert.Contains(t, string(output), "Usage:")
		assert.Contains(t, string(output), "auth")
		assert.Contains(t, string(output), "start")
	})

	// Test proxy start and stop
	t.Run("start_stop", func(t *testing.T) {
		ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
		defer cancel()

		// Start proxy
		cmd := exec.CommandContext(ctx, binPath, "start",
			"--host", "127.0.0.1",
			"--port", proxyPort,
			"--auth-url", mockOAuth.URL+"/oauth/authorize",
			"--token-url", mockOAuth.URL+"/oauth/token",
			"--api-url", mockAPI.URL,
		)

		// Capture output
		var stdout, stderr bytes.Buffer
		cmd.Stdout = &stdout
		cmd.Stderr = &stderr

		// Start command
		err := cmd.Start()
		require.NoError(t, err)

		// Wait for server to be ready
		proxyURL := fmt.Sprintf("http://127.0.0.1:%s", proxyPort)
		err = helpers.WaitForServer(proxyURL+"/health", 2*time.Second)
		
		if err == nil {
			assert.Contains(t, stdout.String(), "Proxy server started")
		}

		// Stop server
		cancel()
		cmd.Wait()
	})
}

func TestCLI_ErrorHandling(t *testing.T) {
	binPath := filepath.Join("..", "..", "..", "claude-gate")
	if _, err := os.Stat(binPath); os.IsNotExist(err) {
		t.Skip("Binary not found. Run 'make build' first")
	}

	// Test invalid command
	t.Run("invalid_command", func(t *testing.T) {
		cmd := exec.Command(binPath, "invalid-command")
		output, err := cmd.CombinedOutput()
		assert.Error(t, err)
		assert.Contains(t, string(output), "unexpected argument")
	})

	// Test port already in use
	t.Run("port_in_use", func(t *testing.T) {
		t.Skip("Skipping port conflict test - requires authentication")
		// This test would need mock OAuth setup to work properly
		// since the server checks for authentication before starting
	})
}
// End of internal/test/e2e/cli_e2e_test.go

=====================

// File: internal/test/e2e/README.md

# End-to-End Tests

This directory contains end-to-end (E2E) tests for the Claude Gate proxy. These tests verify complete user workflows from the CLI interface through to API responses.

## Running E2E Tests

E2E tests are tagged with the `e2e` build tag and are not run by default due to their longer execution time.

To run E2E tests:

```bash
# Run only E2E tests
make test-e2e

# Or directly with go test
go test -tags=e2e ./internal/test/e2e/...

# Run all tests including E2E
make test-all
```

## Test Organization

E2E tests should focus on:
- Complete user workflows (auth → start → API call)
- CLI command interactions
- Real OAuth flow testing (with appropriate mocks)
- Cross-platform behavior verification

## Writing E2E Tests

All E2E test files must include the build tag:

```go
//go:build e2e
// +build e2e

package e2e_test

import (
    "testing"
    "os/exec"
    "github.com/stretchr/testify/assert"
)

func TestCompleteWorkflow(t *testing.T) {
    // Test implementation
}
```

## Test Environment

E2E tests may require:
- Built binaries (run `make build` first)
- Mock OAuth server running
- Clean test environment (no existing auth tokens)

## Best Practices

1. Use test fixtures from `internal/test/testdata/`
2. Clean up resources after tests
3. Use timeouts for long-running operations
4. Test both success and failure paths
// End of internal/test/e2e/README.md

=====================

// File: internal/test/helpers/helpers.go

package helpers

import (
	"encoding/json"
	"fmt"
	"net"
	"net/http"
	"net/http/httptest"
	"testing"
	"time"
)

// TokenResponse represents an OAuth token response
type TokenResponse struct {
	AccessToken  string `json:"access_token"`
	TokenType    string `json:"token_type"`
	ExpiresIn    int    `json:"expires_in"`
	RefreshToken string `json:"refresh_token,omitempty"`
}

// CreateMockOAuthServer creates a mock OAuth server for testing
func CreateMockOAuthServer(t *testing.T) *httptest.Server {
	t.Helper()

	return httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		switch r.URL.Path {
		case "/oauth/authorize":
			// Mock authorization endpoint
			code := r.URL.Query().Get("code")
			if code == "" {
				code = "test-auth-code"
			}
			redirectURI := r.URL.Query().Get("redirect_uri")
			http.Redirect(w, r, redirectURI+"?code="+code, http.StatusFound)

		case "/oauth/token":
			// Mock token endpoint
			w.Header().Set("Content-Type", "application/json")
			
			// Check for refresh token
			if r.FormValue("grant_type") == "refresh_token" {
				refreshToken := r.FormValue("refresh_token")
				if refreshToken == "invalid-refresh-token" {
					w.WriteHeader(http.StatusUnauthorized)
					json.NewEncoder(w).Encode(map[string]string{
						"error": "invalid_grant",
					})
					return
				}
			}

			// Return successful token response
			json.NewEncoder(w).Encode(TokenResponse{
				AccessToken:  "test-access-token-" + time.Now().Format("20060102150405"),
				TokenType:    "Bearer",
				ExpiresIn:    3600,
				RefreshToken: "test-refresh-token",
			})

		default:
			w.WriteHeader(http.StatusNotFound)
		}
	}))
}

// CreateMockAPIServer creates a mock Claude API server for testing
func CreateMockAPIServer(t *testing.T) *httptest.Server {
	t.Helper()

	return httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		// Check authorization header
		authHeader := r.Header.Get("Authorization")
		if authHeader == "" || authHeader == "Bearer invalid-token" {
			w.WriteHeader(http.StatusUnauthorized)
			json.NewEncoder(w).Encode(map[string]string{
				"error": "unauthorized",
			})
			return
		}

		// Check user agent for Claude Code identification
		userAgent := r.Header.Get("User-Agent")
		if userAgent != "Claude-Code/1.0" {
			w.WriteHeader(http.StatusForbidden)
			json.NewEncoder(w).Encode(map[string]string{
				"error": "invalid_client",
			})
			return
		}

		// Mock successful API response
		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(map[string]interface{}{
			"id":      "msg_test123",
			"type":    "message",
			"content": []map[string]string{
				{"type": "text", "text": "Hello from mock Claude API"},
			},
		})
	}))
}

// WaitForServer waits for a server to be ready
func WaitForServer(url string, timeout time.Duration) error {
	client := &http.Client{Timeout: 1 * time.Second}
	deadline := time.Now().Add(timeout)

	for time.Now().Before(deadline) {
		resp, err := client.Get(url)
		if err == nil {
			resp.Body.Close()
			if resp.StatusCode != http.StatusServiceUnavailable {
				return nil
			}
		}
		time.Sleep(100 * time.Millisecond)
	}

	return http.ErrServerClosed
}

// GetFreePort returns a free port for testing
func GetFreePort() string {
	// Using port 0 lets the OS assign a free port
	listener, err := net.Listen("tcp", "127.0.0.1:0")
	if err != nil {
		panic(err)
	}
	port := listener.Addr().(*net.TCPAddr).Port
	listener.Close()
	return fmt.Sprintf("%d", port)
}

// CleanupTestTokens removes any test tokens from storage
func CleanupTestTokens(t *testing.T) {
	t.Helper()
	// Implementation depends on storage backend
	// This is a placeholder that should be implemented based on actual storage
}
// End of internal/test/helpers/helpers.go

=====================

// File: internal/test/integration/auth_integration_test.go

//go:build integration
// +build integration

package integration_test

import (
	"encoding/json"
	"net/http"
	"net/http/httptest"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"

	"github.com/ml0-1337/claude-gate/internal/auth"
	"github.com/ml0-1337/claude-gate/internal/test/helpers"
)

func TestOAuthFlow_CompleteAuthentication(t *testing.T) {
	// Setup mock OAuth server
	mockServer := helpers.CreateMockOAuthServer(t)
	defer mockServer.Close()

	// Create custom OAuth client with mock server URLs
	client := &auth.OAuthClient{
		ClientID:     "test-client-id",
		AuthorizeURL: mockServer.URL + "/oauth/authorize",
		TokenURL:     mockServer.URL + "/oauth/token",
		RedirectURI:  "http://localhost:8080/callback",
		Scopes:       "read write",
	}

	// Test authorization URL generation
	authData, err := client.GetAuthorizationURL()
	require.NoError(t, err)
	assert.NotEmpty(t, authData.URL)
	assert.NotEmpty(t, authData.Verifier)
	assert.Contains(t, authData.URL, mockServer.URL)
	assert.Contains(t, authData.URL, "code_challenge")
	assert.Contains(t, authData.URL, "code_challenge_method=S256")
}

func TestOAuthFlow_TokenExchange(t *testing.T) {
	// Setup mock OAuth server
	mockServer := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if r.URL.Path == "/oauth/token" {
			w.Header().Set("Content-Type", "application/json")
			w.Write([]byte(`{
				"access_token": "test-access-token",
				"token_type": "Bearer",
				"expires_in": 3600,
				"refresh_token": "test-refresh-token"
			}`))
		}
	}))
	defer mockServer.Close()

	// Create OAuth client
	client := &auth.OAuthClient{
		ClientID:    "test-client-id",
		TokenURL:    mockServer.URL + "/oauth/token",
		RedirectURI: "http://localhost:8080/callback",
	}

	// Test token exchange
	token, err := client.ExchangeCode("test-code", "test-verifier")
	require.NoError(t, err)
	assert.NotNil(t, token)
	assert.Equal(t, "oauth", token.Type)
	assert.Equal(t, "test-access-token", token.AccessToken)
	assert.Equal(t, "test-refresh-token", token.RefreshToken)
	assert.True(t, token.ExpiresAt > time.Now().Unix())
}

func TestOAuthFlow_TokenRefresh(t *testing.T) {
	// Setup mock OAuth server
	mockServer := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if r.URL.Path == "/oauth/token" {
			// Parse the JSON body to check grant_type
			var body map[string]interface{}
			json.NewDecoder(r.Body).Decode(&body)
			
			if body["grant_type"] == "refresh_token" {
				w.Header().Set("Content-Type", "application/json")
				w.Write([]byte(`{
					"access_token": "new-access-token",
					"token_type": "Bearer",
					"expires_in": 3600,
					"refresh_token": "new-refresh-token"
				}`))
				return
			}
		}
		w.WriteHeader(http.StatusBadRequest)
	}))
	defer mockServer.Close()

	// Create OAuth client
	client := &auth.OAuthClient{
		ClientID: "test-client-id",
		TokenURL: mockServer.URL + "/oauth/token",
	}

	// Test token refresh
	newToken, err := client.RefreshToken("test-refresh-token")
	require.NoError(t, err)
	assert.NotNil(t, newToken)
	assert.Equal(t, "new-access-token", newToken.AccessToken)
	assert.Equal(t, "new-refresh-token", newToken.RefreshToken)
}

func TestOAuthTokenProvider_Integration(t *testing.T) {
	// Create mock storage
	storage := &mockStorage{
		tokens: make(map[string]*auth.TokenInfo),
	}

	// Create token provider
	provider := auth.NewOAuthTokenProvider(storage)

	// Test getting token when none exists
	_, err := provider.GetAccessToken()
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "no OAuth token found")

	// Store a valid token
	validToken := &auth.TokenInfo{
		Type:        "oauth",
		AccessToken: "valid-access-token",
		ExpiresAt:   time.Now().Add(1 * time.Hour).Unix(),
	}
	storage.Set("anthropic", validToken)

	// Test getting valid token
	token, err := provider.GetAccessToken()
	require.NoError(t, err)
	assert.Equal(t, "valid-access-token", token)
}

// mockStorage implements StorageBackend for testing
type mockStorage struct {
	tokens map[string]*auth.TokenInfo
}

func (m *mockStorage) Get(provider string) (*auth.TokenInfo, error) {
	token, ok := m.tokens[provider]
	if !ok {
		return nil, nil
	}
	return token, nil
}

func (m *mockStorage) Set(provider string, token *auth.TokenInfo) error {
	m.tokens[provider] = token
	return nil
}

func (m *mockStorage) Remove(provider string) error {
	delete(m.tokens, provider)
	return nil
}

func (m *mockStorage) List() ([]string, error) {
	var providers []string
	for provider := range m.tokens {
		providers = append(providers, provider)
	}
	return providers, nil
}

func (m *mockStorage) IsAvailable() bool {
	return true
}

func (m *mockStorage) RequiresUnlock() bool {
	return false
}

func (m *mockStorage) Unlock() error {
	return nil
}

func (m *mockStorage) Lock() error {
	return nil
}

func (m *mockStorage) Name() string {
	return "mock"
}
// End of internal/test/integration/auth_integration_test.go

=====================

// File: internal/test/integration/README.md

# Integration Tests

This directory contains integration tests for the Claude Gate proxy. These tests verify that different components work correctly together.

## Running Integration Tests

Integration tests are tagged with the `integration` build tag and are not run by default.

To run integration tests:

```bash
# Run only integration tests
make test-integration

# Or directly with go test
go test -tags=integration ./internal/test/integration/...

# Run all tests including integration
make test-all
```

## Test Organization

Integration tests should focus on:
- Component interactions (e.g., auth + proxy)
- Database/storage operations
- External service mocking (OAuth providers)
- Multi-step workflows

## Writing Integration Tests

All integration test files must include the build tag:

```go
//go:build integration
// +build integration

package integration_test

import (
    "testing"
    "github.com/stretchr/testify/assert"
)

func TestComponentIntegration(t *testing.T) {
    // Test implementation
}
```

## Test Helpers

Use the shared test helpers from `internal/test/helpers/` for:
- Mock OAuth servers
- Test token providers
- Common test utilities
// End of internal/test/integration/README.md

=====================

// File: internal/ui/browser.go

package ui

import (
	"fmt"
	"os/exec"
	"runtime"
)

// OpenBrowser opens the default browser to the specified URL
func OpenBrowser(url string) error {
	var err error

	switch runtime.GOOS {
	case "linux":
		err = exec.Command("xdg-open", url).Start()
	// case "windows":
	// 	err = exec.Command("rundll32", "url.dll,FileProtocolHandler", url).Start()
	case "darwin":
		err = exec.Command("open", url).Start()
	default:
		err = fmt.Errorf("unsupported platform")
	}

	return err
}

// TryOpenBrowser attempts to open the browser but doesn't fail if it can't
func TryOpenBrowser(url string) {
	// Silently ignore errors - user can still copy/paste the URL
	_ = OpenBrowser(url)
}
// End of internal/ui/browser.go

=====================

// File: internal/ui/components/auth_flow.go

package components

import (
	"fmt"
	"strings"

	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/bubbles/textinput"
	"github.com/charmbracelet/lipgloss"
	"github.com/ml0-1337/claude-gate/internal/ui/styles"
)

// AuthFlowStep represents a step in the OAuth flow
type AuthFlowStep struct {
	Name      string
	Completed bool
	Current   bool
	Failed    bool
}

// AuthFlowModel represents the OAuth authentication flow UI
type AuthFlowModel struct {
	steps      []AuthFlowStep
	authURL    string
	textInput  textinput.Model
	err        error
	width      int
	showingURL bool
	code       string
	done       bool
}

// NewAuthFlow creates a new OAuth flow UI
func NewAuthFlow() AuthFlowModel {
	ti := textinput.New()
	ti.Placeholder = "Enter authorization code"
	ti.Focus()
	ti.CharLimit = 100
	ti.Width = 50

	return AuthFlowModel{
		steps: []AuthFlowStep{
			{Name: "Generate authorization URL", Completed: false, Current: true},
			{Name: "Open browser for authentication", Completed: false, Current: false},
			{Name: "Enter authorization code", Completed: false, Current: false},
			{Name: "Exchange code for tokens", Completed: false, Current: false},
			{Name: "Save tokens securely", Completed: false, Current: false},
		},
		textInput: ti,
		width:     80,
	}
}

// Init initializes the auth flow
func (m AuthFlowModel) Init() tea.Cmd {
	return textinput.Blink
}

// AuthURLMsg contains the authorization URL
type AuthURLMsg struct {
	URL string
}

// AuthCodeMsg indicates the code was submitted
type AuthCodeMsg struct {
	Code string
}

// AuthStepMsg updates the current step
type AuthStepMsg struct {
	Step      int
	Completed bool
	Failed    bool
	Error     error
}

// AuthCompleteMsg indicates authentication is complete
type AuthCompleteMsg struct{}

// Update handles auth flow updates
func (m AuthFlowModel) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	var cmd tea.Cmd

	switch msg := msg.(type) {
	case tea.KeyMsg:
		switch msg.Type {
		case tea.KeyCtrlC, tea.KeyEsc:
			return m, tea.Quit
		case tea.KeyEnter:
			if m.showingURL && m.textInput.Value() != "" {
				m.code = m.textInput.Value()
				return m, func() tea.Msg {
					return AuthCodeMsg{Code: m.code}
				}
			}
		}

	case tea.WindowSizeMsg:
		m.width = msg.Width

	case AuthURLMsg:
		m.authURL = msg.URL
		m.showingURL = true
		m.steps[0].Completed = true
		m.steps[0].Current = false
		m.steps[1].Current = true
		// Auto-advance to step 2
		return m, func() tea.Msg {
			return AuthStepMsg{Step: 2, Completed: true}
		}

	case AuthStepMsg:
		if msg.Step < len(m.steps) {
			if msg.Failed {
				m.steps[msg.Step].Failed = true
				m.steps[msg.Step].Current = false
				m.err = msg.Error
			} else if msg.Completed {
				m.steps[msg.Step].Completed = true
				m.steps[msg.Step].Current = false
				if msg.Step+1 < len(m.steps) {
					m.steps[msg.Step+1].Current = true
				}
			} else {
				// Just update current
				for i := range m.steps {
					m.steps[i].Current = i == msg.Step
				}
			}
		}

	case AuthCompleteMsg:
		m.done = true
		return m, tea.Quit

	case StatusMsg:
		if msg.Status == "error" {
			// Find current step and mark as failed
			for i, step := range m.steps {
				if step.Current {
					m.steps[i].Failed = true
					m.err = fmt.Errorf("%s", msg.Message)
					break
				}
			}
		}
	}

	// Update text input
	if m.showingURL && m.steps[2].Current {
		m.textInput, cmd = m.textInput.Update(msg)
	}

	return m, cmd
}

// View renders the auth flow UI
func (m AuthFlowModel) View() string {
	if m.done {
		return styles.SuccessStyle.Render("✓ Authentication complete!")
	}

	var s strings.Builder

	// Title
	title := styles.TitleStyle.Render("🔐 OAuth Authentication Flow")
	s.WriteString(title + "\n\n")

	// Progress steps
	for _, step := range m.steps {
		var icon string
		var style lipgloss.Style

		if step.Failed {
			icon = "✗"
			style = styles.ErrorStyle
		} else if step.Completed {
			icon = "✓"
			style = styles.SuccessStyle
		} else if step.Current {
			icon = "◐"
			style = styles.InfoStyle
		} else {
			icon = "○"
			style = styles.DescriptionStyle
		}

		stepText := fmt.Sprintf("%s %s", icon, step.Name)
		s.WriteString(style.Render(stepText) + "\n")
	}

	s.WriteString("\n")

	// Show content based on current step
	if m.showingURL && m.authURL != "" {
		s.WriteString(styles.SubtitleStyle.Render("Please visit this URL to authorize:") + "\n\n")
		
		// Create a nice box for the URL
		urlBox := lipgloss.NewStyle().
			Border(lipgloss.RoundedBorder()).
			BorderForeground(styles.Primary).
			Padding(1, 2).
			Width(min(len(m.authURL)+4, m.width-4))
		
		s.WriteString(urlBox.Render(m.authURL) + "\n\n")

		// Show input field if we're on step 2
		if m.steps[2].Current {
			s.WriteString(styles.InfoStyle.Render("After authorizing, enter the code below:") + "\n")
			s.WriteString(m.textInput.View() + "\n\n")
			s.WriteString(styles.HelpStyle.Render("Press Enter to submit, Esc to cancel"))
		}
	}

	// Show error if any
	if m.err != nil {
		s.WriteString("\n" + styles.ErrorStyle.Render("Error: "+m.err.Error()))
	}

	return s.String()
}

// Helper function
func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}

// AuthFlowUI runs the interactive OAuth flow UI
type AuthFlowUI struct {
	model   AuthFlowModel
	program *tea.Program
}

// NewAuthFlowUI creates a new auth flow UI runner
func NewAuthFlowUI() *AuthFlowUI {
	model := NewAuthFlow()
	return &AuthFlowUI{
		model:   model,
		program: tea.NewProgram(model),
	}
}

// Start starts the auth flow UI
func (a *AuthFlowUI) Start() error {
	go func() {
		if _, err := a.program.Run(); err != nil {
			fmt.Printf("Error running auth flow: %v\n", err)
		}
	}()
	return nil
}

// SetAuthURL sets the authorization URL
func (a *AuthFlowUI) SetAuthURL(url string) {
	a.program.Send(AuthURLMsg{URL: url})
}

// UpdateStep updates the current step
func (a *AuthFlowUI) UpdateStep(step int, completed bool, failed bool, err error) {
	a.program.Send(AuthStepMsg{
		Step:      step,
		Completed: completed,
		Failed:    failed,
		Error:     err,
	})
}

// GetCode waits for and returns the authorization code
func (a *AuthFlowUI) GetCode() (string, error) {
	// This would need to be implemented with channels
	// For now, return empty
	return "", nil
}

// Complete marks the flow as complete
func (a *AuthFlowUI) Complete() {
	a.program.Send(AuthCompleteMsg{})
}

// Quit quits the UI
func (a *AuthFlowUI) Quit() {
	a.program.Quit()
}
// End of internal/ui/components/auth_flow.go

=====================

// File: internal/ui/components/confirm.go

package components

import (
	"fmt"

	tea "github.com/charmbracelet/bubbletea"
	"github.com/ml0-1337/claude-gate/internal/ui/styles"
)

// ConfirmModel represents a confirmation prompt
type ConfirmModel struct {
	question string
	answer   bool
	answered bool
}

// NewConfirm creates a new confirmation prompt
func NewConfirm(question string) ConfirmModel {
	return ConfirmModel{
		question: question,
		answer:   false,
		answered: false,
	}
}

// Init initializes the confirmation prompt
func (m ConfirmModel) Init() tea.Cmd {
	return nil
}

// Update handles confirmation updates
func (m ConfirmModel) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	switch msg := msg.(type) {
	case tea.KeyMsg:
		switch msg.String() {
		case "y", "Y":
			m.answer = true
			m.answered = true
			return m, tea.Quit
		case "n", "N":
			m.answer = false
			m.answered = true
			return m, tea.Quit
		case "ctrl+c", "esc":
			m.answer = false
			m.answered = true
			return m, tea.Quit
		}
	}
	return m, nil
}

// View renders the confirmation prompt
func (m ConfirmModel) View() string {
	if m.answered {
		answer := "No"
		if m.answer {
			answer = "Yes"
		}
		return fmt.Sprintf("%s %s\n", m.question, styles.InfoStyle.Render(answer))
	}
	return fmt.Sprintf("%s %s ", m.question, styles.HelpStyle.Render("(y/N)"))
}

// Confirm shows a confirmation prompt and returns the answer
func Confirm(question string) bool {
	model := NewConfirm(question)
	p := tea.NewProgram(model)
	
	finalModel, err := p.Run()
	if err != nil {
		return false
	}
	
	return finalModel.(ConfirmModel).answer
}

// ConfirmWithDefault shows a confirmation prompt with a default value
func ConfirmWithDefault(question string, defaultYes bool) bool {
	suffix := "(y/N)"
	if defaultYes {
		suffix = "(Y/n)"
	}
	
	fullQuestion := fmt.Sprintf("%s %s", question, styles.HelpStyle.Render(suffix))
	
	model := &ConfirmDefaultModel{
		ConfirmModel: ConfirmModel{
			question: fullQuestion,
			answer:   defaultYes,
			answered: false,
		},
		defaultYes: defaultYes,
	}
	
	p := tea.NewProgram(model)
	
	finalModel, err := p.Run()
	if err != nil {
		return false
	}
	
	return finalModel.(*ConfirmDefaultModel).answer
}

// ConfirmDefaultModel extends ConfirmModel with default value support
type ConfirmDefaultModel struct {
	ConfirmModel
	defaultYes bool
}

// Update handles confirmation updates with default support
func (m *ConfirmDefaultModel) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	switch msg := msg.(type) {
	case tea.KeyMsg:
		switch msg.String() {
		case "y", "Y":
			m.answer = true
			m.answered = true
			return m, tea.Quit
		case "n", "N":
			m.answer = false
			m.answered = true
			return m, tea.Quit
		case "enter":
			m.answer = m.defaultYes
			m.answered = true
			return m, tea.Quit
		case "ctrl+c", "esc":
			m.answer = false
			m.answered = true
			return m, tea.Quit
		}
	}
	return m, nil
}
// End of internal/ui/components/confirm.go

=====================

// File: internal/ui/components/progress.go

package components

import (
	"fmt"
	"strings"
	"time"

	"github.com/charmbracelet/bubbles/progress"
	tea "github.com/charmbracelet/bubbletea"
	"github.com/ml0-1337/claude-gate/internal/ui/styles"
	"github.com/ml0-1337/claude-gate/internal/ui/utils"
)

// ProgressModel represents a progress bar
type ProgressModel struct {
	progress progress.Model
	title    string
	percent  float64
	width    int
}

// NewProgress creates a new progress bar model
func NewProgress(title string) ProgressModel {
	width := utils.GetTerminalWidth() - 20 // Leave some margin
	if width < 40 {
		width = 40
	}
	
	p := progress.New(
		progress.WithDefaultGradient(),
		progress.WithWidth(width),
		progress.WithoutPercentage(),
	)
	
	return ProgressModel{
		progress: p,
		title:    title,
		percent:  0,
		width:    width,
	}
}

// Init initializes the progress bar
func (m ProgressModel) Init() tea.Cmd {
	return nil
}

// Update handles progress updates
func (m ProgressModel) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	switch msg := msg.(type) {
	case tea.KeyMsg:
		return m, tea.Quit

	case tea.WindowSizeMsg:
		m.progress.Width = msg.Width - 20
		if m.progress.Width < 40 {
			m.progress.Width = 40
		}
		return m, nil

	case ProgressMsg:
		m.percent = msg.Percent
		if msg.Title != "" {
			m.title = msg.Title
		}
		cmd := m.progress.SetPercent(float64(m.percent))
		return m, cmd

	case progress.FrameMsg:
		progressModel, cmd := m.progress.Update(msg)
		m.progress = progressModel.(progress.Model)
		return m, cmd

	default:
		return m, nil
	}
}

// View renders the progress bar
func (m ProgressModel) View() string {
	pad := strings.Repeat(" ", m.width-len(m.title))
	title := styles.SubtitleStyle.Render(m.title)
	percent := styles.InfoStyle.Render(fmt.Sprintf("%.0f%%", m.percent*100))
	
	return fmt.Sprintf("%s%s%s\n%s", title, pad, percent, m.progress.View())
}

// ProgressMsg is used to update progress
type ProgressMsg struct {
	Percent float64
	Title   string
}

// ProgressTracker provides a simple interface for tracking progress
type ProgressTracker struct {
	program *tea.Program
	total   int
	current int
}

// NewProgressTracker creates a new progress tracker
func NewProgressTracker(title string, total int) *ProgressTracker {
	model := NewProgress(title)
	p := tea.NewProgram(model)
	
	tracker := &ProgressTracker{
		program: p,
		total:   total,
		current: 0,
	}
	
	// Start the program in a goroutine
	go p.Run()
	
	return tracker
}

// Increment increments the progress
func (t *ProgressTracker) Increment(title string) {
	t.current++
	percent := float64(t.current) / float64(t.total)
	t.program.Send(ProgressMsg{
		Percent: percent,
		Title:   title,
	})
}

// Finish completes the progress
func (t *ProgressTracker) Finish() {
	t.program.Send(ProgressMsg{Percent: 1.0})
	time.Sleep(500 * time.Millisecond) // Brief pause to show completion
	t.program.Quit()
}

// SimpleProgress shows a progress bar for a simple operation
func SimpleProgress(title string, steps []string, stepDuration time.Duration) {
	tracker := NewProgressTracker(title, len(steps))
	
	for _, step := range steps {
		tracker.Increment(step)
		time.Sleep(stepDuration)
	}
	
	tracker.Finish()
}
// End of internal/ui/components/progress.go

=====================

// File: internal/ui/components/spinner.go

package components

import (
	"fmt"
	"time"

	"github.com/charmbracelet/bubbles/spinner"
	tea "github.com/charmbracelet/bubbletea"
	"github.com/ml0-1337/claude-gate/internal/ui/styles"
)

// SpinnerModel represents a spinner with a message
type SpinnerModel struct {
	spinner  spinner.Model
	message  string
	status   string
	quitting bool
}

// NewSpinner creates a new spinner model
func NewSpinner(message string) SpinnerModel {
	s := spinner.New()
	s.Spinner = spinner.Dot
	s.Style = styles.InfoStyle
	return SpinnerModel{
		spinner: s,
		message: message,
		status:  "loading",
	}
}

// Init initializes the spinner
func (m SpinnerModel) Init() tea.Cmd {
	return m.spinner.Tick
}

// Update handles spinner updates
func (m SpinnerModel) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	switch msg := msg.(type) {
	case tea.KeyMsg:
		switch msg.String() {
		case "q", "esc", "ctrl+c":
			m.quitting = true
			return m, tea.Quit
		default:
			return m, nil
		}

	case spinner.TickMsg:
		var cmd tea.Cmd
		m.spinner, cmd = m.spinner.Update(msg)
		return m, cmd

	case StatusMsg:
		m.status = msg.Status
		m.message = msg.Message
		if msg.Status != "loading" {
			m.quitting = true
			return m, tea.Quit
		}
		return m, nil

	default:
		return m, nil
	}
}

// View renders the spinner
func (m SpinnerModel) View() string {
	if m.quitting && m.status != "loading" {
		return styles.RenderStatus(m.status, m.message) + "\n"
	}
	return fmt.Sprintf("%s %s", m.spinner.View(), m.message)
}

// StatusMsg is used to update the spinner status
type StatusMsg struct {
	Status  string
	Message string
}

// RunSpinner runs a spinner while executing a function
func RunSpinner(message string, fn func() error) error {
	// Create the spinner model
	model := NewSpinner(message)
	
	// Create a channel to receive the result
	done := make(chan error, 1)
	
	// Create the Bubble Tea program
	p := tea.NewProgram(model)
	
	// Run the function in a goroutine
	go func() {
		err := fn()
		done <- err
		
		// Send status update to the spinner
		if err != nil {
			p.Send(StatusMsg{
				Status:  "error",
				Message: err.Error(),
			})
		} else {
			p.Send(StatusMsg{
				Status:  "success",
				Message: "Done!",
			})
		}
	}()
	
	// Run the spinner
	if _, err := p.Run(); err != nil {
		return err
	}
	
	// Wait for the function to complete
	select {
	case err := <-done:
		return err
	case <-time.After(30 * time.Second):
		return fmt.Errorf("operation timed out")
	}
}

// SimpleSpinner shows a spinner for a duration or until interrupted
func SimpleSpinner(message string, duration time.Duration) {
	model := NewSpinner(message)
	p := tea.NewProgram(model)
	
	// Auto-quit after duration
	go func() {
		time.Sleep(duration)
		p.Send(StatusMsg{
			Status:  "success",
			Message: "Done!",
		})
	}()
	
	p.Run()
}
// End of internal/ui/components/spinner.go

=====================

// File: internal/ui/components/timer.go

package components

import (
	"fmt"
	"strings"
	"time"

	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/lipgloss"
	"github.com/ml0-1337/claude-gate/internal/ui/styles"
)

// TimerModel represents a countdown timer
type TimerModel struct {
	duration  time.Duration
	remaining time.Duration
	message   string
	expired   bool
	quitting  bool
}

// NewTimer creates a new countdown timer
func NewTimer(duration time.Duration, message string) TimerModel {
	return TimerModel{
		duration:  duration,
		remaining: duration,
		message:   message,
		expired:   false,
		quitting:  false,
	}
}

// Init initializes the timer
func (m TimerModel) Init() tea.Cmd {
	return tickCmd()
}

// tickMsg is sent every second
type tickMsg time.Time

// tickCmd returns a command that sends a tick every second
func tickCmd() tea.Cmd {
	return tea.Tick(time.Second, func(t time.Time) tea.Msg {
		return tickMsg(t)
	})
}

// ExpiredMsg is sent when the timer expires
type ExpiredMsg struct{}

// Update handles timer updates
func (m TimerModel) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	switch msg := msg.(type) {
	case tea.KeyMsg:
		switch msg.String() {
		case "q", "esc", "ctrl+c":
			m.quitting = true
			return m, tea.Quit
		}

	case tickMsg:
		m.remaining -= time.Second
		if m.remaining <= 0 {
			m.expired = true
			m.quitting = true
			return m, tea.Batch(
				tea.Quit,
				func() tea.Msg { return ExpiredMsg{} },
			)
		}
		return m, tickCmd()

	case StatusMsg:
		if msg.Status == "success" {
			m.quitting = true
			return m, tea.Quit
		}
	}

	return m, nil
}

// View renders the timer
func (m TimerModel) View() string {
	if m.quitting && !m.expired {
		return ""
	}

	if m.expired {
		return styles.ErrorStyle.Render("⏰ Timer expired!")
	}

	minutes := int(m.remaining.Minutes())
	seconds := int(m.remaining.Seconds()) % 60

	timeStr := fmt.Sprintf("%02d:%02d", minutes, seconds)
	
	// Create a progress bar based on remaining time
	progress := float64(m.remaining) / float64(m.duration)
	width := 30
	filled := int(float64(width) * (1 - progress))
	
	progressBar := lipgloss.NewStyle().
		Foreground(styles.Primary).
		Render(strings.Repeat("█", filled)) +
		lipgloss.NewStyle().
		Foreground(styles.Muted).
		Render(strings.Repeat("░", width-filled))

	return fmt.Sprintf(
		"%s\n%s %s\n",
		m.message,
		progressBar,
		styles.InfoStyle.Render(timeStr),
	)
}

// CountdownTimer runs a countdown timer with a message
func CountdownTimer(duration time.Duration, message string) tea.Model {
	return NewTimer(duration, message)
}

// TimerWithCallback runs a timer and executes a callback when done
func TimerWithCallback(duration time.Duration, message string, onExpired func()) {
	model := NewTimer(duration, message)
	p := tea.NewProgram(model)
	
	go func() {
		finalModel, err := p.Run()
		if err == nil {
			// Check if timer expired
			if m, ok := finalModel.(TimerModel); ok && m.expired {
				onExpired()
			}
		}
	}()
}
// End of internal/ui/components/timer.go

=====================

// File: internal/ui/dashboard/dashboard.go

package dashboard

import (
	"fmt"
	"strings"
	"time"

	"github.com/charmbracelet/bubbles/key"
	"github.com/charmbracelet/bubbles/viewport"
	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/lipgloss"
	"github.com/ml0-1337/claude-gate/internal/ui/styles"
)

// Model represents the dashboard state
type Model struct {
	width     int
	height    int
	ready     bool
	paused    bool
	
	// Components
	stats      *RequestStats
	requestLog *RequestLog
	viewport   viewport.Model
	
	// Server info
	serverURL   string
	startTime   time.Time
	oauthStatus string
	
	// UI state
	showHelp     bool
	selectedPane int // 0: stats, 1: requests
	
	// Update channel
	eventChan chan RequestEvent
}

// New creates a new dashboard model
func New(serverURL string) *Model {
	return &Model{
		stats:       NewRequestStats(),
		requestLog:  NewRequestLog(1000),
		serverURL:   serverURL,
		startTime:   time.Now(),
		oauthStatus: "Ready",
		eventChan:   make(chan RequestEvent, 100),
	}
}

// Init initializes the dashboard
func (m *Model) Init() tea.Cmd {
	return tea.Batch(
		m.listenForEvents(),
		tickCmd(),
	)
}

// Update handles dashboard updates
func (m *Model) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	var (
		cmd  tea.Cmd
		cmds []tea.Cmd
	)

	switch msg := msg.(type) {
	case tea.KeyMsg:
		switch {
		case key.Matches(msg, keys.Quit):
			return m, tea.Quit
		case key.Matches(msg, keys.Help):
			m.showHelp = !m.showHelp
		case key.Matches(msg, keys.Pause):
			m.paused = !m.paused
		case key.Matches(msg, keys.Clear):
			m.requestLog.Clear()
		case key.Matches(msg, keys.Tab):
			m.selectedPane = (m.selectedPane + 1) % 2
		}

	case tea.WindowSizeMsg:
		m.width = msg.Width
		m.height = msg.Height
		
		// Update viewport
		headerHeight := 10 // Approximate header height
		footerHeight := 3
		m.viewport = viewport.New(msg.Width, msg.Height-headerHeight-footerHeight)
		m.viewport.SetContent(m.renderRequests())
		m.ready = true

	case tickMsg:
		// Update UI periodically
		if !m.paused {
			m.viewport.SetContent(m.renderRequests())
		}
		cmds = append(cmds, tickCmd())

	case RequestEvent:
		// Record the request
		if !m.paused {
			m.stats.RecordRequest(msg.StatusCode, msg.Duration)
			m.requestLog.Add(msg)
			m.viewport.SetContent(m.renderRequests())
		}
		// Continue listening for more events
		cmds = append(cmds, m.listenForEvents())
	}

	// Update viewport
	m.viewport, cmd = m.viewport.Update(msg)
	cmds = append(cmds, cmd)

	return m, tea.Batch(cmds...)
}

// View renders the dashboard
func (m *Model) View() string {
	if !m.ready {
		return "Initializing dashboard..."
	}

	var s strings.Builder

	// Header
	s.WriteString(m.renderHeader())
	s.WriteString("\n\n")

	// Stats panel
	s.WriteString(m.renderStats())
	s.WriteString("\n\n")

	// Request log viewport
	s.WriteString(m.renderRequestsHeader())
	s.WriteString("\n")
	s.WriteString(m.viewport.View())
	s.WriteString("\n")

	// Footer
	s.WriteString(m.renderFooter())

	return s.String()
}

// renderHeader renders the dashboard header
func (m *Model) renderHeader() string {
	uptime := time.Since(m.startTime).Round(time.Second)
	
	title := lipgloss.NewStyle().
		Bold(true).
		Foreground(styles.Primary).
		Render("🚀 Claude Gate Dashboard")
	
	status := lipgloss.NewStyle().
		Foreground(styles.Success).
		Render("● Running")
	
	if m.paused {
		status = lipgloss.NewStyle().
			Foreground(styles.Warning).
			Render("⏸ Paused")
	}
	
	info := fmt.Sprintf("Server: %s | OAuth: %s | Uptime: %s",
		m.serverURL, m.oauthStatus, uptime)
	
	header := lipgloss.JoinHorizontal(
		lipgloss.Left,
		title,
		strings.Repeat(" ", 4),
		status,
	)
	
	return header + "\n" + styles.DescriptionStyle.Render(info)
}

// renderStats renders the statistics panel
func (m *Model) renderStats() string {
	stats := m.stats.GetStats()
	
	// Create stat cards
	cards := []string{
		m.createStatCard("Total Requests", fmt.Sprintf("%d", stats.TotalRequests), styles.InfoStyle),
		m.createStatCard("Success Rate", fmt.Sprintf("%.1f%%", m.calculateSuccessRate(stats)), styles.SuccessStyle),
		m.createStatCard("Avg Response", stats.AvgDuration.Round(time.Millisecond).String(), styles.InfoStyle),
		m.createStatCard("Requests/sec", formatReqPerSecond(stats.ReqPerSecond), styles.InfoStyle),
	}
	
	return lipgloss.JoinHorizontal(lipgloss.Left, cards...)
}

// createStatCard creates a single stat card
func (m *Model) createStatCard(label, value string, valueStyle lipgloss.Style) string {
	card := lipgloss.NewStyle().
		Border(lipgloss.RoundedBorder()).
		BorderForeground(styles.Primary).
		Padding(0, 1).
		Width(20).
		Height(3)
	
	content := fmt.Sprintf("%s\n%s",
		styles.DescriptionStyle.Render(label),
		valueStyle.Render(value),
	)
	
	return card.Render(content)
}

// renderRequestsHeader renders the request log header
func (m *Model) renderRequestsHeader() string {
	title := styles.SubtitleStyle.Render("Recent Requests")
	header := styles.DescriptionStyle.Render("Time     Method Status Duration Size Path")
	
	return title + "\n" + header
}

// renderRequests renders the request log content
func (m *Model) renderRequests() string {
	requests := m.requestLog.GetRequests(100)
	
	if len(requests) == 0 {
		return styles.DescriptionStyle.Render("No requests yet...")
	}
	
	var lines []string
	for _, req := range requests {
		line := FormatRequest(req)
		
		// Color based on status
		var style lipgloss.Style
		if req.StatusCode >= 200 && req.StatusCode < 300 {
			style = styles.SuccessStyle
		} else if req.StatusCode >= 400 && req.StatusCode < 500 {
			style = styles.WarningStyle
		} else if req.StatusCode >= 500 {
			style = styles.ErrorStyle
		} else {
			style = styles.InfoStyle
		}
		
		lines = append(lines, style.Render(line))
	}
	
	return strings.Join(lines, "\n")
}

// renderFooter renders the dashboard footer
func (m *Model) renderFooter() string {
	help := []string{
		"q: quit",
		"p: pause",
		"c: clear",
		"?: help",
		"↑/↓: scroll",
	}
	
	if m.showHelp {
		help = append(help, []string{
			"tab: switch panes",
			"f: filter",
			"e: export",
		}...)
	}
	
	return styles.HelpStyle.Render(strings.Join(help, " • "))
}

// calculateSuccessRate calculates the success rate from stats
func (m *Model) calculateSuccessRate(stats Stats) float64 {
	if stats.TotalRequests == 0 {
		return 0
	}
	return float64(stats.SuccessCount) / float64(stats.TotalRequests) * 100
}

// formatReqPerSecond formats the requests per second value
func formatReqPerSecond(rate float64) string {
	if rate < 0.1 {
		// For very low rates, show 3 decimal places
		return fmt.Sprintf("%.3f", rate)
	} else if rate < 1.0 {
		// For rates less than 1, show 2 decimal places
		return fmt.Sprintf("%.2f", rate)
	} else {
		// For higher rates, show 1 decimal place
		return fmt.Sprintf("%.1f", rate)
	}
}

// listenForEvents listens for request events
func (m *Model) listenForEvents() tea.Cmd {
	return func() tea.Msg {
		event := <-m.eventChan
		return event
	}
}

// tickMsg is sent periodically to update the UI
type tickMsg time.Time

// tickCmd returns a command that sends a tick every second
func tickCmd() tea.Cmd {
	return tea.Tick(time.Second, func(t time.Time) tea.Msg {
		return tickMsg(t)
	})
}

// Key bindings
type keyMap struct {
	Quit  key.Binding
	Help  key.Binding
	Pause key.Binding
	Clear key.Binding
	Tab   key.Binding
}

var keys = keyMap{
	Quit: key.NewBinding(
		key.WithKeys("q", "ctrl+c"),
		key.WithHelp("q", "quit"),
	),
	Help: key.NewBinding(
		key.WithKeys("?"),
		key.WithHelp("?", "help"),
	),
	Pause: key.NewBinding(
		key.WithKeys("p", " "),
		key.WithHelp("p", "pause"),
	),
	Clear: key.NewBinding(
		key.WithKeys("c"),
		key.WithHelp("c", "clear"),
	),
	Tab: key.NewBinding(
		key.WithKeys("tab"),
		key.WithHelp("tab", "switch pane"),
	),
}

// SendEvent sends a request event to the dashboard
func (m *Model) SendEvent(event RequestEvent) {
	select {
	case m.eventChan <- event:
	default:
		// Channel full, drop event
	}
}
// End of internal/ui/dashboard/dashboard.go

=====================

// File: internal/ui/dashboard/dashboard_test.go

package dashboard

import (
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
)

func TestDashboard_DirectStatsUpdate(t *testing.T) {
	// Create dashboard
	dashboard := New("http://localhost:8000")
	
	// Simulate multiple requests by directly calling the stats methods
	events := []struct {
		statusCode int
		duration   time.Duration
	}{
		{200, 100 * time.Millisecond},
		{200, 50 * time.Millisecond},
		{400, 200 * time.Millisecond},
	}
	
	// Record events directly
	for i, event := range events {
		dashboard.stats.RecordRequest(event.statusCode, event.duration)
		dashboard.requestLog.Add(RequestEvent{
			Method:     "POST",
			Path:       "/v1/messages",
			StatusCode: event.statusCode,
			Duration:   event.duration,
			Timestamp:  time.Now().Add(time.Duration(i) * time.Second),
			Size:       1024,
		})
	}
	
	// Get stats
	stats := dashboard.stats.GetStats()
	
	// Verify all requests were recorded
	assert.Equal(t, int64(3), stats.TotalRequests, "Should have recorded 3 requests")
	assert.Equal(t, int64(2), stats.SuccessCount, "Should have 2 successful requests")
	assert.Equal(t, int64(1), stats.ErrorCount, "Should have 1 error request")
	
	// Verify request log has all entries
	requests := dashboard.requestLog.GetRequests(10)
	assert.Len(t, requests, 3, "Request log should contain 3 entries")
}

func TestDashboard_EventProcessing(t *testing.T) {
	// Create dashboard model
	model := New("http://localhost:8000")
	
	// Initialize the model
	initCmd := model.Init()
	assert.NotNil(t, initCmd, "Init should return commands")
	
	// Simulate sending multiple events through Update
	events := []RequestEvent{
		{
			Method:     "POST",
			Path:       "/v1/messages",
			StatusCode: 200,
			Duration:   100 * time.Millisecond,
			Timestamp:  time.Now(),
			Size:       1024,
		},
		{
			Method:     "GET",
			Path:       "/v1/models",
			StatusCode: 200,
			Duration:   50 * time.Millisecond,
			Timestamp:  time.Now().Add(1 * time.Second),
			Size:       512,
		},
	}
	
	// Process first event
	updatedModel, cmd := model.Update(events[0])
	model = updatedModel.(*Model)
	
	// Verify first event was processed
	stats := model.stats.GetStats()
	assert.Equal(t, int64(1), stats.TotalRequests, "Should have 1 request after first event")
	
	// Check if we have a command to continue listening
	assert.NotNil(t, cmd, "Should return a command to continue listening")
	
	// Process second event
	updatedModel, cmd = model.Update(events[1])
	model = updatedModel.(*Model)
	
	// Verify second event was processed
	stats = model.stats.GetStats()
	assert.Equal(t, int64(2), stats.TotalRequests, "Should have 2 requests after second event")
	
	// Should still have a command to continue listening
	assert.NotNil(t, cmd, "Should continue to return listening command")
}

func TestDashboard_RequestsPerSecondUpdate(t *testing.T) {
	dashboard := New("http://localhost:8000")
	
	// Record first request directly
	dashboard.stats.RecordRequest(200, 100*time.Millisecond)
	
	// Check initial rate
	stats1 := dashboard.stats.GetStats()
	assert.Greater(t, stats1.ReqPerSecond, 0.0, "Should have non-zero rate after first request")
	initialRate := stats1.ReqPerSecond
	t.Logf("Initial rate after 1 request: %.3f req/s", initialRate)
	
	// Record second request after 2 seconds
	time.Sleep(2 * time.Second)
	dashboard.stats.RecordRequest(200, 150*time.Millisecond)
	
	// Check updated rate
	stats2 := dashboard.stats.GetStats()
	t.Logf("Rate after 2 requests (2s apart): %.3f req/s", stats2.ReqPerSecond)
	
	// With 2 requests over ~2 seconds, rate should be around 1 req/s
	assert.NotEqual(t, initialRate, stats2.ReqPerSecond, "Rate should change after second request")
	assert.Greater(t, stats2.ReqPerSecond, 0.5, "Rate should be reasonable for 2 requests in 2 seconds")
	assert.Less(t, stats2.ReqPerSecond, 1.5, "Rate should be reasonable for 2 requests in 2 seconds")
}
// End of internal/ui/dashboard/dashboard_test.go

=====================

// File: internal/ui/dashboard/request_log.go

package dashboard

import (
	"fmt"
	"strings"
	"sync"
	"time"
)

// RequestEvent represents a single request
type RequestEvent struct {
	ID         string
	Method     string
	Path       string
	StatusCode int
	Duration   time.Duration
	Timestamp  time.Time
	Error      string
	Size       int64
}

// RequestLog maintains a ring buffer of recent requests
type RequestLog struct {
	mu       sync.RWMutex
	requests []RequestEvent
	maxSize  int
	head     int
	count    int
	filter   RequestFilter
}

// RequestFilter defines filtering criteria
type RequestFilter struct {
	StatusCode   int
	Method       string
	PathContains string
	ShowErrors   bool
}

// NewRequestLog creates a new request log
func NewRequestLog(maxSize int) *RequestLog {
	if maxSize <= 0 {
		maxSize = 1000
	}
	return &RequestLog{
		requests: make([]RequestEvent, maxSize),
		maxSize:  maxSize,
	}
}

// Add adds a new request to the log
func (l *RequestLog) Add(event RequestEvent) {
	l.mu.Lock()
	defer l.mu.Unlock()
	
	l.requests[l.head] = event
	l.head = (l.head + 1) % l.maxSize
	if l.count < l.maxSize {
		l.count++
	}
}

// GetRequests returns filtered requests
func (l *RequestLog) GetRequests(limit int) []RequestEvent {
	l.mu.RLock()
	defer l.mu.RUnlock()
	
	if limit <= 0 || limit > l.count {
		limit = l.count
	}
	
	result := make([]RequestEvent, 0, limit)
	
	// Start from the most recent
	start := l.head - 1
	if start < 0 {
		start = l.maxSize - 1
	}
	
	for i := 0; i < l.count && len(result) < limit; i++ {
		idx := (start - i + l.maxSize) % l.maxSize
		req := l.requests[idx]
		
		// Apply filter
		if l.matchesFilter(req) {
			result = append(result, req)
		}
	}
	
	return result
}

// SetFilter updates the filter
func (l *RequestLog) SetFilter(filter RequestFilter) {
	l.mu.Lock()
	defer l.mu.Unlock()
	l.filter = filter
}

// matchesFilter checks if a request matches the current filter
func (l *RequestLog) matchesFilter(req RequestEvent) bool {
	// Status code filter
	if l.filter.StatusCode > 0 && req.StatusCode != l.filter.StatusCode {
		return false
	}
	
	// Method filter
	if l.filter.Method != "" && req.Method != l.filter.Method {
		return false
	}
	
	// Path filter
	if l.filter.PathContains != "" && !strings.Contains(req.Path, l.filter.PathContains) {
		return false
	}
	
	// Error filter
	if l.filter.ShowErrors && req.Error == "" {
		return false
	}
	
	return true
}

// Clear clears the log
func (l *RequestLog) Clear() {
	l.mu.Lock()
	defer l.mu.Unlock()
	
	l.head = 0
	l.count = 0
	l.requests = make([]RequestEvent, l.maxSize)
}

// FormatRequest formats a request for display
func FormatRequest(req RequestEvent) string {
	// Status with color indicator
	var statusStr string
	if req.StatusCode >= 200 && req.StatusCode < 300 {
		statusStr = fmt.Sprintf("2%02d", req.StatusCode%100)
	} else if req.StatusCode >= 300 && req.StatusCode < 400 {
		statusStr = fmt.Sprintf("3%02d", req.StatusCode%100)
	} else if req.StatusCode >= 400 && req.StatusCode < 500 {
		statusStr = fmt.Sprintf("4%02d", req.StatusCode%100)
	} else {
		statusStr = fmt.Sprintf("5%02d", req.StatusCode%100)
	}
	
	// Format duration
	durStr := fmt.Sprintf("%4dms", req.Duration.Milliseconds())
	
	// Format size
	sizeStr := formatBytes(req.Size)
	
	// Timestamp
	timeStr := req.Timestamp.Format("15:04:05")
	
	// Path (truncate if needed)
	path := req.Path
	if len(path) > 40 {
		path = path[:37] + "..."
	}
	
	return fmt.Sprintf("%s %s %s %s %s %-40s",
		timeStr, req.Method, statusStr, durStr, sizeStr, path)
}

// formatBytes formats bytes into human readable format
func formatBytes(bytes int64) string {
	const unit = 1024
	if bytes < unit {
		return fmt.Sprintf("%4dB ", bytes)
	}
	div, exp := int64(unit), 0
	for n := bytes / unit; n >= unit; n /= unit {
		div *= unit
		exp++
	}
	return fmt.Sprintf("%3.0f%cB",
		float64(bytes)/float64(div), "KMGTPE"[exp])
}
// End of internal/ui/dashboard/request_log.go

=====================

// File: internal/ui/dashboard/stats.go

package dashboard

import (
	"fmt"
	"math"
	"sync"
	"time"
)

// RequestStats holds statistics about requests
type RequestStats struct {
	mu            sync.RWMutex
	totalRequests int64
	successCount  int64
	errorCount    int64
	avgDuration   time.Duration
	reqPerSecond  float64
	lastUpdate    time.Time
	
	// Time buckets for rate calculation
	recentRequests []time.Time
	windowSize     time.Duration
}

// NewRequestStats creates a new statistics tracker
func NewRequestStats() *RequestStats {
	return &RequestStats{
		recentRequests: make([]time.Time, 0, 1000),
		windowSize:     time.Minute,
		lastUpdate:     time.Now(),
	}
}

// RecordRequest records a new request
func (s *RequestStats) RecordRequest(statusCode int, duration time.Duration) {
	s.mu.Lock()
	defer s.mu.Unlock()
	
	now := time.Now()
	s.totalRequests++
	
	if statusCode >= 200 && statusCode < 400 {
		s.successCount++
	} else if statusCode >= 400 {
		s.errorCount++
	}
	
	// Update average duration
	if s.avgDuration == 0 {
		s.avgDuration = duration
	} else {
		// Simple moving average
		s.avgDuration = (s.avgDuration + duration) / 2
	}
	
	// Add to recent requests
	s.recentRequests = append(s.recentRequests, now)
	
	// Calculate requests per second BEFORE cleaning
	// This ensures we calculate rate including the new request
	if len(s.recentRequests) >= 1 {
		// For rate calculation, use the full window or actual span, whichever is smaller
		var timeSpan float64
		
		if len(s.recentRequests) == 1 {
			// For single request, calculate rate based on window
			timeSpan = s.windowSize.Seconds()
		} else {
			// For multiple requests, use actual time span
			actualSpan := now.Sub(s.recentRequests[0]).Seconds()
			windowSpan := s.windowSize.Seconds()
			timeSpan = math.Min(actualSpan, windowSpan)
		}
		
		// Ensure minimum time span to avoid very high rates
		if timeSpan < 1.0 {
			timeSpan = 1.0
		}
		
		s.reqPerSecond = float64(len(s.recentRequests)) / timeSpan
	} else {
		s.reqPerSecond = 0.0
	}
	
	// Clean old requests outside window AFTER calculation
	cutoff := now.Add(-s.windowSize)
	i := 0
	for i < len(s.recentRequests) && s.recentRequests[i].Before(cutoff) {
		i++
	}
	if i > 0 {
		s.recentRequests = s.recentRequests[i:]
	}
	
	s.lastUpdate = now
}

// GetStats returns current statistics
func (s *RequestStats) GetStats() Stats {
	s.mu.RLock()
	defer s.mu.RUnlock()
	
	return Stats{
		TotalRequests: s.totalRequests,
		SuccessCount:  s.successCount,
		ErrorCount:    s.errorCount,
		AvgDuration:   s.avgDuration,
		ReqPerSecond:  s.reqPerSecond,
		LastUpdate:    s.lastUpdate,
	}
}

// Stats represents a snapshot of statistics
type Stats struct {
	TotalRequests int64
	SuccessCount  int64
	ErrorCount    int64
	AvgDuration   time.Duration
	ReqPerSecond  float64
	LastUpdate    time.Time
}

// String returns a formatted string of the stats
func (s Stats) String() string {
	successRate := float64(0)
	if s.TotalRequests > 0 {
		successRate = float64(s.SuccessCount) / float64(s.TotalRequests) * 100
	}
	
	return fmt.Sprintf(
		"Total: %d | Success: %.1f%% | Avg: %s | Rate: %.1f req/s",
		s.TotalRequests,
		successRate,
		s.AvgDuration.Round(time.Millisecond),
		s.ReqPerSecond,
	)
}
// End of internal/ui/dashboard/stats.go

=====================

// File: internal/ui/dashboard/stats_test.go

package dashboard

import (
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
)

func TestRequestStats_SingleRequest(t *testing.T) {
	stats := NewRequestStats()
	
	// Record a single request
	stats.RecordRequest(200, 100*time.Millisecond)
	
	result := stats.GetStats()
	
	assert.Equal(t, int64(1), result.TotalRequests)
	assert.Equal(t, int64(1), result.SuccessCount)
	assert.Equal(t, int64(0), result.ErrorCount)
	assert.Equal(t, 100*time.Millisecond, result.AvgDuration)
	
	// Check that req/sec is NOT zero for a single request
	assert.Greater(t, result.ReqPerSecond, 0.0, "ReqPerSecond should be greater than 0 for a single request")
	
	// For a 60-second window, 1 request should give ~0.0167 req/s
	expectedRate := 1.0 / 60.0
	assert.InDelta(t, expectedRate, result.ReqPerSecond, 0.001, "Rate should be approximately 1/60 for a single request")
}

func TestRequestStats_MultipleRequests(t *testing.T) {
	stats := NewRequestStats()
	
	// Record multiple requests quickly
	stats.RecordRequest(200, 100*time.Millisecond)
	time.Sleep(100 * time.Millisecond)
	stats.RecordRequest(200, 150*time.Millisecond)
	time.Sleep(100 * time.Millisecond)
	stats.RecordRequest(200, 200*time.Millisecond)
	
	result := stats.GetStats()
	
	assert.Equal(t, int64(3), result.TotalRequests)
	assert.Equal(t, int64(3), result.SuccessCount)
	
	// For 3 requests over ~0.2 seconds, rate should be around 15 req/s
	// But with minimum timespan of 1 second, it should be 3 req/s
	assert.Greater(t, result.ReqPerSecond, 0.0)
	assert.LessOrEqual(t, result.ReqPerSecond, 3.0, "Rate should not exceed 3 req/s with 1-second minimum")
}

func TestRequestStats_ErrorRequests(t *testing.T) {
	stats := NewRequestStats()
	
	stats.RecordRequest(200, 100*time.Millisecond)
	stats.RecordRequest(404, 50*time.Millisecond)
	stats.RecordRequest(500, 200*time.Millisecond)
	
	result := stats.GetStats()
	
	assert.Equal(t, int64(3), result.TotalRequests)
	assert.Equal(t, int64(1), result.SuccessCount)
	assert.Equal(t, int64(2), result.ErrorCount)
}

func TestRequestStats_WindowCleaning(t *testing.T) {
	stats := &RequestStats{
		recentRequests: make([]time.Time, 0, 1000),
		windowSize:     5 * time.Second, // Short window for testing
		lastUpdate:     time.Now(),
	}
	
	// Add a request
	stats.RecordRequest(200, 100*time.Millisecond)
	
	// Check initial state
	result1 := stats.GetStats()
	assert.Greater(t, result1.ReqPerSecond, 0.0)
	
	// Wait for window to expire
	time.Sleep(6 * time.Second)
	
	// Add another request
	stats.RecordRequest(200, 100*time.Millisecond)
	
	// Should have cleaned old request but still show rate for new one
	result2 := stats.GetStats()
	assert.Greater(t, result2.ReqPerSecond, 0.0)
}

func TestRequestStats_ReqPerSecondCalculation(t *testing.T) {
	tests := []struct {
		name           string
		windowSize     time.Duration
		requests       int
		timeBetween    time.Duration
		expectedMinRate float64
		expectedMaxRate float64
	}{
		{
			name:           "Single request in 60s window",
			windowSize:     60 * time.Second,
			requests:       1,
			timeBetween:    0,
			expectedMinRate: 0.016,  // 1/60
			expectedMaxRate: 0.018,
		},
		{
			name:           "Two requests 1 second apart",
			windowSize:     60 * time.Second,
			requests:       2,
			timeBetween:    1 * time.Second,
			expectedMinRate: 1.9,    // ~2 requests / 1 second
			expectedMaxRate: 2.1,
		},
		{
			name:           "Five requests 100ms apart",
			windowSize:     60 * time.Second,
			requests:       5,
			timeBetween:    100 * time.Millisecond,
			expectedMinRate: 4.5,    // 5 requests / 1 second (minimum timespan)
			expectedMaxRate: 5.5,
		},
	}
	
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			stats := &RequestStats{
				recentRequests: make([]time.Time, 0, 1000),
				windowSize:     tt.windowSize,
				lastUpdate:     time.Now(),
			}
			
			// Record requests
			for i := 0; i < tt.requests; i++ {
				stats.RecordRequest(200, 100*time.Millisecond)
				if i < tt.requests-1 {
					time.Sleep(tt.timeBetween)
				}
			}
			
			result := stats.GetStats()
			
			assert.GreaterOrEqual(t, result.ReqPerSecond, tt.expectedMinRate,
				"Rate should be at least %f, got %f", tt.expectedMinRate, result.ReqPerSecond)
			assert.LessOrEqual(t, result.ReqPerSecond, tt.expectedMaxRate,
				"Rate should be at most %f, got %f", tt.expectedMaxRate, result.ReqPerSecond)
		})
	}
}

// Test to debug the exact issue
func TestRequestStats_DebugZeroRate(t *testing.T) {
	stats := NewRequestStats()
	
	// Manually inspect what happens
	t.Logf("Initial state: recentRequests=%d, windowSize=%v", 
		len(stats.recentRequests), stats.windowSize)
	
	// Record one request
	stats.RecordRequest(200, 3601*time.Millisecond)
	
	// Get the stats
	result := stats.GetStats()
	
	t.Logf("After request: totalRequests=%d, recentRequests=%d, reqPerSecond=%f",
		result.TotalRequests, len(stats.recentRequests), result.ReqPerSecond)
	
	// This MUST not be zero
	assert.NotEqual(t, 0.0, result.ReqPerSecond, 
		"ReqPerSecond is 0.0! recentRequests length: %d", len(stats.recentRequests))
}
// End of internal/ui/dashboard/stats_test.go

=====================

// File: internal/ui/oauth_flow.go

package ui

import (
	"fmt"
	"strings"
	"time"

	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/bubbles/textinput"
	"github.com/charmbracelet/lipgloss"
	"github.com/ml0-1337/claude-gate/internal/ui/styles"
)

// OAuthStep represents a step in the OAuth flow
type OAuthStep int

const (
	StepGenerateURL OAuthStep = iota
	StepOpenBrowser
	StepEnterCode
	StepExchangeToken
	StepSaveToken
)

// OAuthFlowModel represents the OAuth flow UI
type OAuthFlowModel struct {
	currentStep OAuthStep
	authURL     string
	textInput   textinput.Model
	code        string
	err         error
	done        bool
	canceled    bool
	
	// Channels for communication
	codeChan chan string
	errChan  chan error
}

// NewOAuthFlow creates a new OAuth flow model
func NewOAuthFlow() *OAuthFlowModel {
	ti := textinput.New()
	ti.Placeholder = "Enter the authorization code"
	ti.Focus()
	ti.CharLimit = 100
	ti.Width = 60

	return &OAuthFlowModel{
		currentStep: StepGenerateURL,
		textInput:   ti,
		codeChan:    make(chan string, 1),
		errChan:     make(chan error, 1),
	}
}

// Init initializes the OAuth flow
func (m *OAuthFlowModel) Init() tea.Cmd {
	return textinput.Blink
}

// Update handles OAuth flow updates
func (m *OAuthFlowModel) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	var cmd tea.Cmd

	switch msg := msg.(type) {
	case tea.KeyMsg:
		switch msg.Type {
		case tea.KeyCtrlC, tea.KeyEsc:
			m.canceled = true
			close(m.codeChan)
			return m, tea.Quit
		case tea.KeyEnter:
			if m.currentStep == StepEnterCode && m.textInput.Value() != "" {
				m.code = m.textInput.Value()
				m.codeChan <- m.code
				m.currentStep = StepExchangeToken
				return m, nil
			}
		}

	case AuthURLMsg:
		m.authURL = msg.URL
		m.currentStep = StepOpenBrowser
		// Try to open browser
		go TryOpenBrowser(msg.URL)
		// Auto-advance after showing URL
		return m, tea.Tick(2*time.Second, func(time.Time) tea.Msg {
			return AdvanceStepMsg{}
		})

	case AdvanceStepMsg:
		if m.currentStep == StepOpenBrowser {
			m.currentStep = StepEnterCode
		}

	case AuthProgressMsg:
		m.currentStep = msg.Step

	case AuthErrorMsg:
		m.err = msg.Error
		m.errChan <- msg.Error
		return m, tea.Quit

	case AuthCompleteMsg:
		m.done = true
		close(m.codeChan)
		return m, tea.Quit
	}

	// Update text input when entering code
	if m.currentStep == StepEnterCode {
		m.textInput, cmd = m.textInput.Update(msg)
	}

	return m, cmd
}

// View renders the OAuth flow UI
func (m *OAuthFlowModel) View() string {
	if m.done {
		return styles.SuccessStyle.Render("\n✓ Authentication complete!")
	}

	if m.canceled {
		return styles.WarningStyle.Render("\nAuthentication canceled.")
	}

	var s strings.Builder

	// Title
	title := styles.TitleStyle.Render("🔐 Claude Pro/Max OAuth Authentication")
	s.WriteString("\n" + title + "\n\n")

	// Progress indicator
	steps := []struct {
		step OAuthStep
		name string
	}{
		{StepGenerateURL, "Generate authorization URL"},
		{StepOpenBrowser, "Open browser for authentication"},
		{StepEnterCode, "Enter authorization code"},
		{StepExchangeToken, "Exchange code for tokens"},
		{StepSaveToken, "Save tokens securely"},
	}

	for _, step := range steps {
		var icon string
		var style lipgloss.Style

		if step.step < m.currentStep {
			icon = "✓"
			style = styles.SuccessStyle
		} else if step.step == m.currentStep {
			if m.err != nil && step.step == m.currentStep {
				icon = "✗"
				style = styles.ErrorStyle
			} else {
				icon = "◐"
				style = styles.InfoStyle
			}
		} else {
			icon = "○"
			style = styles.DescriptionStyle
		}

		s.WriteString(fmt.Sprintf("%s %s\n", style.Render(icon), style.Render(step.name)))
	}

	s.WriteString("\n")

	// Show content based on current step
	switch m.currentStep {
	case StepOpenBrowser:
		if m.authURL != "" {
			s.WriteString(styles.InfoStyle.Render("Opening browser to authorization page...") + "\n")
			s.WriteString(styles.DescriptionStyle.Render("If the browser doesn't open, please visit this URL manually:") + "\n\n")
			
			// URL box
			urlBox := lipgloss.NewStyle().
				Border(lipgloss.RoundedBorder()).
				BorderForeground(styles.Primary).
				Padding(1, 2).
				Width(min(len(m.authURL)+4, 100))
			
			s.WriteString(urlBox.Render(m.authURL) + "\n\n")
		}

	case StepEnterCode:
		if m.authURL != "" {
			s.WriteString(styles.SubtitleStyle.Render("Waiting for authorization...") + "\n\n")
			s.WriteString(styles.InfoStyle.Render("After authorizing, you'll receive a code.") + "\n")
			s.WriteString(styles.InfoStyle.Render("Enter it below:") + "\n\n")
			s.WriteString(m.textInput.View() + "\n\n")
			s.WriteString(styles.HelpStyle.Render("Press Enter to submit, Esc to cancel"))
		}

	case StepExchangeToken:
		s.WriteString(styles.InfoStyle.Render("Exchanging authorization code for tokens..."))

	case StepSaveToken:
		s.WriteString(styles.InfoStyle.Render("Saving tokens securely..."))
	}

	// Show error if any
	if m.err != nil {
		s.WriteString("\n\n" + styles.ErrorStyle.Render("Error: "+m.err.Error()))
	}

	return s.String()
}

// Message types

type AuthURLMsg struct {
	URL string
}

type AdvanceStepMsg struct{}

type AuthProgressMsg struct {
	Step OAuthStep
}

type AuthErrorMsg struct {
	Error error
}

type AuthCompleteMsg struct{}

// RunOAuthFlow runs the interactive OAuth flow and returns the authorization code
func RunOAuthFlow(authURL string) (string, error) {
	model := NewOAuthFlow()
	p := tea.NewProgram(model, tea.WithAltScreen())

	// Send the auth URL to the model
	go func() {
		time.Sleep(100 * time.Millisecond) // Small delay to ensure program is ready
		p.Send(AuthURLMsg{URL: authURL})
	}()

	// Run the program in a goroutine
	go func() {
		if _, err := p.Run(); err != nil {
			model.errChan <- err
		}
	}()

	// Wait for either code or error
	select {
	case code := <-model.codeChan:
		return code, nil
	case err := <-model.errChan:
		return "", err
	}
}

// Helper to update progress from outside
func UpdateOAuthProgress(p *tea.Program, step OAuthStep) {
	p.Send(AuthProgressMsg{Step: step})
}

// Helper to signal completion
func CompleteOAuthFlow(p *tea.Program) {
	p.Send(AuthCompleteMsg{})
}

// Helper to signal error
func ErrorOAuthFlow(p *tea.Program, err error) {
	p.Send(AuthErrorMsg{Error: err})
}

func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}
// End of internal/ui/oauth_flow.go

=====================

// File: internal/ui/output.go

package ui

import (
	"fmt"
	"os"
	"strings"

	"github.com/ml0-1337/claude-gate/internal/ui/styles"
	"github.com/ml0-1337/claude-gate/internal/ui/utils"
)

// Output provides methods for formatted terminal output
type Output struct {
	interactive bool
	colorEnabled bool
	emojiEnabled bool
}

// NewOutput creates a new output handler
func NewOutput() *Output {
	return &Output{
		interactive:  utils.IsInteractive(),
		colorEnabled: utils.SupportsColor(),
		emojiEnabled: utils.SupportsEmoji(),
	}
}

// Success prints a success message
func (o *Output) Success(format string, args ...interface{}) {
	message := fmt.Sprintf(format, args...)
	if o.colorEnabled {
		fmt.Println(styles.RenderStatus("success", message))
	} else {
		fmt.Printf("✓ %s\n", message)
	}
}

// Error prints an error message
func (o *Output) Error(format string, args ...interface{}) {
	message := fmt.Sprintf(format, args...)
	if o.colorEnabled {
		fmt.Fprintln(os.Stderr, styles.RenderStatus("error", message))
	} else {
		fmt.Fprintf(os.Stderr, "✗ %s\n", message)
	}
}

// Warning prints a warning message
func (o *Output) Warning(format string, args ...interface{}) {
	message := fmt.Sprintf(format, args...)
	if o.colorEnabled {
		fmt.Println(styles.RenderStatus("warning", message))
	} else {
		fmt.Printf("⚠ %s\n", message)
	}
}

// Info prints an info message
func (o *Output) Info(format string, args ...interface{}) {
	message := fmt.Sprintf(format, args...)
	if o.colorEnabled {
		fmt.Println(styles.RenderStatus("info", message))
	} else {
		fmt.Printf("ℹ %s\n", message)
	}
}

// Title prints a title
func (o *Output) Title(text string) {
	if o.colorEnabled {
		fmt.Println(styles.TitleStyle.Render(text))
	} else {
		fmt.Printf("\n%s\n%s\n", text, strings.Repeat("=", len(text)))
	}
}

// Subtitle prints a subtitle
func (o *Output) Subtitle(text string) {
	if o.colorEnabled {
		fmt.Println(styles.SubtitleStyle.Render(text))
	} else {
		fmt.Printf("\n%s\n%s\n", text, strings.Repeat("-", len(text)))
	}
}

// Box prints content in a box
func (o *Output) Box(content string) {
	if o.colorEnabled {
		fmt.Println(styles.BoxStyle.Render(content))
	} else {
		lines := strings.Split(content, "\n")
		maxLen := 0
		for _, line := range lines {
			if len(line) > maxLen {
				maxLen = len(line)
			}
		}
		
		border := "+" + strings.Repeat("-", maxLen+2) + "+"
		fmt.Println(border)
		for _, line := range lines {
			fmt.Printf("| %-*s |\n", maxLen, line)
		}
		fmt.Println(border)
	}
}

// Code prints code or command examples
func (o *Output) Code(code string) {
	if o.colorEnabled {
		fmt.Println(styles.CodeStyle.Render(code))
	} else {
		fmt.Printf("  %s\n", code)
	}
}

// List prints a list of items
func (o *Output) List(items []string) {
	for _, item := range items {
		if o.colorEnabled {
			fmt.Println(styles.ListItemStyle.Render("• " + item))
		} else {
			fmt.Printf("  • %s\n", item)
		}
	}
}

// Table prints a simple table
func (o *Output) Table(headers []string, rows [][]string) {
	// Calculate column widths
	widths := make([]int, len(headers))
	for i, header := range headers {
		widths[i] = len(header)
	}
	
	for _, row := range rows {
		for i, cell := range row {
			if i < len(widths) && len(cell) > widths[i] {
				widths[i] = len(cell)
			}
		}
	}
	
	// Print headers
	headerRow := ""
	separator := ""
	for i, header := range headers {
		if i > 0 {
			headerRow += " | "
			separator += "-+-"
		}
		headerRow += fmt.Sprintf("%-*s", widths[i], header)
		separator += strings.Repeat("-", widths[i])
	}
	
	if o.colorEnabled {
		fmt.Println(styles.TitleStyle.Render(headerRow))
	} else {
		fmt.Println(headerRow)
	}
	fmt.Println(separator)
	
	// Print rows
	for _, row := range rows {
		rowStr := ""
		for i, cell := range row {
			if i > 0 {
				rowStr += " | "
			}
			if i < len(widths) {
				rowStr += fmt.Sprintf("%-*s", widths[i], cell)
			} else {
				rowStr += cell
			}
		}
		fmt.Println(rowStr)
	}
}

// IsInteractive returns true if running in interactive mode
func (o *Output) IsInteractive() bool {
	return o.interactive
}

// SetInteractive overrides the interactive mode detection
func (o *Output) SetInteractive(interactive bool) {
	o.interactive = interactive
}
// End of internal/ui/output.go

=====================

// File: internal/ui/styles/theme.go

package styles

import (
	"github.com/charmbracelet/lipgloss"
)

var (
	// Base colors
	Primary   = lipgloss.AdaptiveColor{Light: "#5A56E0", Dark: "#7C7AFF"}
	Secondary = lipgloss.AdaptiveColor{Light: "#6C6CA0", Dark: "#9E9ED1"}
	Success   = lipgloss.AdaptiveColor{Light: "#02BA84", Dark: "#02D69F"}
	Warning   = lipgloss.AdaptiveColor{Light: "#F59E0B", Dark: "#FBBF24"}
	Error     = lipgloss.AdaptiveColor{Light: "#E11D48", Dark: "#F43F5E"}
	Info      = lipgloss.AdaptiveColor{Light: "#0EA5E9", Dark: "#38BDF8"}
	Muted     = lipgloss.AdaptiveColor{Light: "#6B7280", Dark: "#9CA3AF"}

	// Text styles
	TitleStyle = lipgloss.NewStyle().
			Bold(true).
			Foreground(Primary).
			MarginBottom(1)

	SubtitleStyle = lipgloss.NewStyle().
			Foreground(Secondary).
			MarginBottom(1)

	DescriptionStyle = lipgloss.NewStyle().
				Foreground(Muted)

	// Status styles
	SuccessStyle = lipgloss.NewStyle().
			Foreground(Success)

	WarningStyle = lipgloss.NewStyle().
			Foreground(Warning)

	ErrorStyle = lipgloss.NewStyle().
			Foreground(Error).
			Bold(true)

	InfoStyle = lipgloss.NewStyle().
			Foreground(Info)

	// Box styles
	BoxStyle = lipgloss.NewStyle().
			Border(lipgloss.RoundedBorder()).
			BorderForeground(Primary).
			Padding(1, 2)

	// Progress bar styles
	ProgressBarStyle = lipgloss.NewStyle().
				Foreground(Primary).
				Background(lipgloss.Color("237"))

	ProgressEmptyStyle = lipgloss.NewStyle().
				Foreground(lipgloss.Color("237"))

	// Button styles
	ButtonStyle = lipgloss.NewStyle().
			Foreground(lipgloss.Color("255")).
			Background(Primary).
			Padding(0, 2).
			MarginRight(1)

	ButtonInactiveStyle = lipgloss.NewStyle().
				Foreground(Muted).
				Background(lipgloss.Color("237")).
				Padding(0, 2).
				MarginRight(1)

	// Input styles
	InputStyle = lipgloss.NewStyle().
			Border(lipgloss.NormalBorder()).
			BorderForeground(Primary).
			Padding(0, 1)

	InputInactiveStyle = lipgloss.NewStyle().
				Border(lipgloss.NormalBorder()).
				BorderForeground(Muted).
				Padding(0, 1)

	// Help styles
	HelpStyle = lipgloss.NewStyle().
			Foreground(Muted).
			Italic(true)

	// Code styles
	CodeStyle = lipgloss.NewStyle().
			Background(lipgloss.Color("237")).
			Padding(0, 1)

	// List styles
	ListItemStyle = lipgloss.NewStyle().
			PaddingLeft(2)

	SelectedListItemStyle = lipgloss.NewStyle().
				PaddingLeft(1).
				Foreground(Primary).
				Bold(true)
)

// StatusIcon returns an icon for a given status
func StatusIcon(status string) string {
	switch status {
	case "success":
		return SuccessStyle.Render("✓")
	case "warning":
		return WarningStyle.Render("⚠")
	case "error":
		return ErrorStyle.Render("✗")
	case "info":
		return InfoStyle.Render("ℹ")
	case "loading":
		return InfoStyle.Render("◐")
	default:
		return ""
	}
}

// RenderStatus renders a status message with an icon
func RenderStatus(status, message string) string {
	icon := StatusIcon(status)
	switch status {
	case "success":
		return icon + " " + SuccessStyle.Render(message)
	case "warning":
		return icon + " " + WarningStyle.Render(message)
	case "error":
		return icon + " " + ErrorStyle.Render(message)
	case "info":
		return icon + " " + InfoStyle.Render(message)
	default:
		return message
	}
}
// End of internal/ui/styles/theme.go

=====================

// File: internal/ui/utils/terminal.go

package utils

import (
	"fmt"
	"os"

	"github.com/mattn/go-isatty"
	"github.com/muesli/termenv"
)

// IsInteractive returns true if we're running in an interactive terminal
func IsInteractive() bool {
	return isatty.IsTerminal(os.Stdout.Fd()) || isatty.IsCygwinTerminal(os.Stdout.Fd())
}

// SupportsColor returns true if the terminal supports color output
func SupportsColor() bool {
	if !IsInteractive() {
		return false
	}
	return termenv.ColorProfile() != termenv.Ascii
}

// SupportsEmoji returns true if the terminal likely supports emoji
func SupportsEmoji() bool {
	if !IsInteractive() {
		return false
	}
	// Check if we're in a known good terminal
	term := os.Getenv("TERM_PROGRAM")
	switch term {
	case "iTerm.app", "Apple_Terminal", "vscode", "Hyper":
		return true
	}
	// Also check for modern terminal emulators on Linux
	colorTerm := os.Getenv("COLORTERM")
	if colorTerm == "truecolor" || colorTerm == "24bit" {
		return true
	}
	// Windows Terminal supports emoji
	if os.Getenv("WT_SESSION") != "" {
		return true
	}
	return false
}

// GetTerminalWidth returns the terminal width or a default value
func GetTerminalWidth() int {
	// For now, return a sensible default
	// We can enhance this later with proper terminal size detection
	return 80
}

// ClearLine clears the current line in the terminal
func ClearLine() {
	if IsInteractive() {
		fmt.Print("\r\033[K")
	}
}

// MoveCursorUp moves the cursor up n lines
func MoveCursorUp(n int) {
	if IsInteractive() {
		fmt.Printf("\033[%dA", n)
	}
}
// End of internal/ui/utils/terminal.go

=====================

// File: internal/ui/utils/terminal_test.go

package utils

import (
	"os"
	"testing"

	"github.com/stretchr/testify/assert"
)

func TestIsInteractive(t *testing.T) {
	// This test will behave differently in different environments
	// We're mainly testing that the function doesn't panic
	result := IsInteractive()
	assert.IsType(t, bool(false), result)
}

func TestSupportsColor(t *testing.T) {
	// Test that it returns false when not interactive
	// This is hard to test properly without mocking
	result := SupportsColor()
	assert.IsType(t, bool(false), result)
}

func TestSupportsEmoji(t *testing.T) {
	tests := []struct {
		name     string
		envVars  map[string]string
		expected bool
	}{
		{
			name: "iTerm",
			envVars: map[string]string{
				"TERM_PROGRAM": "iTerm.app",
			},
			expected: true,
		},
		{
			name: "VSCode",
			envVars: map[string]string{
				"TERM_PROGRAM": "vscode",
			},
			expected: true,
		},
		{
			name: "Windows Terminal",
			envVars: map[string]string{
				"WT_SESSION": "some-session-id",
			},
			expected: true,
		},
		{
			name:     "Unknown terminal",
			envVars:  map[string]string{},
			expected: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Save original env
			origTermProgram := os.Getenv("TERM_PROGRAM")
			origColorTerm := os.Getenv("COLORTERM")
			origWTSession := os.Getenv("WT_SESSION")
			
			// Clear env
			os.Unsetenv("TERM_PROGRAM")
			os.Unsetenv("COLORTERM")
			os.Unsetenv("WT_SESSION")
			
			// Set test env
			for k, v := range tt.envVars {
				os.Setenv(k, v)
			}
			
			// Only test if we're in an interactive terminal
			if IsInteractive() {
				result := SupportsEmoji()
				assert.Equal(t, tt.expected, result)
			}
			
			// Restore original env
			if origTermProgram != "" {
				os.Setenv("TERM_PROGRAM", origTermProgram)
			}
			if origColorTerm != "" {
				os.Setenv("COLORTERM", origColorTerm)
			}
			if origWTSession != "" {
				os.Setenv("WT_SESSION", origWTSession)
			}
		})
	}
}

func TestGetTerminalWidth(t *testing.T) {
	width := GetTerminalWidth()
	// Should return at least the default width
	assert.GreaterOrEqual(t, width, 80)
}
// End of internal/ui/utils/terminal_test.go

=====================

// File: LICENSE

MIT License

Copyright (c) 2025 ml0-1337

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

// End of LICENSE

=====================

// File: Makefile

.PHONY: build test test-unit test-integration test-e2e clean install release snapshot npm-test test-all test-docker test-edge help

# Default target
help:
	@echo "Claude Gate - Available targets:"
	@echo "  make build         - Build for current platform"
	@echo "  make test          - Run unit tests with coverage"
	@echo "  make test-unit     - Run unit tests only (short mode)"
	@echo "  make test-integration - Run integration tests"
	@echo "  make test-e2e      - Run end-to-end tests"
	@echo "  make test-all      - Run comprehensive test suite"
	@echo "  make snapshot      - Build snapshot release (all platforms)"
	@echo "  make npm-test      - Test NPM package locally"
	@echo "  make test-docker   - Test in Docker containers"
	@echo "  make test-edge     - Test edge cases"
	@echo "  make install       - Install locally"
	@echo "  make clean         - Clean build artifacts"
	@echo "  make release       - Create a new release (requires version)"

# Build for current platform
build:
	go build -ldflags="-s -w" -o claude-gate ./cmd/claude-gate

# Run unit tests with coverage
test:
	go test -v -race -coverprofile=coverage.out ./...
	go tool cover -func=coverage.out

# Run unit tests only (short mode)
test-unit:
	go test -short -v ./...

# Run integration tests
test-integration:
	go test -tags=integration -v ./internal/test/integration/...

# Run end-to-end tests
test-e2e: build
	go test -tags=e2e -v ./internal/test/e2e/...

# Build snapshot release with GoReleaser
snapshot:
	@if ! command -v goreleaser >/dev/null 2>&1; then \
		echo "Error: goreleaser is not installed. Install with: brew install goreleaser"; \
		exit 1; \
	fi
	goreleaser release --snapshot --clean --skip=publish
	@echo ""
	@echo "Snapshot build complete! Binaries in ./dist/"

# Test NPM package locally
npm-test: snapshot
	./scripts/test-npm-local.sh

# Run comprehensive test suite
test-all: test-unit test-integration test-e2e
	./scripts/test-all.sh

# Test in Docker containers
test-docker: snapshot
	./scripts/test-docker.sh

# Test edge cases
test-edge:
	./scripts/test-edge-cases.sh

# Install locally
install: build
	mkdir -p ~/bin
	cp claude-gate ~/bin/
	@echo "Installed to ~/bin/claude-gate"
	@echo "Make sure ~/bin is in your PATH"

# Clean build artifacts
clean:
	rm -rf dist/
	rm -f claude-gate
	rm -f coverage.out coverage.html
	rm -rf npm/node_modules/
	rm -f npm/*.tgz

# Create a new release (requires VERSION parameter)
release:
ifndef VERSION
	$(error VERSION is required. Usage: make release VERSION=0.1.0)
endif
	@echo "Creating release v$(VERSION)..."
	@echo "This will:"
	@echo "  1. Update version in code"
	@echo "  2. Commit changes"
	@echo "  3. Create tag v$(VERSION)"
	@echo "  4. Push to GitHub"
	@echo ""
	@read -p "Continue? [y/N] " -n 1 -r; \
	echo ""; \
	if [[ $$REPLY =~ ^[Yy]$$ ]]; then \
		sed -i.bak 's/version = ".*"/version = "$(VERSION)"/' cmd/claude-gate/main.go && rm cmd/claude-gate/main.go.bak; \
		sed -i.bak 's/"version": ".*"/"version": "$(VERSION)"/' npm/package.json && rm npm/package.json.bak; \
		git add -A; \
		git commit -m "chore: release v$(VERSION)"; \
		git tag -a v$(VERSION) -m "Release v$(VERSION)"; \
		echo ""; \
		echo "Release prepared! To publish:"; \
		echo "  git push origin main"; \
		echo "  git push origin v$(VERSION)"; \
	else \
		echo "Release cancelled"; \
	fi
// End of Makefile

=====================

// File: npm/index.js

/**
 * claude-gate NPM package
 * This file is not meant to be used programmatically.
 * Install this package globally and use the 'claude-gate' command.
 */

module.exports = {
  name: 'claude-gate',
  version: '0.1.0',
  description: 'OAuth proxy for Anthropic Claude API',
  
  // Display a helpful message if someone tries to require() this package
  __esModule: true,
  default: function() {
    console.error(`
claude-gate is a command-line tool and should be installed globally:

  npm install -g claude-gate

Then use it from the command line:

  claude-gate start
  claude-gate auth login
  claude-gate --help

For more information, visit:
https://github.com/ml0-1337/claude-gate
`);
    process.exit(1);
  }
};

// Show message if this file is run directly
if (require.main === module) {
  module.exports.default();
}
// End of npm/index.js

=====================

// File: npm/package.json

{
  "name": "claude-gate",
  "version": "0.1.0",
  "description": "High-performance OAuth proxy for Anthropic's Claude API - FREE usage for Pro/Max subscribers",
  "keywords": [
    "claude",
    "anthropic",
    "ai",
    "oauth",
    "proxy",
    "cli",
    "api"
  ],
  "homepage": "https://github.com/ml0-1337/claude-gate",
  "bugs": {
    "url": "https://github.com/ml0-1337/claude-gate/issues"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/ml0-1337/claude-gate.git"
  },
  "license": "MIT",
  "author": "ml0-1337",
  "main": "index.js",
  "bin": {
    "claude-gate": "./bin/claude-gate"
  },
  "scripts": {
    "postinstall": "node scripts/install.js",
    "preuninstall": "node scripts/uninstall.js"
  },
  "engines": {
    "node": ">=16.0.0"
  },
  "os": [
    "darwin",
    "linux"
  ],
  "cpu": [
    "x64",
    "arm64"
  ],
  "optionalDependencies": {
    "@claude-gate/darwin-x64": "0.1.0",
    "@claude-gate/darwin-arm64": "0.1.0",
    "@claude-gate/linux-x64": "0.1.0",
    "@claude-gate/linux-arm64": "0.1.0"
  },
  "publishConfig": {
    "access": "public",
    "registry": "https://registry.npmjs.org/"
  }
}
// End of npm/package.json

=====================

// File: npm/README.md

# Claude Gate

OAuth proxy for Anthropic's Claude API - enables FREE Claude usage for Pro/Max subscribers.

## Installation

```bash
npm install -g claude-gate
```

## Quick Start

```bash
# 1. Authenticate
claude-gate auth login

# 2. Start proxy
claude-gate start

# 3. Use with any Anthropic SDK
```

```python
import anthropic

client = anthropic.Anthropic(
    base_url="http://localhost:5789",
    api_key="sk-dummy"
)
```

## Supported Platforms

- macOS (Intel & Apple Silicon)
- Linux (x64 & ARM64)

## Documentation

Full documentation: https://github.com/ml0-1337/claude-gate

## License

MIT
// End of npm/README.md

=====================

// File: npm/scripts/install.js

#!/usr/bin/env node

const fs = require('fs');
const path = require('path');
const { promisify } = require('util');
const chmod = promisify(fs.chmod);
const mkdir = promisify(fs.mkdir);
const copyFile = promisify(fs.copyFile);

// Platform detection
function getPlatform() {
  const type = process.platform;
  const arch = process.arch;
  
  // Map Node.js platform/arch to our package naming
  const platformMap = {
    'darwin-x64': '@claude-gate/darwin-x64',
    'darwin-arm64': '@claude-gate/darwin-arm64',
    'linux-x64': '@claude-gate/linux-x64',
    'linux-arm64': '@claude-gate/linux-arm64',
  };
  
  const platformKey = `${type}-${arch}`;
  const packageName = platformMap[platformKey];
  
  if (!packageName) {
    throw new Error(
      `Unsupported platform: ${type}-${arch}\n` +
      `Supported platforms: ${Object.keys(platformMap).join(', ')}`
    );
  }
  
  return {
    type,
    arch,
    packageName,
    isWindows: type === 'win32'
  };
}

// Find the platform-specific binary
function findBinary(platform) {
  const possiblePaths = [
    // Installed as dependency
    path.join(__dirname, '..', 'node_modules', platform.packageName),
    // Installed globally
    path.join(__dirname, '..', '..', platform.packageName),
    // Development/testing
    path.join(__dirname, '..', '..', '..', 'npm-packages', platform.packageName.replace('@claude-gate/', ''))
  ];
  
  for (const basePath of possiblePaths) {
    const binaryName = platform.isWindows ? 'bin.exe' : 'bin';
    const binaryPath = path.join(basePath, binaryName);
    
    if (fs.existsSync(binaryPath)) {
      return binaryPath;
    }
  }
  
  return null;
}

// Create wrapper script for better error handling
function createWrapper(binDir, actualBinaryPath, platform) {
  const wrapperPath = path.join(binDir, 'claude-gate');
  
  if (platform.isWindows) {
    // Windows batch file
    const batchContent = `@echo off
"${actualBinaryPath}" %*
`;
    fs.writeFileSync(wrapperPath + '.cmd', batchContent);
    
    // PowerShell script for better compatibility
    const psContent = `& "${actualBinaryPath}" $args
`;
    fs.writeFileSync(wrapperPath + '.ps1', psContent);
  } else {
    // Unix shell script
    const shContent = `#!/bin/sh
exec "${actualBinaryPath}" "$@"
`;
    fs.writeFileSync(wrapperPath, shContent);
    fs.chmodSync(wrapperPath, 0o755);
  }
}

// Main installation logic
async function install() {
  console.log('Installing claude-gate...');
  
  try {
    // Detect platform
    const platform = getPlatform();
    console.log(`Platform detected: ${platform.type}-${platform.arch}`);
    
    // Find the binary
    const sourceBinary = findBinary(platform);
    if (!sourceBinary) {
      console.error(`
ERROR: Could not find platform binary for ${platform.packageName}

This might happen if:
1. The platform package failed to install
2. You're using an unsupported platform
3. Installation was run with --ignore-scripts

Try running:
  npm install ${platform.packageName}

Or download the binary manually from:
  https://github.com/ml0-1337/claude-gate/releases
`);
      process.exit(1);
    }
    
    console.log(`Found binary at: ${sourceBinary}`);
    
    // Create bin directory
    const binDir = path.join(__dirname, '..', 'bin');
    await mkdir(binDir, { recursive: true });
    
    // Copy binary to bin directory
    const targetBinary = path.join(binDir, platform.isWindows ? 'claude-gate.exe' : 'claude-gate-bin');
    await copyFile(sourceBinary, targetBinary);
    
    // Set executable permissions on Unix
    if (!platform.isWindows) {
      await chmod(targetBinary, 0o755);
    }
    
    // Create wrapper script
    createWrapper(binDir, targetBinary, platform);
    
    console.log('✅ claude-gate installed successfully!');
    console.log('Run "claude-gate --help" to get started.');
    
  } catch (error) {
    console.error('Installation failed:', error.message);
    console.error('\nFor manual installation instructions, visit:');
    console.error('https://github.com/ml0-1337/claude-gate#installation');
    process.exit(1);
  }
}

// Check if this is being run directly or as a postinstall script
if (require.main === module) {
  install().catch(error => {
    console.error('Unexpected error:', error);
    process.exit(1);
  });
}

module.exports = { install, getPlatform };
// End of npm/scripts/install.js

=====================

// File: npm/scripts/install.test.js

const assert = require('assert');
const path = require('path');
const fs = require('fs');
const { getPlatform } = require('./install.js');

// Test suite for install.js
console.log('Running install.js unit tests...\n');

let passed = 0;
let failed = 0;

function test(name, fn) {
  try {
    fn();
    console.log(`✓ ${name}`);
    passed++;
  } catch (error) {
    console.error(`✗ ${name}`);
    console.error(`  ${error.message}`);
    failed++;
  }
}

// Test getPlatform function
test('getPlatform returns correct platform info for current system', () => {
  const platform = getPlatform();
  assert(platform.type, 'Platform type should be defined');
  assert(platform.arch, 'Platform arch should be defined');
  assert(platform.packageName, 'Package name should be defined');
  assert(typeof platform.isWindows === 'boolean', 'isWindows should be boolean');
});

test('getPlatform maps darwin-x64 correctly', () => {
  const originalPlatform = process.platform;
  const originalArch = process.arch;
  
  Object.defineProperty(process, 'platform', { value: 'darwin', configurable: true });
  Object.defineProperty(process, 'arch', { value: 'x64', configurable: true });
  
  const platform = getPlatform();
  assert.strictEqual(platform.packageName, '@claude-gate/darwin-x64');
  assert.strictEqual(platform.isWindows, false);
  
  Object.defineProperty(process, 'platform', { value: originalPlatform, configurable: true });
  Object.defineProperty(process, 'arch', { value: originalArch, configurable: true });
});

test('getPlatform maps darwin-arm64 correctly', () => {
  const originalPlatform = process.platform;
  const originalArch = process.arch;
  
  Object.defineProperty(process, 'platform', { value: 'darwin', configurable: true });
  Object.defineProperty(process, 'arch', { value: 'arm64', configurable: true });
  
  const platform = getPlatform();
  assert.strictEqual(platform.packageName, '@claude-gate/darwin-arm64');
  assert.strictEqual(platform.isWindows, false);
  
  Object.defineProperty(process, 'platform', { value: originalPlatform, configurable: true });
  Object.defineProperty(process, 'arch', { value: originalArch, configurable: true });
});

test('getPlatform throws error for windows platform', () => {
  const originalPlatform = process.platform;
  const originalArch = process.arch;
  
  Object.defineProperty(process, 'platform', { value: 'win32', configurable: true });
  Object.defineProperty(process, 'arch', { value: 'x64', configurable: true });
  
  assert.throws(() => {
    getPlatform();
  }, /Unsupported platform/);
  
  Object.defineProperty(process, 'platform', { value: originalPlatform, configurable: true });
  Object.defineProperty(process, 'arch', { value: originalArch, configurable: true });
});

test('getPlatform throws error for unsupported platform', () => {
  const originalPlatform = process.platform;
  const originalArch = process.arch;
  
  Object.defineProperty(process, 'platform', { value: 'freebsd', configurable: true });
  Object.defineProperty(process, 'arch', { value: 'x64', configurable: true });
  
  assert.throws(() => {
    getPlatform();
  }, /Unsupported platform/);
  
  Object.defineProperty(process, 'platform', { value: originalPlatform, configurable: true });
  Object.defineProperty(process, 'arch', { value: originalArch, configurable: true });
});

test('getPlatform error message includes supported platforms', () => {
  const originalPlatform = process.platform;
  const originalArch = process.arch;
  
  Object.defineProperty(process, 'platform', { value: 'aix', configurable: true });
  Object.defineProperty(process, 'arch', { value: 'ppc64', configurable: true });
  
  try {
    getPlatform();
    assert.fail('Should have thrown error');
  } catch (error) {
    assert(error.message.includes('darwin-x64'), 'Error should list darwin-x64');
    assert(error.message.includes('linux-arm64'), 'Error should list linux-arm64');
  }
  
  Object.defineProperty(process, 'platform', { value: originalPlatform, configurable: true });
  Object.defineProperty(process, 'arch', { value: originalArch, configurable: true });
});

// Test file paths
test('install script uses correct relative paths', () => {
  const scriptPath = path.join(__dirname, 'install.js');
  const content = fs.readFileSync(scriptPath, 'utf8');
  
  // Check for correct relative paths
  assert(content.includes("path.join(__dirname, '..', 'bin')"), 'Should create bin in parent directory');
  assert(content.includes("path.join(__dirname, '..', 'node_modules'"), 'Should look for node_modules in parent');
});

// Summary
console.log('\n----------------------------------------');
console.log(`Total tests: ${passed + failed}`);
console.log(`Passed: ${passed}`);
console.log(`Failed: ${failed}`);
console.log('----------------------------------------\n');

if (failed > 0) {
  process.exit(1);
}
// End of npm/scripts/install.test.js

=====================

// File: npm/scripts/uninstall.js

#!/usr/bin/env node

const fs = require('fs');
const path = require('path');

function cleanup() {
  console.log('Cleaning up claude-gate...');
  
  const binDir = path.join(__dirname, '..', 'bin');
  
  // Files to remove
  const filesToRemove = [
    path.join(binDir, 'claude-gate'),
    path.join(binDir, 'claude-gate.cmd'),
    path.join(binDir, 'claude-gate.ps1'),
    path.join(binDir, 'claude-gate.exe'),
    path.join(binDir, 'claude-gate-bin')
  ];
  
  let removed = 0;
  
  filesToRemove.forEach(file => {
    try {
      if (fs.existsSync(file)) {
        fs.unlinkSync(file);
        removed++;
        console.log(`Removed: ${path.basename(file)}`);
      }
    } catch (error) {
      console.warn(`Warning: Could not remove ${file}:`, error.message);
    }
  });
  
  // Try to remove bin directory if empty
  try {
    if (fs.existsSync(binDir)) {
      const files = fs.readdirSync(binDir);
      if (files.length === 0) {
        fs.rmdirSync(binDir);
        console.log('Removed empty bin directory');
      }
    }
  } catch (error) {
    // Ignore errors when removing directory
  }
  
  if (removed > 0) {
    console.log('✅ claude-gate uninstalled successfully');
  } else {
    console.log('No files to clean up');
  }
}

// Run cleanup
if (require.main === module) {
  try {
    cleanup();
  } catch (error) {
    console.error('Uninstall error:', error.message);
    // Don't exit with error code as this might prevent npm from completing uninstall
  }
}

module.exports = { cleanup };
// End of npm/scripts/uninstall.js

=====================

// File: README.md

# Claude Gate

A high-performance Go OAuth proxy for Anthropic's Claude API that enables FREE Claude usage for Pro/Max subscribers.

## Overview

Claude Gate is a Go rewrite of claude-auth-bridge that maintains the critical OAuth bypass functionality while improving performance, security, and distribution. By identifying as "Claude Code" (Anthropic's official CLI), it allows Pro/Max subscribers to use the API without additional charges.

## Features

- ✅ **OAuth PKCE Authentication** - Secure authentication flow with Claude Pro/Max
- ✅ **System Prompt Injection** - Automatic Claude Code identification (the secret sauce!)
- ✅ **Model Alias Mapping** - Seamless handling of `latest` model aliases
- ✅ **SSE Streaming Support** - Full support for streaming responses
- ✅ **Cross-Platform** - Works on macOS and Linux
- ✅ **Interactive Dashboard** - Real-time monitoring of requests and usage
- ✅ **High Performance** - <50MB memory usage, <5ms request overhead

## Quick Start

### 1. Install

**Option A: Build from source** (Currently available)
```bash
git clone https://github.com/ml0-1337/claude-gate.git
cd claude-gate
make build
sudo mv claude-gate /usr/local/bin/
```

**Option B: NPM** (Coming soon - will be available after first release)
```bash
# npm install -g claude-gate
```

### 2. Authenticate

```bash
claude-gate auth login
```

### 3. Start Proxy

```bash
claude-gate start
```

### 4. Use with SDK

#### Using Anthropic SDK
```python
import anthropic

client = anthropic.Anthropic(
    base_url="http://localhost:5789",
    api_key="sk-dummy"  # Can be any string
)

response = client.messages.create(
    model="claude-opus-4-20250514",  # Latest Claude 4 Opus
    max_tokens=300,
    messages=[{"role": "user", "content": "Hello, Claude!"}]
)

print(response.content[0].text)
```

#### Using OpenAI SDK (compatibility mode)
```python
from openai import OpenAI

client = OpenAI(
    api_key="sk-dummy",  # Can be any string
    base_url="http://localhost:5789/v1/"  # Note the /v1/ suffix
)

response = client.chat.completions.create(
    model="claude-opus-4-20250514",  # Latest Claude 4 Opus
    messages=[
        {"role": "system", "content": "You are a helpful assistant."},
        {"role": "user", "content": "Hello, Claude!"}
    ]
)

print(response.choices[0].message.content)
```

**Note**: OpenAI SDK compatibility has some limitations. System messages are concatenated to the conversation start, and some OpenAI-specific parameters are ignored.

### 5. Using with Zed Editor

Configure Zed to use Claude Gate by adding this to your `settings.json`:

```json
{
  "language_models": {
    "anthropic": {
      "api_url": "http://127.0.0.1:5789"
    }
  }
}
```

You can find your Zed settings at:
- macOS: `~/.config/zed/settings.json`
- Linux: `~/.config/zed/settings.json`

This configuration redirects all Anthropic API calls from Zed to your local Claude Gate proxy, allowing you to use Claude in Zed for FREE with your Pro/Max subscription.

### 6. Using with Cursor IDE

Cursor requires a public HTTPS endpoint, so you'll need to create a tunnel to your local Claude Gate instance.

#### Step 1: Start Claude Gate
```bash
claude-gate start
```

#### Step 2: Create a tunnel (choose one option)

**Option A: Using Cloudflared**
```bash
cloudflared tunnel --url localhost:5789
```

**Option B: Using ngrok**
```bash
ngrok http 5789
```

Take note of the HTTPS URL provided (e.g., `https://xxxx.trycloudflare.com` or `https://xxxx.ngrok-free.app`)

#### Step 3: Configure Cursor

1. Open Cursor's settings and go to the "Models" section
2. Enter any API key in the "OpenAI API Key" field (e.g., `sk-dummy`)
3. Click the dropdown beneath the API key field labeled "Override OpenAI Base URL"
4. Enter your tunnel URL with `/v1` suffix (e.g., `https://xxxx.trycloudflare.com/v1`)
5. Click "Save" next to the URL field

#### Step 4: Configure your models

In Cursor, use the `anthropic/` prefix for Claude models:
- `anthropic/claude-opus-4-20250514` (recommended - latest Claude 4 Opus)
- `anthropic/claude-sonnet-4-20250514` (Claude 4 Sonnet)
- `anthropic/claude-3-5-sonnet-20241022` (Claude 3.5 Sonnet)
- `anthropic/claude-3-5-haiku-20241022` (Claude 3.5 Haiku)

⚠️ **Important**: When clicking "Verify" in Cursor, make sure to disable any models in Cursor's model list that aren't Claude models. Cursor randomly selects a model to test, and verification will fail if it tries a non-Claude model.

## Documentation

For detailed documentation, see the [docs](./docs) directory:

- **[Getting Started](./docs/getting-started/)** - Installation, configuration, and quick start
- **[User Guides](./docs/guides/)** - Troubleshooting, development, and contributing
- **[API Reference](./docs/reference/)** - CLI commands and HTTP API
- **[Architecture](./docs/architecture/)** - System design and security model

## Development

For development and testing:

```bash
# Prerequisites: Go 1.22+, Node.js 18+, GoReleaser
make build         # Build for current platform
make test          # Run tests
make npm-test      # Build all platforms and test NPM package
```

See our [Development Guide](./docs/guides/development.md) for detailed instructions.

## Contributing

We welcome contributions! Please see our [Contributing Guide](./docs/guides/contributing.md) for details.

## License

MIT License - see [LICENSE](./LICENSE) for details.

---

⚠️ **Disclaimer**: This project is not affiliated with Anthropic. Use at your own risk and in accordance with Claude's Terms of Service.

// End of README.md

=====================

// File: scripts/build-release.sh

#!/bin/bash
set -e

# Build script for testing GoReleaser locally

echo "🔨 Building claude-gate with GoReleaser..."

# Clean previous builds
rm -rf dist/

# Check if goreleaser is installed
if ! command -v goreleaser &> /dev/null; then
    echo "❌ GoReleaser is not installed!"
    echo "Install with: brew install goreleaser"
    exit 1
fi

# Build snapshot (without publishing)
echo "Building snapshot release..."
goreleaser build --snapshot --clean

echo ""
echo "✅ Build complete! Binaries are in ./dist/"
echo ""
echo "📦 Built archives:"
ls -la dist/*.tar.gz dist/*.zip 2>/dev/null | awk '{print "  - " $9 " (" $5 " bytes)"}'

echo ""
echo "🔍 Binary sizes:"
for binary in dist/*/claude-gate*; do
    if [[ -f "$binary" && -x "$binary" ]]; then
        size=$(ls -lh "$binary" | awk '{print $5}')
        platform=$(echo "$binary" | grep -oE '(darwin|linux|windows)_[^/]+')
        echo "  - $platform: $size"
    fi
done

echo ""
echo "To test a specific binary:"
echo "  ./dist/claude-gate_darwin_arm64/claude-gate version"
echo ""
echo "To create a real release:"
echo "  1. git tag v0.1.0"
echo "  2. git push origin v0.1.0"
echo "  3. GitHub Actions will handle the rest"
// End of scripts/build-release.sh

=====================

// File: scripts/setup-npm-auth.sh

#!/bin/bash

# Script to help set up NPM authentication for publishing

echo "🔐 NPM Authentication Setup for Claude Gate"
echo "=========================================="
echo ""
echo "This script will help you set up NPM authentication for publishing."
echo ""
echo "Prerequisites:"
echo "1. Create an npm account at https://www.npmjs.com/signup"
echo "2. Enable 2FA for publishing (required for security)"
echo "3. Create an access token at https://www.npmjs.com/settings/~/tokens"
echo "   - Choose 'Automation' token type"
echo "   - Select 'Publish' permission"
echo ""
read -p "Press Enter to continue..."

echo ""
echo "Setting up GitHub Secrets"
echo "========================"
echo ""
echo "You need to add the NPM token as a GitHub secret:"
echo ""
echo "1. Go to: https://github.com/ml0-1337/claude-gate/settings/secrets/actions"
echo "2. Click 'New repository secret'"
echo "3. Name: NPM_TOKEN"
echo "4. Value: [paste your npm token]"
echo ""
echo "The GitHub Actions workflow will use this token to publish packages."
echo ""

echo "Local Publishing Setup (Optional)"
echo "================================"
echo ""
echo "To publish manually from your local machine:"
echo ""
echo "1. Login to npm:"
echo "   npm login"
echo ""
echo "2. Verify you're logged in:"
echo "   npm whoami"
echo ""
echo "3. To publish (after building):"
echo "   cd npm && npm publish --access public"
echo ""

echo "Publishing Checklist"
echo "==================="
echo ""
echo "Before publishing:"
echo "[ ] Update version in cmd/claude-gate/main.go"
echo "[ ] Update version in npm/package.json"
echo "[ ] Update version in all platform packages"
echo "[ ] Run tests: make test"
echo "[ ] Build snapshot: make snapshot"
echo "[ ] Test npm locally: make npm-test"
echo "[ ] Commit all changes"
echo "[ ] Create and push tag: git tag v0.1.0 && git push origin v0.1.0"
echo ""
echo "The GitHub Actions workflow will handle the rest!"
// End of scripts/setup-npm-auth.sh

=====================

// File: scripts/test-all.sh

#!/bin/bash
# Comprehensive test script for Claude Gate cross-platform builds and NPM distribution

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Test results
PASSED=0
FAILED=0
SKIPPED=0

# Get script directory
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
REPO_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"

# Test result tracking (use arrays for compatibility)
TEST_NAMES=()
TEST_STATUSES=()

# Helper functions
log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[PASS]${NC} $1"
    ((PASSED++))
    TEST_NAMES+=("$1")
    TEST_STATUSES+=("PASSED")
}

log_error() {
    echo -e "${RED}[FAIL]${NC} $1"
    ((FAILED++))
    TEST_NAMES+=("$1")
    TEST_STATUSES+=("FAILED")
}

log_warning() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

log_skip() {
    echo -e "${YELLOW}[SKIP]${NC} $1"
    ((SKIPPED++))
    TEST_NAMES+=("$1")
    TEST_STATUSES+=("SKIPPED")
}

# Check prerequisites
check_prerequisites() {
    log_info "Checking prerequisites..."
    
    local prereqs_met=true
    
    # Check Go
    if command -v go >/dev/null 2>&1; then
        log_success "Go installed: $(go version)"
    else
        log_error "Go not installed"
        prereqs_met=false
    fi
    
    # Check Node.js
    if command -v node >/dev/null 2>&1; then
        log_success "Node.js installed: $(node --version)"
    else
        log_error "Node.js not installed"
        prereqs_met=false
    fi
    
    # Check npm
    if command -v npm >/dev/null 2>&1; then
        log_success "npm installed: $(npm --version)"
    else
        log_error "npm not installed"
        prereqs_met=false
    fi
    
    # Check GoReleaser
    if command -v goreleaser >/dev/null 2>&1; then
        log_success "GoReleaser installed: $(goreleaser --version | head -1)"
    else
        log_warning "GoReleaser not installed - some tests will be skipped"
    fi
    
    if [ "$prereqs_met" = false ]; then
        log_error "Missing prerequisites. Please install required tools."
        exit 1
    fi
}

# Test 1: Go build and tests
test_go_build() {
    log_info "Testing Go build and unit tests..."
    
    cd "$REPO_ROOT"
    
    # Run Go tests
    if go test -v -race ./... >/dev/null 2>&1; then
        log_success "Go unit tests"
    else
        log_error "Go unit tests"
        return 1
    fi
    
    # Test basic build
    if go build -o claude-gate-test ./cmd/claude-gate; then
        log_success "Go build"
        rm -f claude-gate-test
    else
        log_error "Go build"
        return 1
    fi
}

# Test 2: GoReleaser snapshot build
test_goreleaser_build() {
    log_info "Testing GoReleaser snapshot build..."
    
    if ! command -v goreleaser >/dev/null 2>&1; then
        log_skip "GoReleaser build (not installed)"
        return 0
    fi
    
    cd "$REPO_ROOT"
    
    # Clean previous builds
    rm -rf dist/
    
    # Run snapshot build
    if goreleaser build --snapshot --clean >/dev/null 2>&1; then
        log_success "GoReleaser snapshot build"
        
        # Verify expected files exist
        local expected_files=(
            "dist/claude-gate_darwin_amd64_v1/claude-gate"
            "dist/claude-gate_darwin_arm64/claude-gate"
            "dist/claude-gate_linux_amd64_v1/claude-gate"
            "dist/claude-gate_linux_arm64/claude-gate"
            # "dist/claude-gate_windows_amd64_v1/claude-gate.exe"  # Windows not supported
        )
        
        for file in "${expected_files[@]}"; do
            if [ -f "$file" ]; then
                log_success "Binary created: $file"
            else
                log_error "Binary missing: $file"
            fi
        done
        
        # Check binary sizes
        log_info "Binary sizes:"
        find dist -name "claude-gate*" -type f -exec ls -lh {} \; | awk '{print "  " $9 ": " $5}'
        
    else
        log_error "GoReleaser snapshot build"
        return 1
    fi
}

# Test 3: NPM package structure
test_npm_package_structure() {
    log_info "Testing NPM package structure..."
    
    cd "$REPO_ROOT"
    
    # Check required files
    local required_files=(
        "npm/package.json"
        "npm/index.js"
        "npm/scripts/install.js"
        "npm/scripts/uninstall.js"
        "npm/bin/claude-gate"
    )
    
    for file in "${required_files[@]}"; do
        if [ -f "$file" ]; then
            log_success "File exists: $file"
        else
            log_error "File missing: $file"
        fi
    done
    
    # Check platform packages
    local platforms=(
        "darwin-x64"
        "darwin-arm64"
        "linux-x64"
        "linux-arm64"
    )
    
    for platform in "${platforms[@]}"; do
        if [ -f "npm/platforms/$platform/package.json" ]; then
            log_success "Platform package: $platform"
        else
            log_error "Platform package missing: $platform"
        fi
    done
}

# Test 4: NPM install script
test_npm_install_script() {
    log_info "Testing NPM install script..."
    
    cd "$REPO_ROOT/npm"
    
    # Test platform detection
    local platform_output=$(node -e "const {getPlatform} = require('./scripts/install.js'); console.log(JSON.stringify(getPlatform()))" 2>&1)
    
    if [[ $? -eq 0 ]]; then
        log_success "Platform detection works: $platform_output"
    else
        log_error "Platform detection failed"
        return 1
    fi
    
    # Test install script syntax
    if node -c scripts/install.js 2>/dev/null; then
        log_success "Install script syntax valid"
    else
        log_error "Install script syntax error"
        return 1
    fi
    
    # Test uninstall script syntax
    if node -c scripts/uninstall.js 2>/dev/null; then
        log_success "Uninstall script syntax valid"
    else
        log_error "Uninstall script syntax error"
        return 1
    fi
}

# Test 5: Local NPM package
test_npm_local_package() {
    log_info "Testing local NPM package creation..."
    
    if [ ! -d "$REPO_ROOT/dist" ]; then
        log_skip "NPM local package test (no binaries built)"
        return 0
    fi
    
    cd "$REPO_ROOT"
    
    # Run the test script
    if ./scripts/test-npm-local.sh >/dev/null 2>&1; then
        log_success "Local NPM package test"
    else
        log_error "Local NPM package test"
        return 1
    fi
}

# Test 6: Package.json validation
test_package_json_validation() {
    log_info "Testing package.json files..."
    
    cd "$REPO_ROOT"
    
    # Main package.json
    if node -e "JSON.parse(require('fs').readFileSync('npm/package.json'))" 2>/dev/null; then
        log_success "Main package.json valid"
    else
        log_error "Main package.json invalid"
    fi
    
    # Check version consistency
    local main_version=$(node -e "console.log(require('./npm/package.json').version)")
    local go_version=$(grep -E 'var version = ".*"' cmd/claude-gate/main.go | sed 's/.*"\(.*\)".*/\1/')
    
    if [ "$main_version" = "$go_version" ]; then
        log_success "Version consistency: $main_version"
    else
        log_error "Version mismatch: npm=$main_version, go=$go_version"
    fi
    
    # Platform packages
    for platform in darwin-x64 darwin-arm64 linux-x64 linux-arm64; do
        if node -e "JSON.parse(require('fs').readFileSync('npm/platforms/$platform/package.json'))" 2>/dev/null; then
            log_success "Platform package.json valid: $platform"
        else
            log_error "Platform package.json invalid: $platform"
        fi
    done
}

# Test 7: GitHub Actions workflow
test_github_actions() {
    log_info "Testing GitHub Actions workflow..."
    
    cd "$REPO_ROOT"
    
    # Check workflow file exists
    if [ -f ".github/workflows/release.yml" ]; then
        log_success "Release workflow exists"
        
        # Basic YAML validation
        if command -v python3 >/dev/null 2>&1; then
            # Check if PyYAML is installed
            if python3 -c "import yaml" 2>/dev/null; then
                if python3 -c "import yaml; yaml.safe_load(open('.github/workflows/release.yml'))" 2>/dev/null; then
                    log_success "Release workflow YAML valid"
                else
                    log_error "Release workflow YAML invalid"
                fi
            else
                log_skip "YAML validation (PyYAML module not installed)"
            fi
        elif command -v ruby >/dev/null 2>&1; then
            # Try Ruby as fallback
            if ruby -e "require 'yaml'; YAML.load_file('.github/workflows/release.yml')" 2>/dev/null; then
                log_success "Release workflow YAML valid"
            else
                log_error "Release workflow YAML invalid"
            fi
        else
            log_skip "YAML validation (no parser available)"
        fi
    else
        log_error "Release workflow missing"
    fi
}

# Test 8: Binary execution (current platform)
test_binary_execution() {
    log_info "Testing binary execution on current platform..."
    
    if [ ! -d "$REPO_ROOT/dist" ]; then
        log_skip "Binary execution test (no binaries built)"
        return 0
    fi
    
    cd "$REPO_ROOT"
    
    # Detect current platform
    local os=$(uname -s | tr '[:upper:]' '[:lower:]')
    local arch=$(uname -m)
    
    # Map to GoReleaser naming
    case "$os" in
        darwin) os="darwin" ;;
        linux) os="linux" ;;
        *) log_skip "Binary execution test (unsupported OS: $os)"; return 0 ;;
    esac
    
    case "$arch" in
        x86_64) arch="amd64" ;;
        aarch64|arm64) arch="arm64" ;;
        *) log_skip "Binary execution test (unsupported arch: $arch)"; return 0 ;;
    esac
    
    # Find the binary
    local binary_path
    for dir in dist/*; do
        if [[ -d "$dir" && "$dir" == *"${os}_${arch}"* ]]; then
            binary_path="$dir/claude-gate"
            break
        fi
    done
    
    if [ -z "$binary_path" ] || [ ! -f "$binary_path" ]; then
        log_error "Binary not found for $os/$arch"
        return 1
    fi
    
    # Test execution
    if "$binary_path" version >/dev/null 2>&1; then
        log_success "Binary executes: $binary_path"
        
        # Test help command
        if "$binary_path" --help >/dev/null 2>&1; then
            log_success "Binary help command works"
        else
            log_error "Binary help command failed"
        fi
    else
        log_error "Binary execution failed: $binary_path"
    fi
}

# Test 9: Error handling
test_error_handling() {
    log_info "Testing error handling..."
    
    cd "$REPO_ROOT/npm"
    
    # Test unsupported platform error
    local error_output=$(node -e "
        const originalPlatform = process.platform;
        Object.defineProperty(process, 'platform', {value: 'freebsd', configurable: true});
        const {getPlatform} = require('./scripts/install.js');
        try { getPlatform(); } catch(e) { console.log('ERROR_CAUGHT'); }
    " 2>&1)
    
    if [[ "$error_output" == *"ERROR_CAUGHT"* ]]; then
        log_success "Unsupported platform error handling"
    else
        log_error "Unsupported platform error not caught"
    fi
}

# Test 10: Scripts permissions
test_script_permissions() {
    log_info "Testing script permissions..."
    
    cd "$REPO_ROOT"
    
    local scripts=(
        "scripts/build-release.sh"
        "scripts/test-npm-local.sh"
        "scripts/setup-npm-auth.sh"
        "scripts/update-version.sh"
    )
    
    for script in "${scripts[@]}"; do
        if [ -x "$script" ]; then
            log_success "Script executable: $script"
        else
            log_error "Script not executable: $script"
        fi
    done
}

# Generate test report
generate_report() {
    echo ""
    echo "========================================"
    echo "Test Report"
    echo "========================================"
    echo "Total Tests: $((PASSED + FAILED + SKIPPED))"
    echo -e "Passed: ${GREEN}$PASSED${NC}"
    echo -e "Failed: ${RED}$FAILED${NC}"
    echo -e "Skipped: ${YELLOW}$SKIPPED${NC}"
    echo ""
    
    if [ $FAILED -gt 0 ]; then
        echo "Failed Tests:"
        for i in "${!TEST_NAMES[@]}"; do
            if [ "${TEST_STATUSES[$i]}" = "FAILED" ]; then
                echo -e "  ${RED}✗${NC} ${TEST_NAMES[$i]}"
            fi
        done
        echo ""
    fi
    
    if [ $FAILED -eq 0 ]; then
        echo -e "${GREEN}All tests passed!${NC}"
        return 0
    else
        echo -e "${RED}Some tests failed!${NC}"
        return 1
    fi
}

# Main test execution
main() {
    echo "Claude Gate - Cross-Platform Build & NPM Distribution Tests"
    echo "==========================================================="
    echo ""
    
    check_prerequisites
    echo ""
    
    # Run all tests
    test_go_build
    test_goreleaser_build
    test_npm_package_structure
    test_npm_install_script
    test_npm_local_package
    test_package_json_validation
    test_github_actions
    test_binary_execution
    test_error_handling
    test_script_permissions
    
    # Generate report
    generate_report
}

# Run tests
main
// End of scripts/test-all.sh

=====================

// File: scripts/test-docker.sh

#!/bin/bash
# Test Claude Gate NPM package in Docker containers for different platforms

set -e

# Colors
GREEN='\033[0;32m'
RED='\033[0;31m'
YELLOW='\033[1;33m'
NC='\033[0m'

# Get script directory
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
REPO_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"

echo "Testing Claude Gate NPM package in Docker containers..."
echo "======================================================="

# Check if Docker is available
if ! command -v docker >/dev/null 2>&1; then
    echo -e "${RED}Docker is not installed or not running${NC}"
    exit 1
fi

# Build the NPM package first
echo -e "\n${YELLOW}Building NPM package...${NC}"
cd "$REPO_ROOT"

# Check if binaries exist
if [ ! -d "dist" ]; then
    echo "No dist directory found. Building with GoReleaser first..."
    if command -v goreleaser >/dev/null 2>&1; then
        goreleaser build --snapshot --clean
    else
        echo -e "${RED}GoReleaser not installed. Please install it first.${NC}"
        exit 1
    fi
fi

# Create test package
cd npm
npm pack
PACKAGE_FILE="claude-gate-0.1.0.tgz"
mv "$PACKAGE_FILE" "$REPO_ROOT/"
cd "$REPO_ROOT"

# Test function
test_platform() {
    local platform=$1
    local node_version=$2
    local docker_platform=$3
    
    echo -e "\n${YELLOW}Testing $platform with Node.js $node_version...${NC}"
    
    # Create test script
    cat > test-docker-install.sh << 'EOF'
#!/bin/sh
set -e

echo "Platform: $(uname -s) $(uname -m)"
echo "Node.js: $(node --version)"
echo "npm: $(npm --version)"

# Install the package
echo "Installing claude-gate..."
npm install -g /app/claude-gate-0.1.0.tgz

# Test if installed
echo "Testing installation..."
which claude-gate
claude-gate version || echo "Binary execution failed (expected on different arch)"

# Test help
claude-gate --help || echo "Help command failed"

# Check what was installed
echo "Checking installed files..."
ls -la $(npm root -g)/claude-gate/bin/

# Test uninstall
echo "Testing uninstall..."
npm uninstall -g claude-gate

echo "Test completed successfully!"
EOF

    chmod +x test-docker-install.sh
    
    # Run Docker test
    local docker_cmd="docker run --rm -v $REPO_ROOT:/app -w /app"
    
    if [ -n "$docker_platform" ]; then
        docker_cmd="$docker_cmd --platform $docker_platform"
    fi
    
    if $docker_cmd node:$node_version sh test-docker-install.sh; then
        echo -e "${GREEN}✓ $platform test passed${NC}"
        return 0
    else
        echo -e "${RED}✗ $platform test failed${NC}"
        return 1
    fi
}

# Run tests for different platforms
TESTS_PASSED=0
TESTS_FAILED=0

# Linux x64
if test_platform "Linux x64" "20" "linux/amd64"; then
    ((TESTS_PASSED++))
else
    ((TESTS_FAILED++))
fi

# Linux ARM64 (only if Docker supports it)
if docker run --rm --platform linux/arm64 alpine uname -m >/dev/null 2>&1; then
    if test_platform "Linux ARM64" "20" "linux/arm64"; then
        ((TESTS_PASSED++))
    else
        ((TESTS_FAILED++))
    fi
else
    echo -e "\n${YELLOW}Skipping Linux ARM64 test (platform not supported by Docker)${NC}"
fi

# Test with different Node.js versions
for node_version in 18 22; do
    if test_platform "Linux x64 (Node $node_version)" "$node_version" "linux/amd64"; then
        ((TESTS_PASSED++))
    else
        ((TESTS_FAILED++))
    fi
done

# Test --ignore-scripts flag
echo -e "\n${YELLOW}Testing with --ignore-scripts flag...${NC}"
docker run --rm -v "$REPO_ROOT:/app" -w /app node:20 sh -c "
    npm install -g /app/claude-gate-0.1.0.tgz --ignore-scripts
    # The fallback should kick in when running
    claude-gate version 2>&1 | grep -E '(Binary not found|Running installation|version)' && echo 'Fallback mechanism works'
    npm uninstall -g claude-gate
"

if [ $? -eq 0 ]; then
    echo -e "${GREEN}✓ --ignore-scripts test passed${NC}"
    ((TESTS_PASSED++))
else
    echo -e "${RED}✗ --ignore-scripts test failed${NC}"
    ((TESTS_FAILED++))
fi

# Cleanup
rm -f test-docker-install.sh
rm -f "$REPO_ROOT/claude-gate-0.1.0.tgz"

# Summary
echo -e "\n========================================"
echo "Docker Test Summary"
echo "========================================"
echo -e "Tests passed: ${GREEN}$TESTS_PASSED${NC}"
echo -e "Tests failed: ${RED}$TESTS_FAILED${NC}"

if [ $TESTS_FAILED -eq 0 ]; then
    echo -e "\n${GREEN}All Docker tests passed!${NC}"
    exit 0
else
    echo -e "\n${RED}Some Docker tests failed!${NC}"
    exit 1
fi
// End of scripts/test-docker.sh

=====================

// File: scripts/test-edge-cases.sh

#!/bin/bash
# Test edge cases for Claude Gate NPM distribution

set -e

# Colors
GREEN='\033[0;32m'
RED='\033[0;31m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

# Get script directory
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
REPO_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"

echo "Claude Gate - Edge Case Testing"
echo "==============================="

PASSED=0
FAILED=0

log_test() {
    echo -e "\n${BLUE}TEST:${NC} $1"
}

log_pass() {
    echo -e "${GREEN}✓ PASS:${NC} $1"
    ((PASSED++))
}

log_fail() {
    echo -e "${RED}✗ FAIL:${NC} $1"
    ((FAILED++))
}

# Test 1: Missing platform binary
log_test "Missing platform binary"
(
    cd "$REPO_ROOT/npm"
    # Temporarily rename install.js to test error
    cp scripts/install.js scripts/install.js.bak
    
    # Modify to simulate missing binary
    cat > scripts/install.js << 'EOF'
#!/usr/bin/env node
const {getPlatform} = require('./install.js.bak');
// Override findBinary to always return null
require('./install.js.bak').findBinary = () => null;
require('./install.js.bak').install();
EOF
    
    # Test if error message is helpful
    if node scripts/install.js 2>&1 | grep -q "Could not find platform binary"; then
        log_pass "Missing binary error message"
    else
        log_fail "Missing binary error message"
    fi
    
    # Restore
    mv scripts/install.js.bak scripts/install.js
)

# Test 2: Corrupted package.json
log_test "Corrupted package.json handling"
(
    cd "$REPO_ROOT"
    # Create temp directory
    TEMP_DIR=$(mktemp -d)
    cp -r npm/* "$TEMP_DIR/"
    
    # Corrupt the package.json
    echo "{ invalid json" > "$TEMP_DIR/package.json"
    
    cd "$TEMP_DIR"
    if npm pack 2>&1 | grep -q -E "(Failed to parse|Unexpected token)"; then
        log_pass "Corrupted package.json detected"
    else
        log_fail "Corrupted package.json not detected"
    fi
    
    rm -rf "$TEMP_DIR"
)

# Test 3: Permission denied on binary
log_test "Permission denied on binary"
(
    if [ "$OSTYPE" = "msys" ] || [ "$OSTYPE" = "win32" ]; then
        log_pass "Permission test (skipped on Windows)"
    else
        cd "$REPO_ROOT/npm"
        TEMP_BIN=$(mktemp)
        echo "#!/bin/sh" > "$TEMP_BIN"
        chmod 000 "$TEMP_BIN"
        
        # Test if we handle permission errors gracefully
        if ! "$TEMP_BIN" 2>&1 | grep -q "Permission denied"; then
            log_fail "Permission error not detected"
        else
            log_pass "Permission error handling"
        fi
        
        rm -f "$TEMP_BIN"
    fi
)

# Test 4: Very long path names
log_test "Very long path names"
(
    # Create a very long path
    LONG_PATH="$REPO_ROOT"
    for i in {1..20}; do
        LONG_PATH="$LONG_PATH/very_long_directory_name_that_exceeds_normal_limits"
    done
    
    # Don't actually create it, just test path length handling
    if [ ${#LONG_PATH} -gt 1000 ]; then
        log_pass "Long path test setup"
    else
        log_fail "Long path test setup"
    fi
)

# Test 5: Unicode in paths
log_test "Unicode characters in paths"
(
    UNICODE_DIR="$REPO_ROOT/测试目录_🚀"
    mkdir -p "$UNICODE_DIR"
    
    if [ -d "$UNICODE_DIR" ]; then
        log_pass "Unicode directory creation"
        rm -rf "$UNICODE_DIR"
    else
        log_fail "Unicode directory creation"
    fi
)

# Test 6: Concurrent installations
log_test "Concurrent installation attempts"
(
    cd "$REPO_ROOT/npm"
    
    # Try to run install script multiple times concurrently
    node scripts/install.js > /dev/null 2>&1 &
    PID1=$!
    node scripts/install.js > /dev/null 2>&1 &
    PID2=$!
    
    # Wait for both
    wait $PID1
    RESULT1=$?
    wait $PID2
    RESULT2=$?
    
    # At least one should succeed
    if [ $RESULT1 -eq 0 ] || [ $RESULT2 -eq 0 ]; then
        log_pass "Concurrent installation handling"
    else
        log_fail "Concurrent installation handling"
    fi
)

# Test 7: Invalid Node.js version
log_test "Old Node.js version warning"
(
    # Check if package.json has engines field
    if grep -q '"engines"' "$REPO_ROOT/npm/package.json"; then
        log_pass "Node.js version requirement specified"
    else
        log_fail "Node.js version requirement missing"
    fi
)

# Test 8: Network timeout simulation
log_test "Network timeout handling"
(
    # This would require actual network mocking
    # For now, just check if timeout handling exists in code
    if grep -q -i "timeout" "$REPO_ROOT/npm/scripts/install.js"; then
        log_pass "Timeout handling code exists"
    else
        log_fail "No timeout handling found"
    fi
)

# Test 9: Disk space check
log_test "Disk space considerations"
(
    # Check if we document space requirements
    if grep -q -E "(size|space|MB)" "$REPO_ROOT/README.md"; then
        log_pass "Disk space documented"
    else
        log_fail "Disk space not documented"
    fi
)

# Test 10: Signal handling
log_test "Signal handling during installation"
(
    cd "$REPO_ROOT/npm"
    
    # Start installation and send signal
    node scripts/install.js > /dev/null 2>&1 &
    PID=$!
    sleep 0.1
    
    # Check if process exists before killing
    if kill -0 $PID 2>/dev/null; then
        kill -TERM $PID 2>/dev/null
        wait $PID 2>/dev/null
        log_pass "Signal handling (process terminated)"
    else
        log_pass "Signal handling (process completed quickly)"
    fi
)

# Test 11: Version mismatch
log_test "Version mismatch detection"
(
    # Check if versions are consistent
    GO_VERSION=$(grep -E 'var version = ".*"' "$REPO_ROOT/cmd/claude-gate/main.go" | sed 's/.*"\(.*\)".*/\1/')
    NPM_VERSION=$(node -e "console.log(require('$REPO_ROOT/npm/package.json').version)")
    
    if [ "$GO_VERSION" = "$NPM_VERSION" ]; then
        log_pass "Version consistency"
    else
        log_fail "Version mismatch: Go=$GO_VERSION, NPM=$NPM_VERSION"
    fi
)

# Test 12: Symlink handling
log_test "Symlink handling"
(
    if [ "$OSTYPE" = "msys" ] || [ "$OSTYPE" = "win32" ]; then
        log_pass "Symlink test (skipped on Windows)"
    else
        TEMP_LINK=$(mktemp -d)/link
        ln -s "$REPO_ROOT/npm" "$TEMP_LINK"
        
        if [ -L "$TEMP_LINK" ]; then
            log_pass "Symlink creation"
            rm -f "$TEMP_LINK"
        else
            log_fail "Symlink creation"
        fi
    fi
)

# Summary
echo -e "\n========================================"
echo "Edge Case Test Summary"
echo "========================================"
echo -e "Tests passed: ${GREEN}$PASSED${NC}"
echo -e "Tests failed: ${RED}$FAILED${NC}"

if [ $FAILED -eq 0 ]; then
    echo -e "\n${GREEN}All edge case tests passed!${NC}"
    exit 0
else
    echo -e "\n${RED}Some edge case tests failed!${NC}"
    exit 1
fi
// End of scripts/test-edge-cases.sh

=====================

// File: scripts/test-npm-local.sh

#!/bin/bash
set -e

# Script to test NPM package locally without publishing

echo "🧪 Testing NPM package locally..."

# Get current directory
REPO_ROOT=$(cd "$(dirname "$0")/.." && pwd)
cd "$REPO_ROOT"

# Build binaries first
if [ ! -d "dist" ]; then
    echo "No dist directory found. Building binaries first..."
    ./scripts/build-release.sh
fi

# Create temporary directory for testing
TEST_DIR=$(mktemp -d)
echo "Using test directory: $TEST_DIR"

# Function to clean up on exit
cleanup() {
    echo "Cleaning up..."
    rm -rf "$TEST_DIR"
}
trap cleanup EXIT

# Copy NPM package files
echo "Copying NPM package files..."
cp -r npm/* "$TEST_DIR/"

# Create platform packages directory
mkdir -p "$TEST_DIR/node_modules/@claude-gate"

# Extract and copy binaries to simulate platform packages
echo "Preparing platform packages..."

# Find the version from the archive names (e.g., 0.0.1-next)
VERSION=$(ls dist/*.tar.gz 2>/dev/null | head -1 | sed -E 's/.*claude-gate_([^_]+)_.*/\1/' || echo "snapshot")

# macOS Intel
DARWIN_X64_ARCHIVE=$(ls dist/claude-gate_*_Darwin_x86_64.tar.gz 2>/dev/null | head -1)
if [ -f "$DARWIN_X64_ARCHIVE" ]; then
    mkdir -p "$TEST_DIR/node_modules/@claude-gate/darwin-x64"
    tar -xzf "$DARWIN_X64_ARCHIVE" -C "$TEST_DIR/node_modules/@claude-gate/darwin-x64" --strip-components=1
    mv "$TEST_DIR/node_modules/@claude-gate/darwin-x64/claude-gate" "$TEST_DIR/node_modules/@claude-gate/darwin-x64/bin" 2>/dev/null || true
fi

# macOS ARM
DARWIN_ARM64_ARCHIVE=$(ls dist/claude-gate_*_Darwin_arm64.tar.gz 2>/dev/null | head -1)
if [ -f "$DARWIN_ARM64_ARCHIVE" ]; then
    mkdir -p "$TEST_DIR/node_modules/@claude-gate/darwin-arm64"
    tar -xzf "$DARWIN_ARM64_ARCHIVE" -C "$TEST_DIR/node_modules/@claude-gate/darwin-arm64" --strip-components=1
    mv "$TEST_DIR/node_modules/@claude-gate/darwin-arm64/claude-gate" "$TEST_DIR/node_modules/@claude-gate/darwin-arm64/bin" 2>/dev/null || true
fi

# Linux x64
LINUX_X64_ARCHIVE=$(ls dist/claude-gate_*_Linux_x86_64.tar.gz 2>/dev/null | head -1)
if [ -f "$LINUX_X64_ARCHIVE" ]; then
    mkdir -p "$TEST_DIR/node_modules/@claude-gate/linux-x64"
    tar -xzf "$LINUX_X64_ARCHIVE" -C "$TEST_DIR/node_modules/@claude-gate/linux-x64" --strip-components=1
    mv "$TEST_DIR/node_modules/@claude-gate/linux-x64/claude-gate" "$TEST_DIR/node_modules/@claude-gate/linux-x64/bin" 2>/dev/null || true
fi

# Linux ARM64
LINUX_ARM64_ARCHIVE=$(ls dist/claude-gate_*_Linux_arm64.tar.gz 2>/dev/null | head -1)
if [ -f "$LINUX_ARM64_ARCHIVE" ]; then
    mkdir -p "$TEST_DIR/node_modules/@claude-gate/linux-arm64"
    tar -xzf "$LINUX_ARM64_ARCHIVE" -C "$TEST_DIR/node_modules/@claude-gate/linux-arm64" --strip-components=1
    mv "$TEST_DIR/node_modules/@claude-gate/linux-arm64/claude-gate" "$TEST_DIR/node_modules/@claude-gate/linux-arm64/bin" 2>/dev/null || true
fi

# # Windows - commented out as Windows is not supported
# WINDOWS_ARCHIVE=$(ls dist/claude-gate_*_Windows_x86_64.zip 2>/dev/null | head -1)
# if [ -f "$WINDOWS_ARCHIVE" ]; then
#     mkdir -p "$TEST_DIR/node_modules/@claude-gate/win32-x64"
#     unzip -q "$WINDOWS_ARCHIVE" -d "$TEST_DIR/node_modules/@claude-gate/win32-x64"
#     mv "$TEST_DIR/node_modules/@claude-gate/win32-x64/claude-gate.exe" "$TEST_DIR/node_modules/@claude-gate/win32-x64/bin.exe" 2>/dev/null || true
# fi

# Run install script
echo ""
echo "Running install script..."
cd "$TEST_DIR"
node scripts/install.js

# Test the binary
echo ""
echo "Testing installed binary..."
if [ -f "bin/claude-gate" ]; then
    echo "✅ Binary wrapper found"
    
    # Try running it
    echo "Testing command execution..."
    ./bin/claude-gate version || echo "Note: Binary execution test failed (this is expected if built for different platform)"
else
    echo "❌ Binary wrapper not found!"
    ls -la bin/
fi

# Create npm package for testing
echo ""
echo "Creating test package..."
npm pack

echo ""
echo "✅ Local NPM package test complete!"
echo ""
echo "To test global installation:"
echo "  npm install -g $TEST_DIR/claude-gate-0.1.0.tgz"
echo ""
echo "Package file created at: $TEST_DIR/claude-gate-0.1.0.tgz"
// End of scripts/test-npm-local.sh

=====================

// File: scripts/update-version.sh

#!/bin/bash
set -e

# Script to update version across all files

if [ $# -eq 0 ]; then
    echo "Usage: $0 <version>"
    echo "Example: $0 0.2.0"
    exit 1
fi

VERSION=$1

# Validate version format
if ! [[ "$VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9\.\-]+)?$ ]]; then
    echo "Error: Invalid version format. Use semantic versioning (e.g., 1.0.0, 1.0.0-beta.1)"
    exit 1
fi

echo "Updating version to $VERSION..."

# Update Go source
echo "Updating cmd/claude-gate/main.go..."
if [[ "$OSTYPE" == "darwin"* ]]; then
    # macOS
    sed -i '' "s/var version = \".*\"/var version = \"$VERSION\"/" cmd/claude-gate/main.go
else
    # Linux
    sed -i "s/var version = \".*\"/var version = \"$VERSION\"/" cmd/claude-gate/main.go
fi

# Update main NPM package
echo "Updating npm/package.json..."
if [[ "$OSTYPE" == "darwin"* ]]; then
    sed -i '' "s/\"version\": \".*\"/\"version\": \"$VERSION\"/" npm/package.json
    sed -i '' "s/\"@claude-gate\/darwin-x64\": \".*\"/\"@claude-gate\/darwin-x64\": \"$VERSION\"/" npm/package.json
    sed -i '' "s/\"@claude-gate\/darwin-arm64\": \".*\"/\"@claude-gate\/darwin-arm64\": \"$VERSION\"/" npm/package.json
    sed -i '' "s/\"@claude-gate\/linux-x64\": \".*\"/\"@claude-gate\/linux-x64\": \"$VERSION\"/" npm/package.json
    sed -i '' "s/\"@claude-gate\/linux-arm64\": \".*\"/\"@claude-gate\/linux-arm64\": \"$VERSION\"/" npm/package.json
else
    sed -i "s/\"version\": \".*\"/\"version\": \"$VERSION\"/" npm/package.json
    sed -i "s/\"@claude-gate\/darwin-x64\": \".*\"/\"@claude-gate\/darwin-x64\": \"$VERSION\"/" npm/package.json
    sed -i "s/\"@claude-gate\/darwin-arm64\": \".*\"/\"@claude-gate\/darwin-arm64\": \"$VERSION\"/" npm/package.json
    sed -i "s/\"@claude-gate\/linux-x64\": \".*\"/\"@claude-gate\/linux-x64\": \"$VERSION\"/" npm/package.json
    sed -i "s/\"@claude-gate\/linux-arm64\": \".*\"/\"@claude-gate\/linux-arm64\": \"$VERSION\"/" npm/package.json
fi

# Update platform packages
for platform in darwin-x64 darwin-arm64 linux-x64 linux-arm64; do
    echo "Updating npm/platforms/$platform/package.json..."
    if [[ "$OSTYPE" == "darwin"* ]]; then
        sed -i '' "s/\"version\": \".*\"/\"version\": \"$VERSION\"/" "npm/platforms/$platform/package.json"
    else
        sed -i "s/\"version\": \".*\"/\"version\": \"$VERSION\"/" "npm/platforms/$platform/package.json"
    fi
done

# Update npm/index.js
echo "Updating npm/index.js..."
if [[ "$OSTYPE" == "darwin"* ]]; then
    sed -i '' "s/version: '.*'/version: '$VERSION'/" npm/index.js
else
    sed -i "s/version: '.*'/version: '$VERSION'/" npm/index.js
fi

echo ""
echo "✅ Version updated to $VERSION in all files!"
echo ""
echo "Next steps:"
echo "1. Review changes: git diff"
echo "2. Run tests: make test"
echo "3. Build snapshot: make snapshot"
echo "4. Test NPM package: make npm-test"
echo "5. Commit: git add -A && git commit -m \"chore: bump version to $VERSION\""
echo "6. Tag: git tag -a v$VERSION -m \"Release v$VERSION\""
echo "7. Push: git push origin main && git push origin v$VERSION"
// End of scripts/update-version.sh

=====================

